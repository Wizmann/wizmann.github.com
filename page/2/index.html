<!doctype html><html lang=zh-cn dir=auto><head><meta name=generator content="Hugo 0.146.0"><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>利用Arduino制作脚踏板Fn层开关</h2></header><div class=entry-content><p>背景 之前焊了两个客制化键盘，一个是ErgoDone，一个是仿minila配列的60键盘。这两个键盘的共同特点是双手大拇指各有一个额外的开关，我将其做为Fn层的开关，用来开启两个fn层：Vim和NumPad（是啥并不重要，可以理解为功能键的重映射）。
...</p></div><footer class=entry-footer><span title='2021-04-08 00:00:00 +0000 UTC'>April 8, 2021</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 利用Arduino制作脚踏板Fn层开关" href=https://wizmann.top/posts/arduino-foot-pedal-for-fn-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>我到底从UW-CSE341学到了什么</h2></header><div class=entry-content><p>TL;DR 什么也没学到
课程首页
Coursera-课程-A, B, C
介绍当中说，本课程主要内容是FP，并且顺道讨论一下程序语言的设计。
UW官方上面的课程只有Slides和assignments，video不提供。Coursera有video，但是版本比较老，是2013年的。下面的讨论都是基于au20的新版本。
...</p></div><footer class=entry-footer><span title='2020-12-29 00:00:00 +0000 UTC'>December 29, 2020</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 我到底从UW-CSE341学到了什么" href=https://wizmann.top/posts/uw-cse341-au20/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Introduction to Ceph</h2></header><div class=entry-content><p>什么是Ceph Ceph是一个可扩展的，高性能的分布式存储系统。提供了三种不同类型的接口以适应不同的应用场景：
block-based: 块存储，可以用做VM的虚拟磁盘 object-based: 对象存储，与Amazon S3等常用对象存储兼容 file system: POSIX兼容的分布式文件系统，可以被本地系统挂载，并且能被多个客户端共享 ...</p></div><footer class=entry-footer><span title='2020-11-29 00:00:00 +0000 UTC'>November 29, 2020</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Introduction to Ceph" href=https://wizmann.top/posts/introduction-to-ceph/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>2020 计蒜之道 线上决赛 - C. 攀登山峰</h2></header><div class=entry-content><p>本文使用了一种概率算法，不是正解，只求骗分。
题意 原题
给一个长度为n的数组A[1…n]。
现在有q个查询请求（q &lt;= 1e5），每个请求给定一个长度为m的子数组A[i…j]和一个整数t。问在子数组中出现次数超过m/t的数字中（t &lt;= 20），最大的数是多少。
...</p></div><footer class=entry-footer><span title='2020-10-26 00:00:00 +0000 UTC'>October 26, 2020</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 2020 计蒜之道 线上决赛 - C. 攀登山峰" href=https://wizmann.top/posts/jisuanke-climb-the-hill/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>6.824 Lab 2: Raft协议实现指南 （无剧透版）</h2></header><div class=entry-content><p>背景 MIT6.824是一个用来学习分布式系统的非常好的资源。其中第二个课程作业就是关于Raft算法。
由于在工作中涉及到分布一致性算法的调研，接触了paxos/raft算法。然后被@neutronest安利了一发，于是开始着手实现这个作业。
...</p></div><footer class=entry-footer><span title='2019-05-02 21:33:00 +0000 UTC'>May 2, 2019</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 6.824 Lab 2: Raft协议实现指南 （无剧透版）" href=https://wizmann.top/posts/raft-lab-mit-6.824/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>白话一致性协议 - Paxos、Raft和PacificA[2]</h2></header><div class=entry-content><p>PacificA是一个框架 虽然在题目中我们把Paxos、Raft和PacificA并列，但是Paxos和Raft在论文中称自己为一种“算法”（algorithm）；而PacificA对自己的定位是一种通用的，强一致的数据同步框架。
...</p></div><footer class=entry-footer><span title='2019-02-18 00:00:00 +0000 UTC'>February 18, 2019</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 白话一致性协议 - Paxos、Raft和PacificA[2]" href=https://wizmann.top/posts/paxos-raft-pecifaca2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>C++类型擦除与`std::function`性能探索</h2></header><div class=entry-content><p>什么是类型擦除 对于Python这种动态类型语言来说，是不存在“类型擦除”这个概念的。Python对象的行为并不由接口定义，而是由“当前方法和属性的集合”决定。
...</p></div><footer class=entry-footer><span title='2019-02-01 00:00:00 +0000 UTC'>February 1, 2019</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to C++类型擦除与`std::function`性能探索" href=https://wizmann.top/posts/cpp-type-erasure-and-std-function/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>在WSL中获取Windows剪贴板中的图片</h2></header><div class=entry-content><p>背景 Win10里面的WSL（Windows Subsystem For Linux)算是一个开发神器了，虽然功能不是100%完善，但是对于轻度开发已经足够了。现在我的日常开发，就是一个全屏CMD跑内部工具，一个全屏WSL跑tmux+vim。
...</p></div><footer class=entry-footer><span title='2019-01-04 00:00:00 +0000 UTC'>January 4, 2019</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 在WSL中获取Windows剪贴板中的图片" href=https://wizmann.top/posts/get-image-from-clipboard-in-wsl.md/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>白话一致性协议 - Paxos、Raft和PacificA[1]</h2></header><div class=entry-content><p>书接上文 - Multi Paxos 在上一篇文章中，我们提到了Basic Paxos和Multi Paxos的异同。在Paxos Made Simple论文中，作者提到了Multi Paxos的一种实现。这个实现允许我们对一个连续的数据流（也可以称为复制日志，replicated log）达成共识，从而实现节点状态的一致性复制。
...</p></div><footer class=entry-footer><span title='2018-12-05 00:00:00 +0000 UTC'>December 5, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 白话一致性协议 - Paxos、Raft和PacificA[1]" href=https://wizmann.top/posts/paxos-raft-pecifaca1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>白话一致性协议 - Paxos、Raft和PacificA[0]</h2></header><div class=entry-content><p>一致性协议 - Paxos 在分布式系统当中，我们往往需要保持节点之间的一致性。在绝大多数情况下，我们需要让系统中的节点相互协调通力合作，有可能的让系统正确的工作。但是，由于分布式系统本身的特性，需要我们在不可靠的硬件上尽可能的构建可靠的系统。所以，看似简单的一致性问题成为了分布式系统领域的一个重要的课题。
...</p></div><footer class=entry-footer><span title='2018-11-25 00:00:00 +0000 UTC'>November 25, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 白话一致性协议 - Paxos、Raft和PacificA[0]" href=https://wizmann.top/posts/paxos-raft-pecifaca0/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>七牛云图床自救指南（附github图床小工具）</h2></header><div class=entry-content><p>背景 之前一直在用七牛云的存储做图床（简称白嫖）。但是免费的午餐必然不会长久，七牛要求所有bucket都要绑定备案过的域名，否则就停掉你的bucket的外链。这事我也不吐槽，毕竟是白嫖，也不能要求啥。
...</p></div><footer class=entry-footer><span title='2018-11-16 22:23:00 +0000 UTC'>November 16, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 七牛云图床自救指南（附github图床小工具）" href=https://wizmann.top/posts/qnsaver/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>容斥原理以及一些题目</h2></header><div class=entry-content><p>什么是容斥原理 容斥原理是一种计数手段。例如在下图中，我们想不重复、不遗漏的求出包含在ABC三个集合中所包含的元素的个数，应该使用怎么样的方法呢？
这个问题对于我们来说并不陌生，当然也并不困难。直观的方法是把所有的元素计数，再把重复的元素排除出去。这种计数的方法，有“容”有“斥”，我们讲其称做“容斥原理”。
...</p></div><footer class=entry-footer><span title='2018-10-14 00:00:00 +0000 UTC'>October 14, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 容斥原理以及一些题目" href=https://wizmann.top/posts/inclusive-exclusive-principle/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>实现一个无锁消息队列</h2></header><div class=entry-content><p>240414更新：后续补充了一篇勘误文章，见这里
目标 实现一个多读多写的无锁消息队列。
cmpxchg - 比较并替换 比较并替换（compare-and-swap, CAS）是一个用于多线程同步的原子操作。
...</p></div><footer class=entry-footer><span title='2018-05-02 00:39:00 +0000 UTC'>May 2, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 实现一个无锁消息队列" href=https://wizmann.top/posts/implement-non-blocking-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>一种区间交问题的奇怪姿势</h2></header><div class=entry-content><p>Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题：
给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么
...</p></div><footer class=entry-footer><span title='2018-02-20 22:59:47 +0000 UTC'>February 20, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 一种区间交问题的奇怪姿势" href=https://wizmann.top/posts/range-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Bw-Tree：在新硬件平台上的新B-Tree</h2></header><div class=entry-content><p>ARS 与 Bw-Tree nosql数据库从本质上说，都属于ARS（Atomic Record Stores，“原子记录存储”）。
最常见的“原子记录存储”一种实现就是朴素的Hash表：通过一个特定的key，来读写一条独立的数据记录。
...</p></div><footer class=entry-footer><span title='2017-12-18 00:49:00 +0000 UTC'>December 18, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Bw-Tree：在新硬件平台上的新B-Tree" href=https://wizmann.top/posts/bw-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Windows Azure Storage Made Simple</h2></header><div class=entry-content><p>加机器就是一把梭 没有什么问题是加一千台机器解决不了的，如果有，就再加一千台。 —— 《21天精通分布式系统》
分布式系统在设计之初，是为了解决单机系统的可用性和可扩展性问题的。
...</p></div><footer class=entry-footer><span title='2017-10-11 21:12:15 +0000 UTC'>October 11, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Windows Azure Storage Made Simple" href=https://wizmann.top/posts/azure-storage-made-simple/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Metaprogramming in .NET 读书笔记 - 1</h2></header><div class=entry-content><p>什么是 Metaprogramming (元编程) 元编程从字面上理解就是“能处理程序的程序”。
这里的“处理”，有两个意思。
一是“编写”、“生成”，最经典例子就是编译器，它将我们的所编写的高级语言翻译成机器代码。编译器就像建筑工人，将“蓝图”（高级语言）转化成“高楼大厦”（机器语言）。还有一个我们经常用到的就是“宏”(Macro)。我们可以在代码中使用预先编写好的宏，在编译期，宏会被自动展开成相应的代码。这样的好处是用机器带替人类劳动。
...</p></div><footer class=entry-footer><span title='2017-07-26 00:00:00 +0000 UTC'>July 26, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Metaprogramming in .NET 读书笔记 - 1" href=https://wizmann.top/posts/metaprogramming-in-dotnet-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Why do I quit Leetcode contest?</h2></header><div class=entry-content><p>Foreword The title is quite “Yin-ish” as it seems, but I’m not a “Yin-ist”. You know what I mean.
Why I quit? I did a quite a good job in Leetcode Weekly Contest, at least in my point of view. I won a 4th place and a 6th place in my 19 contests, and my highest global ranking is 49th.
It’s remarkable! According to all my poor results among all the online/offline programming contests, there is no reason for me to give up Leetcode contest which seems perfectly suitable for my capabilities.
...</p></div><footer class=entry-footer><span title='2017-06-07 01:53:42 +0000 UTC'>June 7, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Why do I quit Leetcode contest?" href=https://wizmann.top/posts/why-do-i-quit-leetcode-contest/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>STUP - the Implementation (3)</h2></header><div class=entry-content><p>throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?
...</p></div><footer class=entry-footer><span title='2017-05-08 22:15:58 +0000 UTC'>May 8, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to STUP - the Implementation (3)" href=https://wizmann.top/posts/stup-3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>STUP - Packet Structure and State Machine (2)</h2></header><div class=entry-content><p>STUP Packet Structure Brief Introduction of TCP & UDP Packet Structure STUP pretend itself as a protocol at the Transmission Layer, but actually it’s absolutely an Application Layer protocol. So before we start, I’d like to recall some knowledge of two important Transmission Layer protocol: TCP & UDP.
It is well known that TCP is a “connection-oriented”, “reliable”, “ordered”. To make an analogy (a little bit inappropriate), TCP is like a phone call (good cell signal strength):
...</p></div><footer class=entry-footer><span title='2017-05-04 00:53:03 +0000 UTC'>May 4, 2017</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to STUP - Packet Structure and State Machine (2)" href=https://wizmann.top/posts/stup-2/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wizmann.top/>«&nbsp;&nbsp;
</a><a class=next href=https://wizmann.top/page/3/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>