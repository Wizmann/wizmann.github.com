<!doctype html><html lang=zh-cn dir=auto><head><meta name=generator content="Hugo 0.146.0"><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>玩玩算法题1：Sherlock and Queries</h2></header><div class=entry-content><p>题目大意 给你三个数组:A[N], B[M], C[M]。让你按如下pseudo-code给出的规则计算，求出最终A[N]每一项的值。
f e o n r d i f e d o n o = r d 1 j i e d f n o t = d o j i 1 A f M % [ t j d o B ] o [ N i = ] d A o = [ = j ] 0 t h C e [ n i ] 数据范围 1≤ N,M ≤ 10^5
...</p></div><footer class=entry-footer><span title='2014-07-19 11:00:38 +0000 UTC'>July 19, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 玩玩算法题1：Sherlock and Queries" href=https://wizmann.top/posts/interview-problem-1-sherlock-and-queries/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #253 Tutorial</h2></header><div class=entry-content><p>443A - Anton and Letters Simple and easy, solved by two lines of python code.
ls = filter(lambda y: y, map(lambda x: x.strip(), raw_input()[1:-1].split(","))) print len(set(ls)) 443B - Kolya and Tandem Repeat Brute force. Just enumerate the beginning and the end of the substring, and check if that substring is tandem repeat.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;algorithm> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x string str; int k; int main() { freopen("input.txt", "r", stdin); input(str >> k); for (int i = 0; i &lt; k; i++) { str += '?'; } int len = str.length(); int ans = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == '?') { break; } for (int j = 1; i + j &lt; len; j += 2) { int slip = (j + 1) / 2; for (int k = 0; k &lt; slip; k++) { if (str[i + k] == str[i + k + slip] || str[i + k + slip] == '?') { /* pass */; } else { goto fail; } } ans = max(ans, j + 1); fail: /*pass*/; } } print(ans); return 0; } 442A - Borya and Hanabig Because Borya knows about the color and value of all his cards, he just need to distinguish each card from the others.
...</p></div><footer class=entry-footer><span title='2014-06-21 19:24:37 +0000 UTC'>June 21, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #253 Tutorial" href=https://wizmann.top/posts/cf-253/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>A simple problem - World at War</h2></header><div class=entry-content><p>Background This problem is from the book “Algorithm 4th edition” (Exersise 4.1.10)
There are N cities and M undirected roads between those cities. People can travel to any city along the roads.
One day, a war breaks out. Our cities are under attack! As we can’t defend all these N cities, the commander wants you to find the least important city, which means that if this city fell to the enemy, the traffic among other cities would not be affected.
...</p></div><footer class=entry-footer><span title='2014-06-12 17:42:51 +0000 UTC'>June 12, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to A simple problem - World at War" href=https://wizmann.top/posts/world-at-war/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>How to implement a queue with stack(s)?</h2></header><div class=entry-content><p>This problem is from the book Algorithms, 4th Edition.
Queue with three stacks. Implement a queue with three stacks so that each queue operation takes a constant (worst-case) number of stack operations.
Warning : high degree of difficulty.
When I search the Internet to find a solution, I find varieties of this problem, such as “implement a queue with ONE stack”, “implement a queue with TWO stack”, etc.
It is fun, indeed. I spent the whole morning to finding the solution of these problems. So, let’s rock.
...</p></div><footer class=entry-footer><span title='2014-05-20 13:23:03 +0000 UTC'>May 20, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to How to implement a queue with stack(s)?" href=https://wizmann.top/posts/implement-queue-with-stacks/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>内存屏障初探</h2></header><div class=entry-content><p>原文地址 Barrier February 17th, 2007
前言：多核时代的挑战 尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。
...</p></div><footer class=entry-footer><span title='2014-05-08 19:05:26 +0000 UTC'>May 8, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 内存屏障初探" href=https://wizmann.top/posts/read-paper-barrier/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #242 (Div. 2) Tutorials and Solutions</h2></header><div class=entry-content><p>A. Squats Trun x => X or X => x to make the number of ‘x’ is equal to the number of ‘X’.
n = int(raw_input()) hamsters = [c for c in raw_input()] sits = hamsters.count('x') stands = hamsters.count('X') if sits == stands: print 0 print ''.join(hamsters) else: if sits > stands: num = sits - n/2 key = 'x' else: num = stands - n/2 key = 'X' print num for i, c in enumerate(hamsters): if c == key: hamsters[i] = c.swapcase() num -= 1 if not num: break print ''.join(hamsters) B. Megacity Binary search.
...</p></div><footer class=entry-footer><span title='2014-04-30 17:39:00 +0000 UTC'>April 30, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #242 (Div. 2) Tutorials and Solutions" href=https://wizmann.top/posts/cf-242-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)</h2></header><div class=entry-content><p>Overview It has been months that I didn’t participate in the contest on CF, now I’m back. :)
This round of contest makes me confused that the problem B and C is a little bit too twisted, if you can’t catch the vital point, you will get a lot of WAs in the end.
Additionally, the problem D is too easy, just a simple DP and the time limit is too long for an unoptimized solution.
...</p></div><footer class=entry-footer><span title='2014-04-08 14:39:11 +0000 UTC'>April 8, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)" href=https://wizmann.top/posts/cf-240-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>alloca vs placement new</h2></header><div class=entry-content><p>WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.
...</p></div><footer class=entry-footer><span title='2014-04-07 21:08:59 +0000 UTC'>April 7, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to alloca vs placement new" href=https://wizmann.top/posts/alloca-vs-placement-new/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Quartile and Normal Distribution</h2></header><div class=entry-content><p>What is Quartile? Quartile is a concept of descriptive statics. The quartiles of a ranked data set are the three points that divide the data set into four equal groups, each group comprising a quarter of data.
Definitions first quartile (Q1) First quartile, also known as lower quartile, splits off the lowest 25% of data.
second quartile (Q2) Second quartile is the median of the data set, cuts data set in half.
...</p></div><footer class=entry-footer><span title='2014-03-09 22:44:15 +0000 UTC'>March 9, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Quartile and Normal Distribution" href=https://wizmann.top/posts/quartile-and-normal-distribution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>GeoHash算法</h2></header><div class=entry-content><p>GeoHash Geohash is a latitude/longitude geocode system invented by Gustavo Niemeyer when writing the web service at geohash.org, and put into the public domain. It is a hierarchical spatial data structure which subdivides space into buckets of grid shape.
简单说，GeoHash是一个将经纬度信息编码成一个string的算法。从而便于储存、查找。
...</p></div><footer class=entry-footer><span title='2014-02-04 00:10:00 +0000 UTC'>February 4, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to GeoHash算法" href=https://wizmann.top/posts/geo-hash-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>如何判断一个网站的地理信息</h2></header><div class=entry-content><p>啥？ 面试题：
有一个网站，如何判断这个网站的地理信息
方法 使用反向DNS 当我们只有网站的IP地址时，我们可以使用反向DNS来获得这个IP地址对应的域名。
反向域名解析，Reverse DNS。反向域名解析与通常的正向域名解析相反，提供IP地址到域名的对应。
...</p></div><footer class=entry-footer><span title='2014-01-24 00:00:00 +0000 UTC'>January 24, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 如何判断一个网站的地理信息" href=https://wizmann.top/posts/find-the-geo-location-of-a-host/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #223 (Div. 2) 不完全不正确题解</h2></header><div class=entry-content><p>由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱
事情一直很多，所以题解落后了好久才发。
A. Sereja and Dima 纯模拟，Python随便搞
...</p></div><footer class=entry-footer><span title='2014-01-18 14:47:00 +0000 UTC'>January 18, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #223 (Div. 2) 不完全不正确题解" href=https://wizmann.top/posts/cf-223-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>用Misaka做为pelican的Markdown解析器</h2></header><div class=entry-content><p>为啥？ Pelican内置python-markdown做为默认解析器，用来将用户的Markdown格式的文章转为网页格式展示。
然而，python-markdown模块的解析逻辑有严重的Bug。例如一个未标明语言的代码块会被标出很多莫名奇妙的错误；还有C++中的指针符号*会被解析为斜体的符号*SomeText*，在代码块中会产生大量和语法高亮无关的斜体字。
...</p></div><footer class=entry-footer><span title='2014-01-09 14:55:00 +0000 UTC'>January 9, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 用Misaka做为pelican的Markdown解析器" href=https://wizmann.top/posts/misaka-pelican/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>读书 - 《Head first 设计模式》</h2></header><div class=entry-content><p>豆瓣读书
为什么读这本书 在面XX家的时候，被问过一个设计模式问题。当时连面向对象都搞不懂，更不用说设计模式。
于是入了“四人帮”的设计模式来看，被里面的内容彻底搞晕。然后只能找了这本看起来很娱乐化的书来读。
这本书大概有600多页，比“四人帮”书厚很多。一个原因是这本书是“范例驱动”的，包含很多“项目”背景介绍，以及实现思路；第二个原因是，这本书的示例代码用的是Java。
...</p></div><footer class=entry-footer><span title='2014-01-03 00:00:00 +0000 UTC'>January 3, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 读书 - 《Head first 设计模式》" href=https://wizmann.top/posts/read-head-first-design-pattern/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>匈牙利算法</h2></header><div class=entry-content><p>概念 交错路 交错路：设P是图G的一条路，如果P的任意两条相邻的边一定是一条属于M而另一条不属于M，就称P是一条交错路。
通俗点来说，就是把一个图中的路径染成红黑两种。然后找出一条路，使这条路红黑交错。
...</p></div><footer class=entry-footer><span title='2014-01-01 22:01:00 +0000 UTC'>January 1, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 匈牙利算法" href=https://wizmann.top/posts/hungary-algorithm/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces 3C - Tic-tac-toe</h2></header><div class=entry-content><p>啥？ Tic-tac-toe是我很久之前在CF上做的一道题。非常考细心的模拟题。
最近有同学和我讨论过类似的问题。于是拿出来重新做一遍。练练手。
原题做法 没有任何“算法”成分。纯模拟。
又由于数据量实在是太小（3 × 3的矩阵），所以只要是思路正确。代码怎么写都能过。
...</p></div><footer class=entry-footer><span title='2013-12-29 20:23:00 +0000 UTC'>December 29, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces 3C - Tic-tac-toe" href=https://wizmann.top/posts/cf-3c-tic-tac-toe/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>How to "Rotate Image"?</h2></header><div class=entry-content><p>啥？ 原题戳我
Rotate Image
You are given an n x n 2D matrix representing an image.
Rotate the image by 90 degrees (clockwise).
Follow up:
Could you do this in-place?
示意图如下：
当然，矩阵中的数字不一定是规律的。
为什么要提出这个问题 自觉是一个不聪明的人（双低。。。&lt;(=＠_＠;=)?>）。
...</p></div><footer class=entry-footer><span title='2013-12-28 14:42:00 +0000 UTC'>December 28, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label='post link to How to "Rotate Image"?' href=https://wizmann.top/posts/how-to-rotate-image-leetcode/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #221 (Div. 2)不完全不正确题解</h2></header><div class=entry-content><p>A. Lever 水题，杠杆原理。
用^把字符串分割开。然后分别计算两边的重量即可。
#Result: Dec 24, 2013 6:04:41 PM Wizmann A - Lever Python 2 Accepted 312 ms 4200 KB def calc(ss): res = 0 p = 1 for item in ss: if item != '=': t = int(item) res += t * p p += 1 return res s = raw_input() (a, b) = s.split('^') left = calc(a[::-1]) right = calc(b) if left == right: print 'balance' elif left > right: print 'left' else: print 'right' B. I.O.U. 水题，算出每个人负债和贷出（这个词的现学的~）的绝对值差。
...</p></div><footer class=entry-footer><span title='2013-12-25 19:05:00 +0000 UTC'>December 25, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #221 (Div. 2)不完全不正确题解" href=https://wizmann.top/posts/cf-221-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>自己动手搭建第三方的Codeforces CDN</h2></header><div class=entry-content><p>啥？ 校园网上CF那叫一个卡。
原因是什么呢？ 因为codeforces大量的使用了ajax技术，所以引用了很多js/css文件，并且引用的位置位于页面之前。
...</p></div><footer class=entry-footer><span title='2013-12-14 00:00:00 +0000 UTC'>December 14, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 自己动手搭建第三方的Codeforces CDN" href=https://wizmann.top/posts/third-party-codeforces-cdn/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #218 (Div. 2)不完全不正确题解</h2></header><div class=entry-content><p>A. K-Periodic Array 将Array切片，然后按位统计某一位上1的个数C(1)和2的个数C(2)。然后在这一位上的操作数就为M = min(C(1), C(2))。
简单题
B. Fox Dividing Cheese 傻逼才错的题，不幸中枪。
...</p></div><footer class=entry-footer><span title='2013-12-09 23:02:00 +0000 UTC'>December 9, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #218 (Div. 2)不完全不正确题解" href=https://wizmann.top/posts/cf-218-div-2/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wizmann.top/page/4/>«&nbsp;&nbsp;
</a><a class=next href=https://wizmann.top/page/6/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>