Title: KAIST CS492C - 并发编程 · 课程速读（Part1. 介绍）
Date: 2025-10-06 10:00
Tags: 并行计算, 并发, Rust, 系统编程
Slug: kaist-cs492c-1

<div class="alert alert-warning" role="alert">
  ⚠️ 本文根据视频字幕和 slides 由 AI 生成
</div>

[课程主页](https://github.com/kaist-cp/cs431)

## 并发编程导论：走进平行计算的新时代

在 21 世纪的科技浪潮中，人工智能与物联网正推动着计算需求的爆炸式增长。自从 2016 年 AlphaGo 战胜围棋大师李世乭的那一刻起，人类正式步入了“并行计算的时代”——一个由成千上万计算单元协同运作、驱动智能算法与复杂系统的新时代。

## 为什么我们需要并行？

随着 AI 与大数据的兴起，单核 CPU 的性能提升已逐渐触顶。计算机架构的历史告诉我们——两次重大的技术转折推动了“并行化”的浪潮：

1. **Dennard Scaling 的终结（约 2005 年）**
   过去，我们可以通过提高 CPU 主频来提升性能。但功耗与发热限制了频率的进一步增长。于是，多核系统（multi-core）成为新的出路——不再让单个核心更快，而是让更多核心同时工作。

2. **摩尔定律的放缓（约 2018 年）**
   晶体管密度的增长速度逐渐减缓，性能提升进入瓶颈。于是出现了新的突破口——**加速器（Accelerators）**。GPU、TPU、NPU、FPGA 等专用硬件通过极致的并行化，实现了远超传统 CPU 的吞吐能力。

如今，从智能手机到超级计算机，计算资源不仅“更多”，而且“更异构”。我们拥有多核 CPU、GPU、TPU、分布式服务器……但问题也随之而来——**如何协调这些并行资源，让它们真正协同而不是竞争？**

## 并行与并发：两个不同的概念

在进入技术细节之前，我们需要区分两个常被混淆的词：

* **Parallelism（并行）**：多个任务在不同资源上同时执行。

  > 例如，多个 CPU 核心同时计算不同的任务。

* **Concurrency（并发）**：多个任务共享可变资源（shared mutable state）。

  > 例如，多个线程同时访问同一个数据库或内存。

并行让我们“同时做多件事”，而并发让我们“安全地共享”。
真正高性能的系统，往往需要两者兼备。

## 并发的挑战：非确定性（Nondeterminism）

并发之所以难，不是因为代码复杂，而是因为它**不可预测**。

1. **指令交错（Interleaving）**
   当多个线程同时修改同一变量时，执行顺序的不确定性会导致不同结果。
   例如：

   ```text
   Thread 1: X = 1
   Thread 2: X = 2
   ```

   程序的最终值取决于哪个线程“先执行”，这在多核环境中是不可控的。

2. **硬件与编译器重排序（Reordering）**
   即使你以为代码按顺序执行，CPU 和编译器可能会为了优化性能而重新排列指令。
   在现代体系结构下，甚至可能出现两个线程都读到旧值的情况（如 a=b=0）。

非确定性带来了“组合爆炸式”的复杂度，也让调试并发程序成为噩梦。

## 驯服混乱：两种应对策略

为了让并发变得“可控”，研究者与工程师提出了两大方向：

1. **通过安全的 API 封装复杂性**
   例如锁（lock）、条件变量（condition variable）或线程库等，都在提供一种“安全抽象”：

   * 我们不需要了解底层实现；
   * 只需遵循 API 规范，就能安全地同步并发操作。
     举例来说，锁的核心保证是：“任意时刻，最多只有一个线程持有它。”

2. **通过成熟的同步模式实现安全性**
   对于实现者而言，底层需要使用经过验证的**同步原语**（如 release-acquire 模型、原子操作 CAS 等），以确保正确性与性能平衡。
   换言之：**上层开发者依赖安全 API，下层开发者掌握同步模式。**

## 并发编程的核心目标

并发编程的终极目标不是“让所有线程都跑起来”，而是**在安全性、效率和可扩展性之间取得平衡**。
正如课程中所强调的：

> “Too much nondeterminism leads to scalability problems,
> too little leads to correctness problems.”

我们要学会“驯服刚刚好的非确定性”——既不过分限制并行性，也不让错误无处可查。

---

### 总结：从混乱到秩序的艺术

《Concurrent Programming》课程从这节导论开始，为我们揭示了一个真相：
**并发不是附加在程序上的技巧，而是现代计算的本质。**

从 AlphaGo 背后的千万线程，到你电脑中悄然运行的多任务系统，
并发编程是一场让“混乱的世界”高效、有序运转的艺术。

接下来的课程将深入探讨：

* 如何安全地同步多线程操作；
* 锁与无锁编程的权衡；
* Rust 语言中的所有权模型；
* 以及如何在理论与实践中构建真正高效的并发系统。
