Date: 2020-10-26
Title: 2020 计蒜之道 线上决赛 - C. 攀登山峰
Tags: algorithm, 算法
Slug: jisuanke-climb-the-hill

> 本文使用了一种概率算法，不是正解，只求骗分。

## 题意

[原题][2]

给一个长度为n的数组A[1...n]。

现在有q个查询请求（q <= 1e5），每个请求给定一个长度为k的子数组A[i...j]和一个整数t。问在子数组中出现次数超过m / t的数字中（t <= 20），最大的数是多少。

## 题意中的坑

阈值m / t是一个实数。（题意不明先死个🐴好吗？）

## 解法

首先我们将每种数字出现的位置简历一个索引，此时对于任意一个数，我们可以用二分法在O(logn)的时间内求出其在某个区间内出现的次数。

因为t最大是20，也就意味着如果我们随机取数，那么取到一个符合出现次数限制的（超过m/t次）数字的概率是1/t。如果我们进行多次尝试，并使用上面的方法对其进行验证，几乎可以保证我们一定可以取到正确的那一个。

那么“多次尝试”是多少次呢？我们枚举所有的t，然后计算其在q=1e5的情况下的成功率。因为这是一个随机算法，我们先使用下面的代码分别计算一下成功率为10%和50%的期望尝试次数。

```python
#coding=utf-8

for i in xrange(1, 21):
    fail = 1 - (1. / i)
    for j in xrange(1, 3000):
        ff = 1 - fail ** j
        if pow(ff, 100000) > 0.1:
            print i, j, pow(ff, 100000)
            break
```

|  T | attempt(10%) | succ rate(10%) | attempt(50%) | succ rate(50%) |
|---:|-------------:|---------------:|-------------:|---------------:|
|  1 |            1 |              1 |            1 |              1 |
|  2 |           16 |         0.2174 |           18 |         0.6829 |
|  3 |           27 |          0.172 |           30 |         0.5936 |
|  4 |           38 |         0.1673 |           42 |          0.568 |
|  5 |           48 |         0.1075 |           54 |         0.5573 |
|  6 |           59 |         0.1189 |           66 |         0.5519 |
|  7 |           70 |         0.1275 |           78 |         0.5488 |
|  8 |           80 |         0.1008 |           89 |         0.5017 |
|  9 |           91 |         0.1093 |          101 |         0.5058 |
| 10 |          102 |         0.1163 |          113 |         0.5091 |
| 11 |          113 |         0.1222 |          125 |         0.5118 |
| 12 |          123 |         0.1055 |          137 |         0.5142 |
| 13 |          134 |         0.1111 |          149 |         0.5161 |
| 14 |          145 |          0.116 |          161 |         0.5179 |
| 15 |          155 |         0.1035 |          173 |         0.5193 |
| 16 |          166 |         0.1081 |          185 |         0.5207 |
| 17 |          177 |         0.1123 |          196 |          0.501 |
| 18 |          187 |         0.1023 |          208 |         0.5033 |
| 19 |          198 |         0.1062 |          220 |         0.5053 |
| 20 |          209 |         0.1098 |          232 |         0.5071 |

由上表我们可以知道，对于不同的t，我们可以使用不同的尝试次数以达到预期的胜率。

总的时间复杂度为O(q * logn * attempt)，对于极限数据可能会有超时的风险，所以我们在随机尝试时可以加入些许的优化，例如挂上输入输出外挂，以及之前计算过的值或当前值小于最大值时不进行二分查找等。剩下的工作就是孜孜不倦的提交，直到获得AC为止。（评测机你辛苦了）

以及，记得加上初始化随机数种子`srand(time(NULL));`，否则你的随机数每次都一样。。。

实际上总的胜率还是很高的，说明数据并没有达到极限，出题人手下留情做了个人（

代码请见[这里][1]

[1]: https://github.com/Wizmann/ACM-ICPC/blob/master/Jisuanke/T49111-%E6%94%80%E7%99%BB%E5%B1%B1%E5%B3%B0.cc
[2]: https://nanti.jisuanke.com/t/49111
