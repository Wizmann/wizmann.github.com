Title: KAIST CS492 - 并发编程 · 课程速读（Part2.1 基于锁的并发编程）
Date: 2025-10-06 11:00
Tags: 并行计算, 并发, Rust, 系统编程
Slug: kaist-cs492-2.1

[课程主页](https://github.com/kaist-cp/cs431)

## 基于锁的并发编程：**从共享内存到安全同步**

在并发编程的学习中，“锁”（Lock）是我们理解同步与互斥的起点。它是最早也是最经典的并发控制方式之一，本节内容将从共享内存模型出发，逐步讲解锁的动机、机制、局限性，以及如何利用现代语言（特别是 Rust）实现更安全的并发抽象。

---

## 一、共享内存并发模型

并发编程的一个基础假设是：多个线程同时运行，并且它们共享同一片内存空间。这被称为“共享内存并发”（Shared-Memory Concurrency）。

每个线程都是一个执行的“代理”（agent），拥有自己的寄存器和程序计数器，独立执行指令。当它需要访问或修改共享数据时，就会对共享内存进行读写操作。共享内存是多个线程共同依赖的“资源”，因此也成为了所有并发问题的根源。

在现实系统中，CPU、缓存、存储控制器等因素会增加很多复杂性，但在概念模型中，我们只需记住：线程是主动执行者，内存是被共享的对象。理解这一点，是学习并发的第一步。

---

## 二、基于锁的并发思想

所谓“基于锁的并发”（Lock-Based Concurrency），指的是在任意时刻，只允许一个线程访问某个共享资源。这意味着线程之间的访问是互斥的，从而避免了数据竞争和状态不一致的问题。

它的优点是简单、容易理解、逻辑清晰；缺点是会降低并行性能，因为其他线程必须等待锁被释放。

可以说，锁让我们牺牲了一部分并行性，以换取确定性和安全性。对于学习者而言，这是理解更复杂并发模式之前最重要的基础。

---

## 三、锁的动机：避免并发冲突

让我们通过一个简单例子来看为什么需要锁。

假设两个线程都执行下面的代码：

```
Thread 1      | Thread 2
--------------------------
r1 = X;       | r2 = X; 
X = r1 + 1;   | X = r2 + 1;
```

如果 X 初始值为 0，理想情况下两次自增后 X 应该等于 2。但由于两个线程可能交错执行，实际结果可能是 1。这是因为两个线程都先读取了 0，然后分别写回了 1，导致更新丢失。这类问题就是典型的“竞争条件”（race condition）。

引入锁之后，程序可以改写为：

```
Thread 1       | Thread 2
--------------------------
L.acquire();   | L.acquire();
r1 = X;        | r2 = X;
X = r1 + 1;    | X = r2 + 1;
L.release();   | L.release();
```

这样，每次只有一个线程能修改 X，另一个线程必须等待锁释放。最终结果始终是 X=2。锁保证了对共享资源的安全访问。

---

## 四、低层锁 API 的问题

尽管锁机制本身能保障安全，但它的底层 API 十分容易出错。常见的失误包括：

1. 忘记调用 `release`，导致死锁；
2. 忘记 `acquire`，导致数据竞争；
3. 错误地使用了不相关的锁；
4. `acquire` 和 `release` 不匹配；
5. 多线程协作中出现悬空状态或错误释放。

这些问题在大型系统中极其常见。并发错误往往潜伏极深，可能只有在极低概率的调度情况下才会出现。更糟的是，编译器和类型系统无法静态地验证这些错误。

因此，虽然锁提供了“安全访问”的机制，但它也引入了“高出错风险”。为了让锁更易用、更可靠，我们需要在更高层次上重新设计它的抽象。

---

## 五、从低层 API 到高层抽象

改进方向主要有两个：
第一，自动化匹配 `acquire` 与 `release`；
第二，显式地将锁与被保护的资源绑定。

C++ 提供的 RAII（Resource Acquisition Is Initialization）机制就是一个经典的例子。
通过 RAII，当一个对象被创建时自动获得资源（如锁），当对象销毁时自动释放资源。这种机制大大减少了程序员手动管理锁的负担。

例如：

```cpp
void safe_increment() {
    std::lock_guard<std::mutex> guard(mtx);
    ++shared_counter;
}
```

在这段代码中，`lock_guard` 的构造函数会自动获取锁，析构函数会自动释放锁。无论函数如何返回，锁都不会被忘记释放，从而避免了常见的死锁或资源泄漏问题。

为了进一步提高安全性，我们还可以通过类型系统将“锁”与“被保护的数据”显式关联。例如定义：

```cpp
template <typename T>
class Lock {
    RawLock lock;
    T data;
};
```

这样，访问数据必须通过锁对象进行操作，程序结构上就明确地表达了“哪个锁保护哪个数据”，大大减少了混乱与误用。

---

## 六、安全 API 的隐患与 Rust 的解法

然而，即使是 RAII 模式，在 C++ 中仍然可能出现微妙的安全漏洞。例如：

```
auto guard = data.lock();
auto ptr = &(*guard);
guard.~LockGuard(); // 提前释放锁
*ptr = 666;         // 在锁已释放的情况下访问数据
```

这段代码在语法上合法，但逻辑上危险：锁已经释放，指针仍然被使用。此时如果其他线程获得了锁并修改数据，就会造成严重的并发错误。

根本原因在于：C++ 的类型系统无法表达“生命周期”这一约束，即指针的存活时间不能超过锁的持有期。Rust 则在语言层面彻底解决了这一问题。

Rust 的核心思想是“所有权与借用”（ownership and borrowing）。
它强制每个值都有唯一的所有者，引用的生命周期受到严格追踪。当编译器发现一个引用可能在锁释放后仍然被使用时，会直接拒绝编译。
因此，Rust 能够在编译期防止数据竞争、悬空引用等问题，从而在类型层面实现并发安全。

这正是为什么 KAIST CS431 课程在后续部分选择用 Rust 继续讲授并发编程——因为它让“安全”成为语言的一部分，而不是事后依赖程序员去维护的契约。

---

## 七、总结

“基于锁的并发”是理解并发控制的起点。
它让我们第一次能够安全地访问共享资源，并在逻辑上消除了非确定性。然而，传统的低层 API 充满陷阱，需要更高层的抽象和更强的语言保障。

RAII 提供了自动化的资源管理思路，而 Rust 的类型系统进一步在编译期保证了安全。

从这一讲开始，我们不再仅仅把锁看作一个编程技巧，而是把它看作一种“安全设计理念”的体现。它连接了编译器、类型系统与程序正确性，为理解更高级的并发机制（如无锁编程和内存模型）奠定了坚实基础。

<div class="alert alert-warning" role="alert">
  ⚠️ 本文根据视频字幕和 slides 由 AI 生成
</div>
