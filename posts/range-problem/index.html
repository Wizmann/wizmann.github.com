<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Date: 2018-02-20 22:59:47
Title: 一种区间交问题的奇怪姿势
Tags: algorithm, leetcode, C++
Slug: range-problem

Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题
区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题："><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/range-problem/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/range-problem/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/range-problem/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:description" content="Date: 2018-02-20 22:59:47 Title: 一种区间交问题的奇怪姿势 Tags: algorithm, leetcode, C++ Slug: range-problem
Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题："><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Date: 2018-02-20 22:59:47
Title: 一种区间交问题的奇怪姿势
Tags: algorithm, leetcode, C++
Slug: range-problem

Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题
区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题："><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://wizmann.top/posts/range-problem/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Date: 2018-02-20 22:59:47 Title: 一种区间交问题的奇怪姿势 Tags: algorithm, leetcode, C++ Slug: range-problem\nUpdate[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。\n我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。\n例如，Insert Interval一题，就是比较直白的区间交问题：\n","keywords":[],"articleBody":"Date: 2018-02-20 22:59:47 Title: 一种区间交问题的奇怪姿势 Tags: algorithm, leetcode, C++ Slug: range-problem\nUpdate[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。\n我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。\n例如，Insert Interval一题，就是比较直白的区间交问题：\n给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么\n类似的还有Merge Intervals：\n给定一系列可能有重叠的整数区间，求合并后的整数区间\n另一种区间交问题的描述是时间区间相关的问题，如Time Intersection:\n给定用户A和用户B的在线时间区间，问两人同时在线的时间区间\n又如经典的会议室安排问题Meeting Rooms和Meeting Rooms II:\n给定N个会议的时间区间，问一个人能否参加所有的会议\n以及\n给定N个会议的时间区间，问最少需要多少个会议室\n还有系统设计与API设计包装后的算法题Range Module。归根结底，都是整数区间问题的变形或者包装。\n传统解法 对于这类区间问题，传统的解法是将区间使用顺序容器（如vector）保存，在查询和修改时，使用“排序+遍历”或者“排序+二分”。\n这种解决在一定程度上是区间问题的通解，但是这样做也有它的问题。\n一来区间问题有很多对区间序列进行随机增加、删除，这样的操作对于顺序容器是非常不友好的。\n二来对于使用“起点”或“终点”排序的区间，二分查找需要处理很多重复值，在某些情况下会发生复杂度的退化。\n那么我们如何优化我们的实现来解决以上的问题呢？\n使用std::set 我们以Merge Intervals一题为例。只要两个区间有交集，无论是哪一种形式的相交，那么我们就需要把这两个区间合并。\n所以，我们只需要能高效的判断两个区间是否相交，就可以解决这个问题了。\n但是在这里，我们反其道而行之，先来讨论一下不相交的情况。对于两个不相交的区间A和B，只存在两种情况，一是A在B左面，二是A在B右面。\n我们可以把区间的左右关系看成不相交区间的顺序关系，即：\n如果区间A在区间B的“左边”，我们说A \u003c B 如果区间A在区间B的“右边”，我们说A \u003e B 所以，根据不相交区间的性质，我们可以很自然的将它们存储在std::set当中。这样我们就可以在O(logN)时间进行查找、随机插入与随机删除。\n那么，回到最开始判断区间是否相交的问题。对于相交的区间A和B，非常明显，A \u003c B与A \u003e B都是不成立的。在std::set中，这种关系被判定为相等。\n虽然这种相等关系是不符合常规逻辑的，但是却非常实用。如果两个区间有“大小”关系，我们可以知道区间的相对位置。而如果两个区间“相等”，则我们可以知道两个区间一定相交。更重要的是，在这类题目中，两个相交的区间是不能同时存在的。这与std::set中元素的唯一性相呼应。\n所以，在使用std::set来存储区间时，我们可以使用如下的性质：\n使用find()函数来查找相交区间。这里要注意，相交的区间可能有多个 使用insert()来插入区间。这里要注意，先要判断是否有区间与新插入的区间相交 使用erase()来删除区间。 实战 - Merge Intervals 在Merge Intervals一题中使用std::set并不是最优的解法。这里只做举例。\n题目链接：Merge Intervals\n/** * Definition for an interval. * struct Interval { * int start; * int end; * Interval() : start(0), end(0) {} * Interval(int s, int e) : start(s), end(e) {} * }; */ // overload the comparator for std::set bool operator \u003c (const Interval\u0026 i1, const Interval\u0026 i2) { return i1.end \u003c i2.start; } class Solution { public: vector\u003cInterval\u003e merge(vector\u003cInterval\u003e\u0026 intervals) { set\u003cInterval\u003e st; for (auto interval: intervals) { // merge intervals which are overlaped while (true) { auto iter = st.find(interval); if (iter == st.end()) { break; }; interval = { min(interval.start, iter-\u003estart), max(interval.end, iter-\u003eend) }; st.erase(iter); } // add the new interval to std::set st.insert(interval); } // copy the intervals to a vector vector\u003cInterval\u003e result; copy(st.begin(), st.end(), back_inserter(result)); return result; } }; 上面的代码中，std::set中存储了已经合并好的区间。当加入新的区间时，我们会先判断新区间是否与已有区间相关，如果相交，则进行合并。\n实战 - Range Module 题目链接：Range Module\n题意： 设计一个类，提供三个接口： 接口1：void addRange(int left, int right) 将区间[left, right - 1]加入区间集合 接口2：bool queryRange(int left, int right) 查询是否已有区间与区间[left, right - 1]相交 接口3：void removeRange(int left, int right) 移除已有区间内，位于[left, right - 1]范围内的所有数\n这个题目看似可以完全套用我们上面讲到的std::set的实现，但是这里有几个暗坑需要注意。\n首先我们来看接口3，这里的删除并不是删除区间，而是删除整数，所以我们可以使用find()函数，但是与之前的合并操作不同，我们在这里要删除区间中的一部分。\n在删除整数操作进行完之后，会引入一个新问题，这就是一些连续的整数区间，会在std::set中表现为独立的多个区间。例如，区间[1, 5]，在删除了[2, 3]之后，会形成两个区间[1, 1] 和 [4, 5]。我们再把区间[2, 3]加回来，如果不进行特殊操作，就会产生三个不相交但连续的区间[1, 1]、[2, 3]和[4, 5]。所以我们在插入区间时，要多做一步区间合并的操作。\n具体的实现为：\n在插入区间[l, r]之前，先查找是不存在区间包含[l - 1, l - 1]或[r + 1, r + 1]。如果有，则先将已有的相邻区间合并的新区间里 将新的区间进行合并操作，插入std::set 正确性证明：\n已知1：空区间集合不包含不相交但连续的区间 已知2：只有插入操作会产生不相交但连续的区间 归纳假设：我们保证在任何插入新区间的操作之前，std::set中均不包含不相交但连续的区间。 证明： 如果区间集合内不包含不相交但连续的区间，那么对于新加区间，我们只需要尝试合并其近邻区间[l - 1, l - 1]和[r + 1, r + 1]，就不会产生不相交但连续的区间。 代码实现如下：\nstruct MyInterval { int left, right; bool operator \u003c (const MyInterval\u0026 other) const { return this-\u003eright \u003c other.left; } }; class RangeModule { public: RangeModule() { // pass } void addRange(int left, int right) { right -= 1; MyInterval ll = {left - 1, left - 1}; auto liter = st.find(ll); if (liter != st.end()) { left = liter-\u003eleft; } MyInterval rr = {right + 1, right + 1}; auto riter = st.find(rr); if (riter != st.end()) { right = riter-\u003eright; } doAddRange(left, right); } void doAddRange(int left, int right) { MyInterval newInterval = {left, right}; while (true) { auto iter = st.find(newInterval); if (iter == st.end()) { break; } newInterval.left = min(newInterval.left, iter-\u003eleft); newInterval.right = max(newInterval.right, iter-\u003eright); st.erase(iter); } st.insert(newInterval); } bool queryRange(int left, int right) { right -= 1; MyInterval interval = {left, right}; auto iter = st.find(interval); if (iter == st.end()) { return false; } return iter-\u003eleft \u003c= left \u0026\u0026 right \u003c= iter-\u003eright; } void removeRange(int left, int right) { right -= 1; MyInterval newInterval = {left, right}; while (true) { auto iter = st.find(newInterval); if (iter == st.end()) { break; } auto cur = *iter; st.erase(iter); if (cur.left \u003c newInterval.left) { st.insert({cur.left, newInterval.left - 1}); } if (cur.right \u003e newInterval.right) { st.insert({newInterval.right + 1, cur.right}); } } } private: set\u003cMyInterval\u003e st; }; ","wordCount":"2566","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/range-problem/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>wizmann</div></header><div class=post-content><p>Date: 2018-02-20 22:59:47
Title: 一种区间交问题的奇怪姿势
Tags: algorithm, leetcode, C++
Slug: range-problem</p><blockquote><p>Update[220504]: 原来这种数据结构叫<a href=https://oi-wiki.org/ds/odt/>珂朵莉树</a>啊，真神奇。。。</p></blockquote><h2 id=我们要解决什么问题>我们要解决什么问题<a hidden class=anchor aria-hidden=true href=#我们要解决什么问题>#</a></h2><p>区间交问题，是我们在做题中经常遇到的问题。</p><p>例如，<a href=https://leetcode.com/problems/insert-interval/description/>Insert Interval</a>一题，就是比较直白的区间交问题：</p><blockquote><p>给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么</p></blockquote><p>类似的还有<a href=https://leetcode.com/problems/merge-intervals/description/>Merge Intervals</a>：</p><blockquote><p>给定一系列可能有重叠的整数区间，求合并后的整数区间</p></blockquote><p>另一种区间交问题的描述是时间区间相关的问题，如<a href=http://lintcode.com/en/problem/time-intersection/>Time Intersection</a>:</p><blockquote><p>给定用户A和用户B的在线时间区间，问两人同时在线的时间区间</p></blockquote><p>又如经典的会议室安排问题<a href=https://segmentfault.com/a/1190000003894670>Meeting Rooms</a>和<a href=http://www.cnblogs.com/grandyang/p/5244720.html>Meeting Rooms II</a>:</p><blockquote><p>给定N个会议的时间区间，问一个人能否参加所有的会议</p></blockquote><p>以及</p><blockquote><p>给定N个会议的时间区间，问最少需要多少个会议室</p></blockquote><p>还有系统设计与API设计包装后的算法题<a href=https://leetcode.com/problems/range-module/description/>Range Module</a>。归根结底，都是整数区间问题的变形或者包装。</p><h2 id=传统解法>传统解法<a hidden class=anchor aria-hidden=true href=#传统解法>#</a></h2><p>对于这类区间问题，传统的解法是将区间使用顺序容器（如<code>vector</code>）保存，在查询和修改时，使用“排序+遍历”或者“排序+二分”。</p><p>这种解决在一定程度上是区间问题的通解，但是这样做也有它的问题。</p><p>一来区间问题有很多对区间序列进行随机增加、删除，这样的操作对于顺序容器是非常不友好的。</p><p>二来对于使用“起点”或“终点”排序的区间，二分查找需要处理很多重复值，在某些情况下会发生复杂度的退化。</p><p>那么我们如何优化我们的实现来解决以上的问题呢？</p><h2 id=使用stdsetinterval>使用<code>std::set&lt;Interval></code><a hidden class=anchor aria-hidden=true href=#使用stdsetinterval>#</a></h2><p>我们以<a href=https://leetcode.com/problems/merge-intervals/description/>Merge Intervals</a>一题为例。只要两个区间有交集，无论是哪一种形式的相交，那么我们就需要把这两个区间合并。</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/18-2-20/85403056.jpg></p><p>所以，我们只需要能高效的判断两个区间<strong>是否相交</strong>，就可以解决这个问题了。</p><p>但是在这里，我们反其道而行之，先来讨论一下<strong>不相交</strong>的情况。对于两个不相交的区间<code>A</code>和<code>B</code>，只存在两种情况，一是<code>A</code>在<code>B</code>左面，二是<code>A</code>在<code>B</code>右面。</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/18-2-20/87075632.jpg></p><p>我们可以把区间的左右关系看成不相交区间的顺序关系，即：</p><ul><li>如果区间<code>A</code>在区间<code>B</code>的“左边”，我们说<code>A &lt; B</code></li><li>如果区间<code>A</code>在区间<code>B</code>的“右边”，我们说<code>A > B</code></li></ul><p>所以，根据不相交区间的性质，我们可以很自然的将它们存储在<code>std::set&lt;Interval></code>当中。这样我们就可以在<code>O(logN)</code>时间进行查找、随机插入与随机删除。</p><p>那么，回到最开始判断区间<strong>是否相交</strong>的问题。对于相交的区间<code>A</code>和<code>B</code>，非常明显，<code>A &lt; B</code>与<code>A > B</code>都是不成立的。在<code>std::set&lt;Interval></code>中，这种关系被判定为<strong>相等</strong>。</p><p>虽然这种<strong>相等</strong>关系是不符合常规逻辑的，但是却非常实用。如果两个区间有“大小”关系，我们可以知道区间的相对位置。而如果两个区间“相等”，则我们可以知道两个区间一定相交。更重要的是，在这类题目中，两个相交的区间是不能同时存在的。这与<code>std::set&lt;Interval></code>中元素的唯一性相呼应。</p><p>所以，在使用<code>std::set&lt;Interval></code>来存储区间时，我们可以使用如下的性质：</p><ul><li>使用<code>find()</code>函数来查找相交区间。这里要注意，相交的区间可能有多个</li><li>使用<code>insert()</code>来插入区间。这里要注意，先要判断是否有区间与新插入的区间相交</li><li>使用<code>erase()</code>来删除区间。</li></ul><h2 id=实战---merge-intervals>实战 - Merge Intervals<a hidden class=anchor aria-hidden=true href=#实战---merge-intervals>#</a></h2><blockquote><p>在Merge Intervals一题中使用std::set并不是最优的解法。这里只做举例。</p></blockquote><p>题目链接：<a href=https://leetcode.com/problems/merge-intervals/description/>Merge Intervals</a></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Definition for an interval.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * struct Interval {
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     int start;
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     int end;
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Interval() : start(0), end(0) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e> *     Interval(int s, int e) : start(s), end(e) {}
</span></span></span><span style=display:flex><span><span style=color:#75715e> * };
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// overload the comparator for std::set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>const</span> Interval<span style=color:#f92672>&amp;</span> i1, <span style=color:#66d9ef>const</span> Interval<span style=color:#f92672>&amp;</span> i2) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> i1.end <span style=color:#f92672>&lt;</span> i2.start;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>Interval<span style=color:#f92672>&gt;</span> merge(vector<span style=color:#f92672>&lt;</span>Interval<span style=color:#f92672>&gt;&amp;</span> intervals) {
</span></span><span style=display:flex><span>        set<span style=color:#f92672>&lt;</span>Interval<span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> interval: intervals) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// merge intervals which are overlaped
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> st.find(interval);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (iter <span style=color:#f92672>==</span> st.end()) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                interval <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>                    min(interval.start, iter<span style=color:#f92672>-&gt;</span>start),
</span></span><span style=display:flex><span>                    max(interval.end, iter<span style=color:#f92672>-&gt;</span>end)
</span></span><span style=display:flex><span>                };
</span></span><span style=display:flex><span>                st.erase(iter);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e>// add the new interval to std::set
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            st.insert(interval);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy the intervals to a vector
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vector<span style=color:#f92672>&lt;</span>Interval<span style=color:#f92672>&gt;</span> result;
</span></span><span style=display:flex><span>        copy(st.begin(), st.end(), back_inserter(result));
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> result;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>上面的代码中，<code>std::set&lt;Interval></code>中存储了已经合并好的区间。当加入新的区间时，我们会先判断新区间是否与已有区间相关，如果相交，则进行合并。</p><h2 id=实战---range-module>实战 - Range Module<a hidden class=anchor aria-hidden=true href=#实战---range-module>#</a></h2><p>题目链接：<a href=https://leetcode.com/problems/range-module/description/>Range Module</a></p><blockquote><p>题意：<br>设计一个类，提供三个接口： 接口1：<code>void addRange(int left, int right)</code><br>将区间<code>[left, right - 1]</code>加入区间集合 接口2：<code>bool queryRange(int left, int right)</code><br>查询是否已有区间与区间<code>[left, right - 1]</code>相交 接口3：<code>void removeRange(int left, int right)</code>
移除已有区间内，位于<code>[left, right - 1]</code>范围内的所有数</p></blockquote><p>这个题目看似可以完全套用我们上面讲到的<code>std::set&lt;Interval></code>的实现，但是这里有几个暗坑需要注意。</p><p>首先我们来看接口3，这里的删除并不是删除区间，而是删除整数，所以我们可以使用<code>find()</code>函数，但是与之前的合并操作不同，我们在这里要删除区间中的一部分。</p><p>在删除整数操作进行完之后，会引入一个新问题，这就是一些连续的整数区间，会在<code>std::set&lt;Interval></code>中表现为独立的多个区间。例如，区间<code>[1, 5]</code>，在删除了<code>[2, 3]</code>之后，会形成两个区间<code>[1, 1]</code> 和 <code>[4, 5]</code>。我们再把区间<code>[2, 3]</code>加回来，如果不进行特殊操作，就会产生三个不相交但连续的区间<code>[1, 1]</code>、<code>[2, 3]</code>和<code>[4, 5]</code>。所以我们在插入区间时，要多做一步区间合并的操作。</p><p>具体的实现为：</p><ol><li>在插入区间<code>[l, r]</code>之前，先查找是不存在区间包含<code>[l - 1, l - 1]</code>或<code>[r + 1, r + 1]</code>。如果有，则先将已有的相邻区间合并的新区间里</li><li>将新的区间进行合并操作，插入<code>std::set&lt;Interval></code></li></ol><p>正确性证明：</p><ul><li>已知1：空区间集合不包含<strong>不相交但连续的区间</strong></li><li>已知2：只有插入操作会产生<strong>不相交但连续的区间</strong></li><li>归纳假设：我们保证在任何插入新区间的操作之前，<code>std::set&lt;Interval></code>中均不包含<strong>不相交但连续的区间</strong>。</li><li>证明：
如果区间集合内不包含<strong>不相交但连续的区间</strong>，那么对于新加区间，我们只需要尝试合并其近邻区间<code>[l - 1, l - 1]</code>和<code>[r + 1, r + 1]</code>，就不会产生<strong>不相交但连续的区间</strong>。</li></ul><p>代码实现如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>MyInterval</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> left, right;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>const</span> MyInterval<span style=color:#f92672>&amp;</span> other) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>right <span style=color:#f92672>&lt;</span> other.left;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RangeModule</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    RangeModule() {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pass
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        MyInterval ll <span style=color:#f92672>=</span> {left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>, left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> liter <span style=color:#f92672>=</span> st.find(ll);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (liter <span style=color:#f92672>!=</span> st.end()) {
</span></span><span style=display:flex><span>            left <span style=color:#f92672>=</span> liter<span style=color:#f92672>-&gt;</span>left;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        MyInterval rr <span style=color:#f92672>=</span> {right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> riter <span style=color:#f92672>=</span> st.find(rr);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (riter <span style=color:#f92672>!=</span> st.end()) {
</span></span><span style=display:flex><span>            right <span style=color:#f92672>=</span> riter<span style=color:#f92672>-&gt;</span>right;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        doAddRange(left, right);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>doAddRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        MyInterval newInterval <span style=color:#f92672>=</span> {left, right};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> st.find(newInterval);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (iter <span style=color:#f92672>==</span> st.end()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            newInterval.left <span style=color:#f92672>=</span> min(newInterval.left, iter<span style=color:#f92672>-&gt;</span>left);
</span></span><span style=display:flex><span>            newInterval.right <span style=color:#f92672>=</span> max(newInterval.right, iter<span style=color:#f92672>-&gt;</span>right);
</span></span><span style=display:flex><span>            st.erase(iter);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        st.insert(newInterval);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>queryRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {        
</span></span><span style=display:flex><span>        right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        MyInterval interval <span style=color:#f92672>=</span> {left, right};
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> st.find(interval);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (iter <span style=color:#f92672>==</span> st.end()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> iter<span style=color:#f92672>-&gt;</span>left <span style=color:#f92672>&lt;=</span> left <span style=color:#f92672>&amp;&amp;</span> right <span style=color:#f92672>&lt;=</span> iter<span style=color:#f92672>-&gt;</span>right;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>removeRange</span>(<span style=color:#66d9ef>int</span> left, <span style=color:#66d9ef>int</span> right) {
</span></span><span style=display:flex><span>        right <span style=color:#f92672>-=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        MyInterval newInterval <span style=color:#f92672>=</span> {left, right};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> st.find(newInterval);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (iter <span style=color:#f92672>==</span> st.end()) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> cur <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>iter;
</span></span><span style=display:flex><span>            st.erase(iter);
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cur.left <span style=color:#f92672>&lt;</span> newInterval.left) {
</span></span><span style=display:flex><span>                st.insert({cur.left, newInterval.left <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cur.right <span style=color:#f92672>&gt;</span> newInterval.right) {
</span></span><span style=display:flex><span>                st.insert({newInterval.right <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, cur.right});
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span>MyInterval<span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/raft-lab-mit-6/><span class=title>«</span><br><span></span>
</a><a class=next href=https://wizmann.top/posts/read-flatbuffer-1/><span class=title>»</span><br><span></span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>