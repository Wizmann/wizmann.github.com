<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>6.824 Lab 2: Raft协议实现指南 （无剧透版）</h1><div class=tip><time datetime="2019-05-02 21:33:00 +0000 UTC">2019/05/02</time>
<span class=split>·</span>
<span>4262 words </span><span class=split>·</span>
<span>9 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/raft>raft</a>
<a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统</a></div></div><hr><div class=content><h2 id=背景>背景 <a href=#%e8%83%8c%e6%99%af class=anchor>🔗</a></h2><p>MIT6.824是一个用来学习分布式系统的非常好的资源。其中第二个课程作业就是关于<a href=https://pdos.csail.mit.edu/6.824/labs/lab-raft.html>Raft算法</a>。</p><p>由于在工作中涉及到分布一致性算法的调研，接触了paxos/raft算法。然后被@neutronest安利了一发，于是开始着手实现这个作业。</p><p>本文是我对这个项目的实现总结。希望能在划出重点的同时，不涉及实现细节，避免破坏大家的写代码体验。</p><p>本文唯一参考资料：<a href=https://raft.github.io/raft.pdf>In Search of an Understandable Consensus Algorithm</a></p><h2 id=任务分解>任务分解 <a href=#%e4%bb%bb%e5%8a%a1%e5%88%86%e8%a7%a3 class=anchor>🔗</a></h2><p>在官方文档里，整个项目被分成了2A、2B、2C三个部分：</p><ul><li>2A - 投票与选举</li><li>2B - 一致性</li><li>2C - 可持久化</li></ul><p>实际上，2C的工作量非常少，我们可以把2B和2C合成一个。然后单独提出几个比较重要的测试用例，划分成子项目。任务分解如下：</p><ul><li>2A - 投票与选举</li><li>2B/2C - 一致性和可持久化</li><li>三个难度比较高的Case<ul><li>Test (2B): leader backs up quickly over incorrect follower logs<br>验证协议实现的正确性</li><li>Test (2B): RPC counts aren&rsquo;t too high<br>测试协议是否产生了过多的RPC请求。验证协议的性能。</li><li>Test (2C): Figure 8 (unreliable)<br>测试在极端混乱的情况下，Raft协议是否能及时恢复正常工作。验证协议实现的正确性和性能。</li></ul></li></ul><p>所以推荐大家按顺序以上顺序进行实现。并且充分利用版本控制对代码进行开发和重构。</p><h2 id=需要关注的知识点>需要关注的知识点 <a href=#%e9%9c%80%e8%a6%81%e5%85%b3%e6%b3%a8%e7%9a%84%e7%9f%a5%e8%af%86%e7%82%b9 class=anchor>🔗</a></h2><p>以下会介绍每一个部分需要重点关注的知识点，内容包括golang基础和论文中的知识点，无剧透，请放心食用。</p><h3 id=准备工作>准备工作 <a href=#%e5%87%86%e5%a4%87%e5%b7%a5%e4%bd%9c class=anchor>🔗</a></h3><p>golang是一门傲慢的语言，其标准库的缺乏实在是让人感到TMD蛋疼。但是对于一个课程作业来说，我们也没有必要引入一系列第三方库。所以我们先要扩充<code>util.go</code>文件，使其为我们的开发提供更多的便利。</p><h4 id=log模块>Log模块 <a href=#log%e6%a8%a1%e5%9d%97 class=anchor>🔗</a></h4><p>项目给出的<code>DPrintf</code>函数非常简单，只提供了一个<code>fmt.Printf</code>的封装。并不能打印行号和文件名。这里提供一个扩展版本。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>DPrintf</span>(<span style=color:#a6e22e>format</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>Debug</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>lineno</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Caller</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ok</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>a</span> = append([]<span style=color:#66d9ef>interface</span>{} { <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;2006-01-02 15:04:05.00&#34;</span>), <span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>lineno</span> }, <span style=color:#a6e22e>a</span><span style=color:#f92672>...</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%s [%s:%d] &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>format</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n&#34;</span>, <span style=color:#a6e22e>a</span><span style=color:#f92672>...</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>其输出示例如下：</p><div class=mermaid>2019-05-02 09:28:35.04 [raft.go:652] Node[1] is processing, state: [LEADER], term 1, commitIndex: 12, logCount: 12, leader 1</div><h4 id=max和min函数>Max和Min函数 <a href=#max%e5%92%8cmin%e5%87%bd%e6%95%b0 class=anchor>🔗</a></h4><p>golang是没有对于int值的<code>max</code>和<code>min</code>函数的，这里省略脏话100句。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Min</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> &lt; <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Max</span>(<span style=color:#a6e22e>a</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>b</span> <span style=color:#66d9ef>int</span>) (<span style=color:#66d9ef>int</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>a</span> &gt; <span style=color:#a6e22e>b</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>a</span>;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>b</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=assert函数>Assert函数 <a href=#assert%e5%87%bd%e6%95%b0 class=anchor>🔗</a></h4><p>是的，你没有看错，golang也没有提供<code>assert</code>函数。如果你嫌到处写<code>if</code>和<code>panic</code>太丑的话，可以使用这个<code>assert</code>函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Assert</span>(<span style=color:#a6e22e>flag</span> <span style=color:#66d9ef>bool</span>, <span style=color:#a6e22e>format</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>a</span> <span style=color:#f92672>...</span><span style=color:#66d9ef>interface</span>{}) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (!<span style=color:#a6e22e>flag</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>path</span>, <span style=color:#a6e22e>lineno</span>, <span style=color:#a6e22e>ok</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Caller</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>file</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>filepath</span>.<span style=color:#a6e22e>Split</span>(<span style=color:#a6e22e>path</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>ok</span>) {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>t</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Now</span>();
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>a</span> = append([]<span style=color:#66d9ef>interface</span>{} { <span style=color:#a6e22e>t</span>.<span style=color:#a6e22e>Format</span>(<span style=color:#e6db74>&#34;2006-01-02 15:04:05.00&#34;</span>), <span style=color:#a6e22e>file</span>, <span style=color:#a6e22e>lineno</span> }, <span style=color:#a6e22e>a</span><span style=color:#f92672>...</span>);
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>reason</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Sprintf</span>(<span style=color:#e6db74>&#34;%s [%s:%d] &#34;</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>format</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;\n&#34;</span>, <span style=color:#a6e22e>a</span><span style=color:#f92672>...</span>);
</span></span><span style=display:flex><span>            panic(<span style=color:#a6e22e>reason</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            panic(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=log-id>Log Id <a href=#log-id class=anchor>🔗</a></h4><p>为了验证日志的一致性，我们在日志中额外加入一个UUID来进行标识。</p><div class=mermaid>import "math/rand"
func CreateLogId() (uuid string) {
b := make([]byte, 16)
_, err := rand.Read(b)
if err != nil {
fmt.Println("Error: ", err)
return
}
uuid = fmt.Sprintf("%X-%X-%X-%X-%X", b[0:4], b[4:6], b[6:8], b[8:10], b[10:])
return uuid
}</div><p>以上代码可以生成一个（伪）UUID对日志进行标识。推荐使用<code>math/rand</code>，因为这里我们使用伪随机数就够了。</p><blockquote><p>注：这里的UUID只是看起来像一个UUID，实际上UUID有其特殊的规范与格式。但是由于golang内部没有提供可用的UUID库，所以只好随手模拟了一个。</p></blockquote><h4 id=文件组织>文件组织 <a href=#%e6%96%87%e4%bb%b6%e7%bb%84%e7%bb%87 class=anchor>🔗</a></h4><p>默认的实现是把所有的东西都写到了<code>raft.go</code>文件里。一个非常大的文件可能会给我们的开发带来负担，所以我的做法是把所有的类声明放到<code>models.go</code>文件里。以避免文件的膨胀。</p><h4 id=锁与defer>锁与defer <a href=#%e9%94%81%e4%b8%8edefer class=anchor>🔗</a></h4><p>在raft实现中，锁可以用来保证在多线程环境下数据的正确性。所以只要在涉及到raft内部状态的变化时，都需要加锁。一个常见的加锁pattern是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>// 加锁</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>() <span style=color:#75715e>// 在函数执行完成后解锁</span>
</span></span></code></pre></div><p>这里推荐使用defer，因为手动控制锁实现是过于容易出错。但是defer也是有坑的！</p><p>不同于C++的大括号作用域，defer的触发时间是在函数执行完成之后，而并不是退出当前大括号时。这点非常需要注意，否则极易出现死锁。</p><p>如果我们想实现C++中<code>do { ... } while (0);</code>类似的lock guard pattern，可以使用以下实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span>() {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Lock</span>()
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>defer</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>mu</span>.<span style=color:#a6e22e>Unlock</span>()
</span></span><span style=display:flex><span>    <span style=color:#75715e>// do something here</span>
</span></span><span style=display:flex><span>}()
</span></span></code></pre></div><p>这样一来，在执行完当前lambda之后，就会自动解锁。</p><h4 id=刷新定时器>刷新定时器 <a href=#%e5%88%b7%e6%96%b0%e5%ae%9a%e6%97%b6%e5%99%a8 class=anchor>🔗</a></h4><p>由于raft算法里面使用了定时器，这里提供一个刷新定时器的golang代码。这样实现是为了每次在刷新的时候，清空定时器中原有的超时时间，以避免混乱。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-golang data-lang=golang><span style=display:flex><span><span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>rf</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Raft</span>) <span style=color:#a6e22e>renewTimer</span>(<span style=color:#a6e22e>timeout</span> <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>Duration</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>timer</span> <span style=color:#f92672>==</span> <span style=color:#66d9ef>nil</span>) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>timer</span> = <span style=color:#a6e22e>time</span>.<span style=color:#a6e22e>NewTimer</span>(<span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (!<span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>Stop</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>select</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>&lt;-</span> <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>C</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e>// pass</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>default</span>:
</span></span><span style=display:flex><span>                <span style=color:#75715e>// pass</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>rf</span>.<span style=color:#a6e22e>timer</span>.<span style=color:#a6e22e>Reset</span>(<span style=color:#a6e22e>timeout</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>以及，在定时器超时之后，不要忘了更新定时器。</p><h3 id=2a---投票与选举>2A - 投票与选举 <a href=#2a---%e6%8a%95%e7%a5%a8%e4%b8%8e%e9%80%89%e4%b8%be class=anchor>🔗</a></h3><h4 id=所需要类的声明>所需要类的声明 <a href=#%e6%89%80%e9%9c%80%e8%a6%81%e7%b1%bb%e7%9a%84%e5%a3%b0%e6%98%8e class=anchor>🔗</a></h4><p>论文中的<code>Figure2</code>包含了算法中所有的类以及基本算法。在2A中，所有的类都会被用到。由于2A中只包括投票与选举，所以和日志相关的字段可以先忽略掉。</p><h4 id=checklist-for-2a>Checklist for 2A <a href=#checklist-for-2a class=anchor>🔗</a></h4><ul><li>实现raft状态机的三个状态：leader，follower和candidate</li><li>实现RPC函数：<code>sendRequestVote</code>（发送端）和<code>RequestVote</code>（接收端的回调函数）</li><li>实现RPC函数：<code>sendAppendEntries</code>（发送端）和<code>AppendEntries</code>（接收端的回调函数）</li><li>保证raft状态机的任期号（<code>currentTerm</code>）是单调递增的</li><li>一个Follower对于某一个Term只能投出一票</li><li>实现Leader心跳，维护当前任期（Term）。</li><li>实现Follower选举超时（election timeout）</li><li>实现Candidate选举的三种场景<ul><li>获得多数选票，赢得选举。状态切换为Leader</li><li>其它的节点已经被选为Leader。状态切换为Follower</li><li>在选举中并未获得多数选票，状态切换为Follower</li></ul></li><li>实现Candidate随机选举超时（randomized election timeout）</li></ul><h3 id=2b2c---日志复制与持久化>2B/2C - 日志复制与持久化 <a href=#2b2c---%e6%97%a5%e5%bf%97%e5%a4%8d%e5%88%b6%e4%b8%8e%e6%8c%81%e4%b9%85%e5%8c%96 class=anchor>🔗</a></h3><h4 id=基本工作流>基本工作流 <a href=#%e5%9f%ba%e6%9c%ac%e5%b7%a5%e4%bd%9c%e6%b5%81 class=anchor>🔗</a></h4><p>日志复制的基本工作流如下：</p><p>Leader接受用户请求，将状态变化写入本机的日志流中，并且把日志复制到Followers。如果本条日志合法，Followers会将这条日志标记为“提交”（committed），然后再将这条日志“应用”（apply）到Raft协议之外的状态机。Follower在提交日志之后，就可以向Leader回报这条日志已经被提交。在本条日志被多数节点提交之后，Leader再将这条日志标记为提交。此时，用户的请求就可以被确认（ACK）了。</p><p>Raft的论文中，Leader需要维护<code>commitIndex</code>和<code>lastApplied</code>这两个状态。为了简单起见，我们可以忽略“应用”（apply）这个过程。这两个状态我们只需要维护<code>commitIndex</code>即可。</p><blockquote><p>Raft协议不是2PC，千万不要搞混了哦～</p></blockquote><h4 id=回滚与滚回来>回滚与滚回来 <a href=#%e5%9b%9e%e6%bb%9a%e4%b8%8e%e6%bb%9a%e5%9b%9e%e6%9d%a5 class=anchor>🔗</a></h4><p><img src=https://raw.githubusercontent.com/Wizmann/assets/3f1056d6f142755204092fb89a474dc964608bab/wizmann-pic/2019-05-02_14-40-52.png alt=rollback></p><p>从上面的工作流我们可以看到，对于已经committed的日志，仍然有可能是不可靠的。</p><p>例如，在Term1时，节点1作业Leader提交到了日志(1, 2)，而Follower节点Node2和Node3分别提交到了日志(1, 2)和(1, 3)。此时Leader短暂断线，出发选举超时，就会进行下一轮的选举。如果节点Node2被选为Leader，那么节点Node3就会被Leader多出一条日志，这是不被允许的。如果节点Node3被选为Leader，那么Node2就比Leader在Term1少一条日志，需要补齐。</p><blockquote><p>这里有人可能会怀疑，节点2比节点3少一条日志，那么按照论文里的说法，因为节点3的日志比较节点2要多，所以只有节点3才能赢得下一轮选举。这其实是不对的，如果节点3断线，节点1和节点2仍然可以组成一个quorum，选举出Leader。</p></blockquote><p>所以我们需要考虑将已committed的日志回滚（向左滚），以及缺失的日志补齐（向右滚）。这里其实有一些优化的点，我们后文再说。</p><p>再次注意，保证日志的一致性是Raft协议正确性的必须保证，在这一点上一定要注意。</p><h4 id=乱序请求>乱序请求 <a href=#%e4%b9%b1%e5%ba%8f%e8%af%b7%e6%b1%82 class=anchor>🔗</a></h4><p>本项目中，模拟的RPC协议并不能保证可靠性（会丢包）、有序性（会乱序），也没有SLA（没有超时时间的上限），更不用想拥塞控制。我们可以理解为它在底层使用了UDP协议，而不是TCP。所以我们不能做出任何假设。</p><p>例如，两个请求先后来到Leader端，A请求编号(1,100)，B请求编号(1,110)。然后我们依次将Log复制到Follower端（A先B后），但是在Follower端有可能收到的顺序是B先A后。甚至只收到B，没收到A。这种情况日常工程中的TCP协议下几乎不能发生，但是在测试环境中要十分小心。</p><h4 id=checklist-for-2b2c>Checklist for 2B/2C <a href=#checklist-for-2b2c class=anchor>🔗</a></h4><ul><li>日志的状态会影响Leader选举<br>如果两份日志流的最后一条日志的Term不一样，那么我们认为Term号大的日志“比较新”。如果Term号一样，那么Index大的日志“比较新”</li><li>如果Leader和Follower的日志不一致，那么Follower需要拷贝Leader的日志（向左滚或向右滚的正确性）<br>这里推荐使用Assert加断言进行保证，如果出错可以获得实时的现场</li><li>对于小于当前Term的日志，Leader不需要等多数Follower确认就可以直接commit</li><li>一个重要特性：如果两个日志的(Term, Index)一致，那么其内容也是一致的。并且在此日志之前的所有日志都必须是一致的</li><li>另一个重要特性：RPC请求是幂等的，也就是多次重复发送一个请求并不会破坏Raft协议的状态</li></ul><h3 id=最后的3个case>最后的3个Case <a href=#%e6%9c%80%e5%90%8e%e7%9a%843%e4%b8%aacase class=anchor>🔗</a></h3><p>最后的三个Case有一个共同点，就是对协议的效率和正确性有比较高的要求。即使前面的代码里你的实现是正确的，也有可能因为各种其它的原因造成Case挂掉。</p><p>建议首先解决正确性问题，再提升效率。</p><h4 id=向左滚的优化重要>向左滚的优化（重要！） <a href=#%e5%90%91%e5%b7%a6%e6%bb%9a%e7%9a%84%e4%bc%98%e5%8c%96%e9%87%8d%e8%a6%81 class=anchor>🔗</a></h4><p>在论文的5.3节，介绍了一种回滚的优化。如果Leader和Follower在某个Index上的日志不一致，Leader的版本记为(Term1, Index)，Follower的版本记为(Term2, Index)。那么Follower需要回滚所有日志，直到Term小于<code>Min(Term1, Term2)</code>。</p><p>这样的好处是可以加快回滚的效率。虽然论文上表示这种优化并非必要，但是在模拟出来的极端网络环境下，这样的优化可以帮助我们通过一些比较变态的Case。</p><h4 id=其它的非官方优化>其它的非官方优化 <a href=#%e5%85%b6%e5%ae%83%e7%9a%84%e9%9d%9e%e5%ae%98%e6%96%b9%e4%bc%98%e5%8c%96 class=anchor>🔗</a></h4><p>这里还有一些论文里没的提到的优化方案，不保证一定是正确的。</p><p>为了不剧透，放到单独的链接里了：<a href=https://github.com/Wizmann/assets/blob/master/wizmann-pic/19-05-02/raft-hints.md>剧透警告！</a></p><blockquote><p>还有一个Bonus挑战，谁比较闲可以试一下。</p></blockquote><h2 id=测试结果>测试结果 <a href=#%e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c class=anchor>🔗</a></h2><p><img src=https://raw.githubusercontent.com/Wizmann/assets/e35dd59aa533ddd19065f070dcb85a3734cc035d/wizmann-pic/19-05-02/2019-05-02_21-37-14.png alt=tests></p><p>在Travis CI上面运行的测试。自我感觉实现的比较一般，所以你们的程序应该跑的比我快一点才正常。</p><h2 id=总结>总结 <a href=#%e6%80%bb%e7%bb%93 class=anchor>🔗</a></h2><p>想要完整正确的实现这个项目，首先一定要把论文读懂。并且划出实现上应该注意的重点。</p><p>当遇到正确性问题时，一定要回归论文，大部分的问题都可以获得解答。当遇到性能问题时，可以参考作业上面的Hints，里面也有非常有用的信息。</p><p>MIT的这个课程还有基于raft实现kv storage的项目，后续如果有时间应该还会做吧。</p></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>