<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Date: 2014-01-18 14:47
Title: Codeforces Round #223 (Div. 2) 不完全不正确题解
Tags: codeforces, algorithm, 算法, 题解
Slug: cf-223-div-2
由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/cf-223-div-2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/cf-223-div-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/cf-223-div-2/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:description" content="Date: 2014-01-18 14:47 Title: Codeforces Round #223 (Div. 2) 不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-223-div-2
由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Date: 2014-01-18 14:47
Title: Codeforces Round #223 (Div. 2) 不完全不正确题解
Tags: codeforces, algorithm, 算法, 题解
Slug: cf-223-div-2
由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://wizmann.top/posts/cf-223-div-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Date: 2014-01-18 14:47 Title: Codeforces Round #223 (Div. 2) 不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-223-div-2\n由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。\n等有实力切D题了，再去打一区。（弱\n","keywords":[],"articleBody":"Date: 2014-01-18 14:47 Title: Codeforces Round #223 (Div. 2) 不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-223-div-2\n由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。\n等有实力切D题了，再去打一区。（弱\n事情一直很多，所以题解落后了好久才发。\nA. Sereja and Dima 纯模拟，Python随便搞\nn = int(raw_input()) pokers = map(int, raw_input().split()) v = [0, 0] p = 0 for i in xrange(n): if pokers[0] \u003e pokers[-1]: v[p] += pokers[0] del pokers[0] else: v[p] += pokers[-1] del pokers[-1] p ^= 1 print v[0], v[1] B. Sereja and Stairs 题目要求实现一个数组，使前一半为递增，后一半为递减。\na[1] \u003c a[2] \u003c ... \u003c a[i - 1] \u003c a[i] \u003e a[i + 1] \u003e ... \u003e a[n - 1] \u003e a[n]\n所以我们观察到，某一个数x在数组a中最多可以出现两次，其中一次在左边的序列，一次在右边的序列。\n所以我们就对给出的数组s进行一次统计，找出每一个数出现的次数。\n并分别讨论出现一次和出现两次的情况。\nSIZE = 5120 n = int(raw_input()) cards = map(int, raw_input().split()) cnt = [0 for i in xrange(SIZE)] maxi = max(cards) for item in cards: cnt[item] += 1 left = [] right = [] for i in xrange(maxi): if cnt[i] == 1: left.append(i) elif cnt[i] \u003e 1: left.append(i) right.append(i) left.sort() right.sort(reverse=True) ans = left + [maxi] + right print len(ans) print ' '.join(map(str, ans)) C. Sereja and Prefixes 给定一个空序列A，然后这个序列上可以有两种操作。\n一是A.push_back(x)，二是A.push_back_batch(A[0]...A[i])。\n由于操作的次数是10^5，于是我们将序列A存成一个如下的形式。\na -\u003e b -\u003e c -\u003e copy(0...i) -\u003e d -\u003e copy(0 ... j)\n我们可以看出，如果询问的位置pos是一个数，则我们可以直接返回结果。如果询问的位置pos位于一个copy块里面，那么这个数一定会在A[0...i]中出现，则我们可以处理pos -\u003e pos'，使pos'位于A[0...i]区间内。如此循环，直到pos是一个数为止。\n然后这题用的算法貌似不是最快的，但是我觉得是最好理解的一种。\n使用一个大根堆循环取query中最大的值，然后进行处理。\n#include #include #include #include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x typedef long long llint; const int SIZE = 100010; struct node { llint st, end; llint prefix, rep; node(llint ist, llint pre, llint r) { st = ist; end = st + pre * r - 1; prefix = pre; rep = r; } node(llint ist, llint v) { st = end = ist; prefix = v; rep = -1; } node(){} bool is_value() { return rep == -1; } llint value() { return prefix; } bool contains(llint v) { return st \u003c= v \u0026\u0026 v \u003c= end; } }; struct query { llint v, q; query(){} query(llint iv, llint iq): v(iv), q(iq){} friend bool operator \u003c (const query\u0026 a, const query\u0026 b) { return a.v \u003c b.v; } }; priority_queue\u003cquery\u003e pq; int n, m; vector\u003cnode\u003e vec; map\u003cllint, llint\u003e mp; llint ask[SIZE]; void solve() { int ptr = vec.size() - 1; while (!pq.empty()) { query nn = pq.top(); llint now = nn.v; llint q = nn.q; pq.pop(); while (!vec[ptr].contains(now)) { ptr--; } if (vec[ptr].is_value()) { mp[q] = vec[ptr].value(); } else { llint delta = now - vec[ptr].st; delta %= vec[ptr].prefix; pq.push(query(delta + 1, q)); } } } int main() { llint a, b, c; input(n); llint st = 1; for (int i = 0; i \u003c n; i++) { input(a); if (a == 1) { input(b); vec.push_back(node(st, b)); st++; } else { input(b \u003e\u003e c); vec.push_back(node(st, b, c)); st = (--vec.end()) -\u003e end + 1; } } input(m); for (int i = 0; i \u003c m; i++) { input(a); ask[i] = a; pq.push(query(a, a)); } solve(); for (int i = 0; i \u003c m; i++) { if (i) printf(\" \"); printf(\"%lld\", mp[ask[i]]); } puts(\"\"); return 0; } D. Sereja and Tree 暴力乱搞，因为树的高度只有7000，所以怎么搞都大概能过。但是为什么做的人好少。\n可能是题目表述的不太好吧。\n#include #include #include #include #include #include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x typedef long long llint; const int SIZE = 7010; const int LINE = 501000; struct node { int l, r; int val; node(){} node(int il, int ir, int ival): l(il), r(ir), val(ival) {} }; int n, m; int ls[LINE], rs[LINE]; vector\u003cnode\u003e ins[SIZE]; bool intersect(int a, int b, int c, int d) { if (b \u003c c || a \u003e d) return false; return true; } void init() { ls[1] = 1; rs[1] = 2; int cnt, p = 3; for (int i = 2; i \u003c LINE; i++) { if ((1 \u003c\u003c cnt) == i) { cnt++; ls[i] = p++; rs[i] = p++; } else { ls[i] = -1; rs[i] = p++; } } } int query(int a, int b) { set\u003cint\u003e s; int ll = b, rr = b; for (int level = a; level \u003c= n; level++) { for (int i = 0; i \u003c (int)ins[level].size(); i++) { if (intersect(ll, rr, ins[level][i].l, ins[level][i].r)) { s.insert(ins[level][i].val); } } ll = ls[ll] == -1? rs[ll]: ls[ll]; rr = rs[rr]; } return s.size(); } int main() { int tp; int l, r; int a, b; init(); input(n \u003e\u003e m); while (m--) { input(tp); if (tp == 1) { input(a \u003e\u003e l \u003e\u003e r \u003e\u003e b); ins[a].push_back(node(l, r, b)); } else { input(a \u003e\u003e b); print(query(a, b)); } } return 0; } E. Sereja and Brackets 不出意外的又看错题了。。。_(:з」∠)_\n最长的括号区间居然是可以在中间删除一些括号的区间。这样题目就变成了一道比较简单的离线化+树状数组了。\n代码如下：\n#include #include #include #include #include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x typedef long long llint; const int SIZE = 1000100; struct ppair { int l, r; int id; ppair(){} ppair(int il, int ir, int iid): l(il), r(ir), id(iid) {} friend bool operator \u003c (const ppair\u0026 a, const ppair\u0026 b) { return a.r \u003c b.r; } }; inline int lowbit(int x) { return x\u0026(-x); } struct BIT//点更新，区间查询 { int baum[SIZE]; inline void init() { memset(baum,0,sizeof(baum)); } void add(int x,int val) { while(x\u003cSIZE) { baum[x]+=val; x+=lowbit(x); } } int sum(int x) { int res=0; while(x\u003e0) { res+=baum[x]; x-=lowbit(x); } return res; } int sum(int a,int b)//查询区间和 { return sum(b)-sum(a-1); } }; int q; char ss[SIZE]; vector\u003cppair\u003e match; vector\u003cppair\u003e query; vector\u003cint\u003e ans; void preload() { stack\u003cint\u003e st; for (int i = 0; ss[i]; i++) { char c = ss[i]; if (c == '(') { st.push(i); } else if (c == ')' \u0026\u0026 !st.empty()) { int now = st.top(); st.pop(); match.push_back(ppair(now + 1, i + 1, -1)); } } } void solve() { sort(match.begin(), match.end()); sort(query.begin(), query.end()); ans.resize(query.size()); BIT bit; bit.init(); int p = 0; for (int i = 0; i \u003c (int)query.size(); i++) { while (p \u003c (int)match.size() \u0026\u0026 match[p].r \u003c= query[i].r) { bit.add(match[p].l, 1); p++; } ans[query[i].id] = bit.sum(query[i].l, query[i].r); } } int main() { int a, b; scanf(\"%s\", ss); preload(); input(q); for (int i = 0; i \u003c q; i++) { input(a \u003e\u003e b); query.push_back(ppair(a, b, i)); } solve(); for (auto iter = ans.begin(); iter != ans.end(); ++iter) { print(*iter * 2); } return 0; } ","wordCount":"1678","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/cf-223-div-2/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>wizmann</div></header><div class=post-content><p>Date: 2014-01-18 14:47
Title: Codeforces Round #223 (Div. 2) 不完全不正确题解
Tags: codeforces, algorithm, 算法, 题解
Slug: cf-223-div-2</p><p>由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。</p><p>等有实力切D题了，再去打一区。（弱</p><p>事情一直很多，所以题解落后了好久才发。</p><h2 id=a-sereja-and-dima>A. Sereja and Dima<a hidden class=anchor aria-hidden=true href=#a-sereja-and-dima>#</a></h2><p>纯模拟，Python随便搞</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>n <span style=color:#f92672>=</span> int(raw_input())
</span></span><span style=display:flex><span>pokers <span style=color:#f92672>=</span> map(int, raw_input()<span style=color:#f92672>.</span>split())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>v <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> pokers[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>&gt;</span> pokers[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>        v[p] <span style=color:#f92672>+=</span> pokers[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>del</span> pokers[<span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        v[p] <span style=color:#f92672>+=</span> pokers[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>del</span> pokers[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]
</span></span><span style=display:flex><span>    p <span style=color:#f92672>^=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>print v[<span style=color:#ae81ff>0</span>], v[<span style=color:#ae81ff>1</span>]
</span></span></code></pre></div><h2 id=b-sereja-and-stairs>B. Sereja and Stairs<a hidden class=anchor aria-hidden=true href=#b-sereja-and-stairs>#</a></h2><p>题目要求实现一个数组，使前一半为递增，后一半为递减。</p><p><code>a[1] &lt; a[2] &lt; ... &lt; a[i - 1] &lt; a[i] > a[i + 1] > ... > a[n -  1] > a[n]</code></p><p>所以我们观察到，某一个数<code>x</code>在数组<code>a</code>中最多可以出现两次，其中一次在左边的序列，一次在右边的序列。</p><p>所以我们就对给出的数组<code>s</code>进行一次统计，找出每一个数出现的次数。</p><p>并分别讨论出现一次和出现两次的情况。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>5120</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>n <span style=color:#f92672>=</span> int(raw_input())
</span></span><span style=display:flex><span>cards <span style=color:#f92672>=</span> map(int, raw_input()<span style=color:#f92672>.</span>split())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>cnt <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span> <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(SIZE)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>maxi <span style=color:#f92672>=</span> max(cards)
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> item <span style=color:#f92672>in</span> cards:
</span></span><span style=display:flex><span>    cnt[item] <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>left <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>right <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(maxi):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> cnt[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        left<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> cnt[i] <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>        left<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>        right<span style=color:#f92672>.</span>append(i)
</span></span><span style=display:flex><span>left<span style=color:#f92672>.</span>sort()
</span></span><span style=display:flex><span>right<span style=color:#f92672>.</span>sort(reverse<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ans <span style=color:#f92672>=</span> left <span style=color:#f92672>+</span> [maxi] <span style=color:#f92672>+</span> right
</span></span><span style=display:flex><span>print len(ans)
</span></span><span style=display:flex><span>print <span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>.</span>join(map(str, ans))
</span></span></code></pre></div><h2 id=c-sereja-and-prefixes>C. Sereja and Prefixes<a hidden class=anchor aria-hidden=true href=#c-sereja-and-prefixes>#</a></h2><p>给定一个空序列<code>A</code>，然后这个序列上可以有两种操作。</p><p>一是<code>A.push_back(x)</code>，二是<code>A.push_back_batch(A[0]...A[i])</code>。</p><p>由于操作的次数是<code>10^5</code>，于是我们将序列<code>A</code>存成一个如下的形式。</p><p><code>a -> b -> c -> copy(0...i) -> d -> copy(0 ... j)</code></p><p>我们可以看出，如果询问的位置<code>pos</code>是一个数，则我们可以直接返回结果。如果询问的位置<code>pos</code>位于一个<code>copy</code>块里面，那么这个数一定会在<code>A[0...i]</code>中出现，则我们可以处理<code>pos</code> -> <code>pos'</code>，使<code>pos'</code>位于<code>A[0...i]</code>区间内。如此循环，直到<code>pos</code>是一个数为止。</p><p>然后这题用的算法貌似不是最快的，但是我觉得是最好理解的一种。</p><p>使用一个大根堆循环取<code>query</code>中最大的值，然后进行处理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> llint;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>100010</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> {
</span></span><span style=display:flex><span>    llint st, end;
</span></span><span style=display:flex><span>    llint prefix, rep;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node(llint ist, llint pre, llint r) {
</span></span><span style=display:flex><span>        st <span style=color:#f92672>=</span> ist;
</span></span><span style=display:flex><span>        end <span style=color:#f92672>=</span> st <span style=color:#f92672>+</span> pre <span style=color:#f92672>*</span> r <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        prefix <span style=color:#f92672>=</span> pre;
</span></span><span style=display:flex><span>        rep <span style=color:#f92672>=</span> r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node(llint ist, llint v) {
</span></span><span style=display:flex><span>        st <span style=color:#f92672>=</span> end <span style=color:#f92672>=</span> ist;
</span></span><span style=display:flex><span>        prefix <span style=color:#f92672>=</span> v;
</span></span><span style=display:flex><span>        rep <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node(){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>is_value</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> rep <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    llint <span style=color:#a6e22e>value</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prefix;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>contains</span>(llint v) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> st <span style=color:#f92672>&lt;=</span> v <span style=color:#f92672>&amp;&amp;</span> v <span style=color:#f92672>&lt;=</span> end;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>query</span> {
</span></span><span style=display:flex><span>    llint v, q;
</span></span><span style=display:flex><span>    query(){}
</span></span><span style=display:flex><span>    query(llint iv, llint iq)<span style=color:#f92672>:</span> v(iv), q(iq){}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>const</span> query<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> query<span style=color:#f92672>&amp;</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a.v <span style=color:#f92672>&lt;</span> b.v;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>priority_queue<span style=color:#f92672>&lt;</span>query<span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n, m;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>node<span style=color:#f92672>&gt;</span> vec;
</span></span><span style=display:flex><span>map<span style=color:#f92672>&lt;</span>llint, llint<span style=color:#f92672>&gt;</span> mp;
</span></span><span style=display:flex><span>llint ask[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>solve</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ptr <span style=color:#f92672>=</span> vec.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>pq.empty()) {
</span></span><span style=display:flex><span>        query nn <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>        llint now <span style=color:#f92672>=</span> nn.v;
</span></span><span style=display:flex><span>        llint q <span style=color:#f92672>=</span> nn.q;
</span></span><span style=display:flex><span>        pq.pop();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>vec[ptr].contains(now)) {
</span></span><span style=display:flex><span>            ptr<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (vec[ptr].is_value()) {
</span></span><span style=display:flex><span>            mp[q] <span style=color:#f92672>=</span> vec[ptr].value();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            llint delta <span style=color:#f92672>=</span> now <span style=color:#f92672>-</span> vec[ptr].st;
</span></span><span style=display:flex><span>            delta <span style=color:#f92672>%=</span> vec[ptr].prefix;
</span></span><span style=display:flex><span>            pq.push(query(delta <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, q));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    llint a, b, c;
</span></span><span style=display:flex><span>    input(n);
</span></span><span style=display:flex><span>    llint st <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(a);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            input(b);
</span></span><span style=display:flex><span>            vec.push_back(node(st, b));
</span></span><span style=display:flex><span>            st<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            input(b <span style=color:#f92672>&gt;&gt;</span> c);
</span></span><span style=display:flex><span>            vec.push_back(node(st, b, c));
</span></span><span style=display:flex><span>            st <span style=color:#f92672>=</span> (<span style=color:#f92672>--</span>vec.end()) <span style=color:#f92672>-&gt;</span> end <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    input(m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(a);
</span></span><span style=display:flex><span>        ask[i] <span style=color:#f92672>=</span> a;
</span></span><span style=display:flex><span>        pq.push(query(a, a));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    solve();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> m; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (i) printf(<span style=color:#e6db74>&#34; &#34;</span>);
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%lld&#34;</span>, mp[ask[i]]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    puts(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=d-sereja-and-tree>D. Sereja and Tree<a hidden class=anchor aria-hidden=true href=#d-sereja-and-tree>#</a></h2><p>暴力乱搞，因为树的高度只有7000，所以怎么搞都大概能过。但是为什么做的人好少。</p><p>可能是题目表述的不太好吧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;set&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> llint;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>7010</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> LINE <span style=color:#f92672>=</span> <span style=color:#ae81ff>501000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l, r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> val;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    node(){}
</span></span><span style=display:flex><span>    node(<span style=color:#66d9ef>int</span> il, <span style=color:#66d9ef>int</span> ir, <span style=color:#66d9ef>int</span> ival)<span style=color:#f92672>:</span> l(il), r(ir), val(ival) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n, m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ls[LINE], rs[LINE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>node<span style=color:#f92672>&gt;</span> ins[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>intersect</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b, <span style=color:#66d9ef>int</span> c, <span style=color:#66d9ef>int</span> d) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (b <span style=color:#f92672>&lt;</span> c <span style=color:#f92672>||</span> a <span style=color:#f92672>&gt;</span> d) <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ls[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    rs[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt, p <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>; i <span style=color:#f92672>&lt;</span> LINE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((<span style=color:#ae81ff>1</span> <span style=color:#f92672>&lt;&lt;</span> cnt) <span style=color:#f92672>==</span> i) {
</span></span><span style=display:flex><span>            cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            ls[i] <span style=color:#f92672>=</span> p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            rs[i] <span style=color:#f92672>=</span> p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            ls[i] <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            rs[i] <span style=color:#f92672>=</span> p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>query</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    set<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> s;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ll <span style=color:#f92672>=</span> b, rr <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> level <span style=color:#f92672>=</span> a; level <span style=color:#f92672>&lt;=</span> n; level<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>int</span>)ins[level].size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (intersect(ll, rr, ins[level][i].l, ins[level][i].r)) {
</span></span><span style=display:flex><span>                s.insert(ins[level][i].val);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        ll <span style=color:#f92672>=</span> ls[ll] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span><span style=color:#f92672>?</span> rs[ll]<span style=color:#f92672>:</span> ls[ll];
</span></span><span style=display:flex><span>        rr <span style=color:#f92672>=</span> rs[rr];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> s.size();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> tp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l, r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a, b;
</span></span><span style=display:flex><span>    init();
</span></span><span style=display:flex><span>    input(n <span style=color:#f92672>&gt;&gt;</span> m);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (m<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        input(tp);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tp <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            input(a <span style=color:#f92672>&gt;&gt;</span> l <span style=color:#f92672>&gt;&gt;</span> r <span style=color:#f92672>&gt;&gt;</span> b);
</span></span><span style=display:flex><span>            ins[a].push_back(node(l, r, b));
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            input(a <span style=color:#f92672>&gt;&gt;</span> b);
</span></span><span style=display:flex><span>            print(query(a, b));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e-sereja-and-brackets>E. Sereja and Brackets<a hidden class=anchor aria-hidden=true href=#e-sereja-and-brackets>#</a></h2><p>不出意外的又看错题了。。。_(:з」∠)_</p><p>最长的括号区间居然是可以在中间删除一些括号的区间。这样题目就变成了一道比较简单的<code>离线化+树状数组</code>了。</p><p>代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> llint;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>1000100</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ppair</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l, r;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> id;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    ppair(){}
</span></span><span style=display:flex><span>    ppair(<span style=color:#66d9ef>int</span> il, <span style=color:#66d9ef>int</span> ir, <span style=color:#66d9ef>int</span> iid)<span style=color:#f92672>:</span> l(il), r(ir), id(iid) {}
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>friend</span> <span style=color:#66d9ef>bool</span> <span style=color:#66d9ef>operator</span> <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>const</span> ppair<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> ppair<span style=color:#f92672>&amp;</span> b) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a.r <span style=color:#f92672>&lt;</span> b.r;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>lowbit</span>(<span style=color:#66d9ef>int</span> x)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x<span style=color:#f92672>&amp;</span>(<span style=color:#f92672>-</span>x);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>BIT</span><span style=color:#75715e>//点更新，区间查询
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> baum[SIZE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        memset(baum,<span style=color:#ae81ff>0</span>,<span style=color:#66d9ef>sizeof</span>(baum));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add</span>(<span style=color:#66d9ef>int</span> x,<span style=color:#66d9ef>int</span> val)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(x<span style=color:#f92672>&lt;</span>SIZE)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            baum[x]<span style=color:#f92672>+=</span>val;
</span></span><span style=display:flex><span>            x<span style=color:#f92672>+=</span>lowbit(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> x)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(x<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            res<span style=color:#f92672>+=</span>baum[x];
</span></span><span style=display:flex><span>            x<span style=color:#f92672>-=</span>lowbit(x);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span> a,<span style=color:#66d9ef>int</span> b)<span style=color:#75715e>//查询区间和
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum(b)<span style=color:#f92672>-</span>sum(a<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> q;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> ss[SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>ppair<span style=color:#f92672>&gt;</span> match;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>ppair<span style=color:#f92672>&gt;</span> query;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ans;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>preload</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> st;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; ss[i]; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> ss[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;(&#39;</span>) {
</span></span><span style=display:flex><span>            st.push(i);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;)&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>st.empty()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> now <span style=color:#f92672>=</span> st.top();
</span></span><span style=display:flex><span>            st.pop();
</span></span><span style=display:flex><span>            match.push_back(ppair(now <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, i <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>));
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>solve</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sort(match.begin(), match.end());
</span></span><span style=display:flex><span>    sort(query.begin(), query.end());
</span></span><span style=display:flex><span>    ans.resize(query.size());
</span></span><span style=display:flex><span>    BIT bit;
</span></span><span style=display:flex><span>    bit.init();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>int</span>)query.size(); i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (p <span style=color:#f92672>&lt;</span> (<span style=color:#66d9ef>int</span>)match.size() <span style=color:#f92672>&amp;&amp;</span> match[p].r <span style=color:#f92672>&lt;=</span> query[i].r) {
</span></span><span style=display:flex><span>            bit.add(match[p].l, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            p<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        ans[query[i].id] <span style=color:#f92672>=</span> bit.sum(query[i].l, query[i].r);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> a, b;
</span></span><span style=display:flex><span>    scanf(<span style=color:#e6db74>&#34;%s&#34;</span>, ss);
</span></span><span style=display:flex><span>    preload();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input(q);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> q; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(a <span style=color:#f92672>&gt;&gt;</span> b);
</span></span><span style=display:flex><span>        query.push_back(ppair(a, b, i));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    solve();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> iter <span style=color:#f92672>=</span> ans.begin(); iter <span style=color:#f92672>!=</span> ans.end(); <span style=color:#f92672>++</span>iter) {
</span></span><span style=display:flex><span>        print(<span style=color:#f92672>*</span>iter <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/cf-221-div-2/><span class=title>«</span><br><span></span>
</a><a class=next href=https://wizmann.top/posts/cf-240-div-2/><span class=title>»</span><br><span></span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>