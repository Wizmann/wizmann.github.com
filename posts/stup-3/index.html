<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>STUP - the Implementation (3)</title>
<meta name=description content="throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?
"><link rel=canonical href=https://wizmann.top/posts/stup-3/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/stup-3/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/stup-3/><meta property="og:title" content="STUP - the Implementation (3)"><meta property="og:description" content="throughput and window size
The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?"><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/stup-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-08T22:15:58+00:00"><meta property="article:modified_time" content="2017-05-08T22:15:58+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="STUP - the Implementation (3)"><meta name=twitter:description content="throughput and window size
The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"STUP - the Implementation (3)","datePublished":"2017-05-08T22:15:58+00:00","dateModified":"2017-05-08T22:15:58+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":381,"description":"throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.\nBoth windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h2 id=throughput-and-window-size>throughput and window size</h2><p>The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.</p><p>Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?</p><p>TCP use congestion control to achieve high performance (really?) and avoid congestion collapse. But here in STUP, we have different situations.</p><p>Firstly, we need real high performance. We don&rsquo;t want the window size cut into half when there is a lost / timeout packet, which is very normal in our &ldquo;long thin pipe&rdquo;. Secondly, STUP is not a protocol for general usage, by the initial design, it should be used in an exclusive, non-production environment. So we don&rsquo;t need to care about our neighbors, we can just use up a reserved, reasonable bandwidth.</p><p>However, be aware of the number in <code>Config.py</code>. Our router was down once because of a wrong configuration. :)</p><h2 id=other-mechanisms-and-algorithms-in-stup>other mechanisms and algorithms in STUP</h2><ul><li>Keep Alive</li><li>Nagle algorithm</li><li>Piggybacking</li><li>Fast retransmission</li></ul><p>These features are copied from TCP protocol and absolutely a clich√© to have a discuss here. If you have any problem about these, just look it up in Wikipedia.</p><h2 id=twisted-twisted-framework>twisted Twisted Framework</h2><p>STUP protocol takes me about a whole year to do the development work (and it&rsquo;s not finished yet). But for more than half of the time, I was struggling with the Twisted framework. For people who want to learn more about Twisted Framework, you can read the <a href=http://twistedmatrix.com/trac/wiki/Documentation target=_blank rel=noopener>official manual</a> or look through <a href=/twisted-defer-and-deferredqueue.html>this blog</a> for a quick start.</p><p>What a pun!</p><h2 id=future-of-stup>future of STUP</h2><p>Since STUP protocol is written in Python, one of the main problem is the performance. As a result, I&rsquo;m planning to rewrite this with C++ (and golang, perhaps) to gain a better performance. I call it: STUPP (STUP in cpp).</p><p>In STUPP, several features are to be added:</p><ul><li>Selective ACK</li><li>Monotonic strictly increasing sequence number to prevent replay attacks</li><li>Multiple socks5 connections share a single STUP connection</li></ul></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>