<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>STUP - the Implementation (3) | Maerlyn's Rainbow</title>
<meta name=keywords content="STUP,TCP,UDP,networking,protocol"><meta name=description content="throughput and window size
The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/stup-3/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/stup-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/stup-3/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="STUP - the Implementation (3)"><meta property="og:description" content="throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2017-05-08T22:15:58+00:00"><meta property="article:modified_time" content="2017-05-08T22:15:58+00:00"><meta property="article:tag" content="STUP"><meta property="article:tag" content="TCP"><meta property="article:tag" content="UDP"><meta property="article:tag" content="Networking"><meta property="article:tag" content="Protocol"><meta name=twitter:card content="summary"><meta name=twitter:title content="STUP - the Implementation (3)"><meta name=twitter:description content="throughput and window size
The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"STUP - the Implementation (3)","item":"https://wizmann.top/posts/stup-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"STUP - the Implementation (3)","name":"STUP - the Implementation (3)","description":"throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.\nBoth windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?\n","keywords":["STUP","TCP","UDP","networking","protocol"],"articleBody":"throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.\nBoth windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?\nTCP use congestion control to achieve high performance (really?) and avoid congestion collapse. But here in STUP, we have different situations.\nFirstly, we need real high performance. We don’t want the window size cut into half when there is a lost / timeout packet, which is very normal in our “long thin pipe”. Secondly, STUP is not a protocol for general usage, by the initial design, it should be used in an exclusive, non-production environment. So we don’t need to care about our neighbors, we can just use up a reserved, reasonable bandwidth.\nHowever, be aware of the number in Config.py. Our router was down once because of a wrong configuration. :)\nother mechanisms and algorithms in STUP Keep Alive Nagle algorithm Piggybacking Fast retransmission These features are copied from TCP protocol and absolutely a cliché to have a discuss here. If you have any problem about these, just look it up in Wikipedia.\ntwisted Twisted Framework STUP protocol takes me about a whole year to do the development work (and it’s not finished yet). But for more than half of the time, I was struggling with the Twisted framework. For people who want to learn more about Twisted Framework, you can read the official manual or look through this blog for a quick start.\nWhat a pun!\nfuture of STUP Since STUP protocol is written in Python, one of the main problem is the performance. As a result, I’m planning to rewrite this with C++ (and golang, perhaps) to gain a better performance. I call it: STUPP (STUP in cpp).\nIn STUPP, several features are to be added:\nSelective ACK Monotonic strictly increasing sequence number to prevent replay attacks Multiple socks5 connections share a single STUP connection ","wordCount":"381","inLanguage":"zh-cn","datePublished":"2017-05-08T22:15:58Z","dateModified":"2017-05-08T22:15:58Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/stup-3/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">STUP - the Implementation (3)</h1><div class=post-meta><span title='2017-05-08 22:15:58 +0000 UTC'>May 8, 2017</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=throughput-and-window-size>throughput and window size<a hidden class=anchor aria-hidden=true href=#throughput-and-window-size>#</a></h2><p>The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.</p><p>Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?</p><p>TCP use congestion control to achieve high performance (really?) and avoid congestion collapse. But here in STUP, we have different situations.</p><p>Firstly, we need real high performance. We don&rsquo;t want the window size cut into half when there is a lost / timeout packet, which is very normal in our &ldquo;long thin pipe&rdquo;. Secondly, STUP is not a protocol for general usage, by the initial design, it should be used in an exclusive, non-production environment. So we don&rsquo;t need to care about our neighbors, we can just use up a reserved, reasonable bandwidth.</p><p>However, be aware of the number in <code>Config.py</code>. Our router was down once because of a wrong configuration. :)</p><h2 id=other-mechanisms-and-algorithms-in-stup>other mechanisms and algorithms in STUP<a hidden class=anchor aria-hidden=true href=#other-mechanisms-and-algorithms-in-stup>#</a></h2><ul><li>Keep Alive</li><li>Nagle algorithm</li><li>Piggybacking</li><li>Fast retransmission</li></ul><p>These features are copied from TCP protocol and absolutely a cliché to have a discuss here. If you have any problem about these, just look it up in Wikipedia.</p><h2 id=twisted-twisted-framework>twisted Twisted Framework<a hidden class=anchor aria-hidden=true href=#twisted-twisted-framework>#</a></h2><p>STUP protocol takes me about a whole year to do the development work (and it&rsquo;s not finished yet). But for more than half of the time, I was struggling with the Twisted framework. For people who want to learn more about Twisted Framework, you can read the <a href=http://twistedmatrix.com/trac/wiki/Documentation>official manual</a> or look through <a href=/twisted-defer-and-deferredqueue.html>this blog</a> for a quick start.</p><p>What a pun!</p><h2 id=future-of-stup>future of STUP<a hidden class=anchor aria-hidden=true href=#future-of-stup>#</a></h2><p>Since STUP protocol is written in Python, one of the main problem is the performance. As a result, I&rsquo;m planning to rewrite this with C++ (and golang, perhaps) to gain a better performance. I call it: STUPP (STUP in cpp).</p><p>In STUPP, several features are to be added:</p><ul><li>Selective ACK</li><li>Monotonic strictly increasing sequence number to prevent replay attacks</li><li>Multiple socks5 connections share a single STUP connection</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/stup/>STUP</a></li><li><a href=https://wizmann.top/tags/tcp/>TCP</a></li><li><a href=https://wizmann.top/tags/udp/>UDP</a></li><li><a href=https://wizmann.top/tags/networking/>Networking</a></li><li><a href=https://wizmann.top/tags/protocol/>Protocol</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/why-do-i-quit-leetcode-contest/><span class=title>«</span><br><span>Why do I quit Leetcode contest?</span>
</a><a class=next href=https://wizmann.top/posts/stup-2/><span class=title>»</span><br><span>STUP - Packet Structure and State Machine (2)</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>