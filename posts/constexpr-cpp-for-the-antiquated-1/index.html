<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>constexpr详解 - C++ for the Antiquated（之一）</h1><div class=tip><time datetime="2024-12-28 00:00:00 +0000 UTC">2024/12/28</time>
<span class=split>·</span>
<span>2768 words </span><span class=split>·</span>
<span>6 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/cpp>cpp</a>
<a href=/tags/modern-cpp>modern cpp</a></div></div><hr><div class=content><p>在这篇文章中，我们将深入讨论 C++ 中的常量表达式（<code>constexpr</code>）及其与传统的<code>const</code>常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨<code>constexpr</code>函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。</p><h2 id=常量表达式constexpr>常量表达式（constexpr） <a href=#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8fconstexpr class=anchor>🔗</a></h2><p>在 C++ 中，<code>const</code> 关键字通常用于修饰变量、引用和指针，使得它们在运行时不能被修改。需要注意的是，<code>const</code> 并没有区分编译期常量和运行时常量，它只是保证了这些变量在运行时不可修改。</p><p>例如，使用 <code>const</code> 声明的变量在运行时其值是固定的，但并不意味着它们在编译时已知。</p><p>下面是传统 C++ 中 <code>const</code> 关键字的一些常见用法：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define CONSTANT_1 114514  </span><span style=color:#75715e>// 宏也是一种常量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> helloworld1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;helloworld&#34;</span>;  <span style=color:#75715e>// const 字符串
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> value1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 常量值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> value2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> value3 <span style=color:#f92672>=</span> value1 <span style=color:#f92672>+</span> value2;  <span style=color:#75715e>// 运行时计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> value8 <span style=color:#f92672>=</span> pow(value2, value3); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> arr_pow_of_2[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>};  <span style=color:#75715e>// 数组初始化
</span></span></span></code></pre></div><p>在上述代码中，虽然 const 修饰的变量在程序运行期间不能修改，但它们的值是在运行时计算的。因此，我们无法在编译时将它们视为常量。所以，<code>const</code> 变量也可以有内存地址，并且在某些情况下可以使用 <code>const_cast</code> 强行进行修改。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>MakeChange</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>(<span style=color:#66d9ef>const_cast</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>*&gt;</span>(<span style=color:#f92672>&amp;</span>x)) <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    MakeChange(x);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> x <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出：2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=引入-constexpr>引入 constexpr <a href=#%e5%bc%95%e5%85%a5-constexpr class=anchor>🔗</a></h3><p>C++11 引入了 <code>constexpr</code>，它的字面意思是 <code>constant expression</code>（常量表达式），用于在编译时计算常量值。与 <code>const</code> 不同，<code>constexpr</code> 确保一个变量或者函数的值是在编译时已知的，编译器会在编译时对其进行求值。</p><p>通过使用 <code>constexpr</code>，我们可以定义编译时常量，并且 <code>constexpr</code> 函数在某些情况下也能够在编译期计算结果。</p><p>使用 <code>constexpr</code> 重写上述代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> helloworld1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;helloworld&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value3 <span style=color:#f92672>=</span> value1 <span style=color:#f92672>+</span> value2;  <span style=color:#75715e>// 编译期计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value8 <span style=color:#f92672>=</span> pow(value2, value3);  <span style=color:#75715e>// 编译期计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 编译期初始化数组
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> arr_pow_of_2[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>};  
</span></span></code></pre></div><h2 id=常量表达式函数>常量表达式函数 <a href=#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%87%bd%e6%95%b0 class=anchor>🔗</a></h2><p><code>constexpr</code> 不仅可以修饰变量，还可以修饰函数。<code>constexpr</code> 函数的特性是，若输入的参数是编译时常量，那么它的返回值也是一个编译时常量。</p><p>以下是一个计算 Fibonacci 数列的示例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint64_t</span> MOD <span style=color:#f92672>=</span> (<span style=color:#ae81ff>1LL</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>62</span>) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;  <span style=color:#75715e>// 编译时常量
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint64_t</span> <span style=color:#a6e22e>fib</span>(<span style=color:#66d9ef>uint64_t</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint64_t</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, b <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>uint64_t</span> temp <span style=color:#f92672>=</span> a <span style=color:#f92672>+</span> b;
</span></span><span style=display:flex><span>        a <span style=color:#f92672>=</span> b;
</span></span><span style=display:flex><span>        b <span style=color:#f92672>=</span> temp <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> b;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 在编译期计算 Fibonacci 数列
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint64_t</span> result <span style=color:#f92672>=</span> fib(<span style=color:#ae81ff>123456</span>);  
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> result <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这段代码中，<code>fib</code> 函数被标记为 <code>constexpr</code>，因此当传入常量参数时，编译器会在编译期间计算出 Fibonacci 数列的第 <code>123456</code> 项。需要注意的是，<code>constexpr</code> 函数的计算存在一些限制：</p><ol><li><strong>递归深度限制</strong>：constexpr 函数的递归深度通常受到编译器的限制，如果递归过深，编译器可能会产生错误或警告。</li><li><strong>计算效率</strong>：尽管常量表达式函数可以在编译期计算，但对于复杂的运算，可能会增加编译时间，因为编译器需要进行更多的计算。</li></ol><h3 id=constexpr-vs-模板元编程>constexpr vs 模板元编程 <a href=#constexpr-vs-%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b class=anchor>🔗</a></h3><p><code>constexpr</code> 函数的使用在某种程度上简化了模板元编程。传统的模板元编程可以实现与 <code>constexpr</code> 类似的功能，但代码结构通常更加复杂。下面是使用模板元编程计算 Fibonacci 数列的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> MOD <span style=color:#f92672>=</span> <span style=color:#ae81ff>1999</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>uint64_t</span> N<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fibonacci</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> value <span style=color:#f92672>=</span> (Fibonacci<span style=color:#f92672>&lt;</span>N <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>+</span> Fibonacci<span style=color:#f92672>&lt;</span>N <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;::</span>value) <span style=color:#f92672>%</span> MOD;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fibonacci</span><span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;</span> { <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> value <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; };
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;&gt;</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Fibonacci</span><span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span> { <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>uint64_t</span> value <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Fibonacci(40): &#34;</span> <span style=color:#f92672>&lt;&lt;</span> Fibonacci<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>40</span><span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在这个模板元编程示例中，Fibonacci 结构体使用递归模板计算 Fibonacci 数列的第 N 项。这与 <code>constexpr</code> 函数类似，但模板元编程的语法更加繁琐。<code>constexpr</code> 的优势在于它能够写出更加接近正常逻辑代码的形式，并且具有更强的表达能力</p><h3 id=c14-对常量表达式函数的增强>C++14 对常量表达式函数的增强 <a href=#c14-%e5%af%b9%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%87%bd%e6%95%b0%e7%9a%84%e5%a2%9e%e5%bc%ba class=anchor>🔗</a></h3><p>在 C++14 中，常量表达式函数得到了进一步的增强。具体增强包括：</p><ul><li><strong>支持局部变量</strong>：<code>constexpr</code> 函数可以声明和初始化局部变量，但不能声明未初始化的变量、<code>static</code> 或 <code>thread_local</code> 变量。</li><li><strong>支持 if 和 switch 语句</strong>：<code>constexpr</code> 函数可以使用 <code>if</code> 和 <code>switch</code> 语句来控制流程，但不能使用 <code>got</code>o。</li><li><strong>支持循环语句</strong>：<code>constexpr</code> 函数支持所有类型的循环语句，包括 <code>for</code>、<code>while</code> 和 <code>do-while</code>。</li><li><strong>修改生命周期</strong>：在 constexpr 函数内部，可以修改局部变量和非常量引用参数</li><li><strong>返回值可以是 void</strong>：<code>constexpr</code> 函数可以声明返回类型为 <code>void</code>。</li></ul><h2 id=常量表达式与模板函数>常量表达式与模板函数 <a href=#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%8e%e6%a8%a1%e6%9d%bf%e5%87%bd%e6%95%b0 class=anchor>🔗</a></h2><p>在 C++11 引入 <code>constexpr</code> 后，建议在所有需要常量语义的场景中使用 <code>constexpr</code>。<code>constexpr</code> 变量和函数作为编译时常量，在模板函数中具有广泛的应用场景，能够显著提升程序的效率和可读性。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> T square(T x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>uint64_t</span> square2 <span style=color:#f92672>=</span> square(<span style=color:#ae81ff>2</span>);       <span style=color:#75715e>// 计算常量的平方
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>double</span> square2_0 <span style=color:#f92672>=</span> square(<span style=color:#ae81ff>2.0</span>);     <span style=color:#75715e>// 计算浮点数的平方
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;%lu</span><span style=color:#ae81ff>\t</span><span style=color:#e6db74>%.04lf</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, square2, square2_0);  <span style=color:#75715e>// 输出结果
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>模板函数 <code>square</code> 使用了 <code>constexpr</code>，确保在编译时就可以计算结果。对于不同类型的参数（如整数、浮点数），模板会自动进行实例化。</p><p>如果模板参数不是编译期常量，<code>constexpr</code> 将不会在编译期执行，但函数本身仍然是有效的。</p><h2 id=constexpr-函数中的动态内存分配>constexpr 函数中的动态内存分配 <a href=#constexpr-%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d class=anchor>🔗</a></h2><p>在 C++20 中，<code>constexpr</code> 函数得到了进一步增强，支持在编译期进行动态内存分配，但仍然存在一些限制。</p><p><code>std::array</code> 的所有数据都存储在栈上，而不是堆上。严格的说，<code>std::array</code>不涉及动态内存分配。所以<code>std::array</code>可以在<code>constexpr</code>函数中被初始化、修改并返回。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;array&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> maxstep<span style=color:#f92672>=</span><span style=color:#ae81ff>100</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, maxstep<span style=color:#f92672>&gt;</span> Collatz(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>array<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, maxstep<span style=color:#f92672>&gt;</span> path;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> idx <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>        path[idx<span style=color:#f92672>++</span>] <span style=color:#f92672>=</span> x;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (x <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            x <span style=color:#f92672>/=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (x <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> x <span style=color:#f92672>*</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> path;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> path <span style=color:#f92672>=</span> Collatz(<span style=color:#ae81ff>12345</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> item : path) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (item <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, item);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而对于<code>std::string</code>或者<code>std::vector</code>这种 需要在堆上分配内存的数据结构，我们则不可以在constexpr函数中直接返回。但是可以在constexpr函数中则用其进行计算。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;array&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>square</span>(<span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x <span style=color:#f92672>*</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>CountPrimes</span>(<span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> primes{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>};
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>; i <span style=color:#f92672>&lt;=</span> n; i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> flag <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> prime : primes) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (i <span style=color:#f92672>%</span> prime <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (square(prime) <span style=color:#f92672>&gt;=</span> i) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (flag) {
</span></span><span style=display:flex><span>            primes.push_back(i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> primes.size();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> CountPrimes(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, cnt);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=constexpr-virtual-函数>constexpr virtual 函数 <a href=#constexpr-virtual-%e5%87%bd%e6%95%b0 class=anchor>🔗</a></h2><p>在 C++20 中，<code>constexpr</code> 函数可以与 <code>virtual</code> 关键字结合使用，实现在编译期进行多态求值。</p><p>虚函数的 constexpr 限制：constexpr 虚函数只能在编译期求值，前提是其被调用的具体对象类型是确定的。</p><p>在 constexpr 上下文中调用 virtual 函数时，调用将绑定到具体派生类的实现。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Base</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Value</span>() <span style=color:#66d9ef>const</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#75715e>// 虚拟 constexpr 函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived1</span> <span style=color:#f92672>:</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Value</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span> { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Derived2</span> <span style=color:#f92672>:</span> Base {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Value</span>() <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>override</span> { <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>; }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>Calc</span>() {
</span></span><span style=display:flex><span>    Base<span style=color:#f92672>*</span> d1 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived1(); <span style=color:#75715e>// constexpr 中分配内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Base<span style=color:#f92672>*</span> d2 <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Derived2();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> d1<span style=color:#f92672>-&gt;</span>Value() <span style=color:#f92672>+</span> d2<span style=color:#f92672>-&gt;</span>Value(); <span style=color:#75715e>// 调用虚函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> d1; <span style=color:#75715e>// 必须释放内存
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>delete</span> d2;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> value;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>auto</span> v <span style=color:#f92672>=</span> Calc(); <span style=color:#75715e>// 在编译期计算
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    printf(<span style=color:#e6db74>&#34;%d</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, v);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> v;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=常量表达式用于模板函数的类型判断>常量表达式用于模板函数的类型判断 <a href=#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e7%94%a8%e4%ba%8e%e6%a8%a1%e6%9d%bf%e5%87%bd%e6%95%b0%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad class=anchor>🔗</a></h2><p>在 C++17 中引入的 <code>if constexpr</code> 提供了一种更加简洁和可读的方式来进行模板元编程的类型判断。根据类型特性，在编译期选择不同的分支路径。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdint&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cmath&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;type_traits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> equal(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> a, <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (std<span style=color:#f92672>::</span>is_integral_v<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> a <span style=color:#f92672>==</span> b; <span style=color:#75715e>// 整数类型直接比较
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>constexpr</span> (std<span style=color:#f92672>::</span>is_floating_point_v<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> fabs(a <span style=color:#f92672>-</span> b) <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1e-3</span>; <span style=color:#75715e>// 浮点数进行误差比较
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static_assert</span>(std<span style=color:#f92672>::</span>is_arithmetic_v<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>||</span> std<span style=color:#f92672>::</span>is_pointer_v<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>, <span style=color:#e6db74>&#34;not supported&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>boolalpha;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> equal(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;                 <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> equal(<span style=color:#ae81ff>1L</span>, <span style=color:#ae81ff>1L</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;               <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> equal(<span style=color:#ae81ff>1.0000001</span>, <span style=color:#ae81ff>1.000002</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> equal(<span style=color:#ae81ff>1.0000001</span>, <span style=color:#ae81ff>2.000002</span>) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在传统C++中，我们常用<code>std::enable_if</code>来实现类似的功能。但是很明显，语法会显得过于笨重。</p><div class=mermaid>#include <type_traits>#include <cmath>#include <cstdio>// 整数类型
template <typename t>typename std::enable_if<std::is_integral<t>::value, bool>::type
equal(const T& a, const T& b) {
    return a == b;
}
// 浮点类型
template <typename t>typename std::enable_if<std::is_floating_point<t>::value, bool>::type
equal(const T& a, const T& b) {
    return std::fabs(a - b) <= 1e-3;
}
// 其他类型
template <typename t>typename std::enable_if<
!(std::is_integral<t>::value || std::is_floating_point<t>::value), bool>::type
equal(const T& a, const T& b) {
    static_assert(std::is_arithmetic<t>::value || std::is_pointer<t>::value, "not supported");
return false;
}
int main() {
puts(equal(1, 1) ? "true" : "false"); // 整数
puts(equal(1.0000001, 1.000002) ? "true" : "false"); // 浮点
return 0;
}</div><h2 id=使用consteval强制使用编译期求值>使用<code>consteval</code>强制使用编译期求值 <a href=#%e4%bd%bf%e7%94%a8consteval%e5%bc%ba%e5%88%b6%e4%bd%bf%e7%94%a8%e7%bc%96%e8%af%91%e6%9c%9f%e6%b1%82%e5%80%bc class=anchor>🔗</a></h2><p><code>consteval</code> 是在 C++20 中引入的关键字，用于声明立即函数（immediate function）。立即函数要求在编译时进行求值，不能在运行时调用。
如果调用一个<code>consteval</code>。如果调用 <code>consteval</code> 函数时无法在编译期计算，编译器将报错。</p><p><code>constexpr</code> 函数在某些情况下可能会退化为运行时调用，<code>consteval</code> 可以避免这种情况。</p><p>例如：</p><div class=mermaid>#include <iostream>// consteval 强制要求在编译时进行计算
consteval int factorial(int n) {
return (n <= 1) ? 1 : (n * factorial(n - 1));
}
int main() {
constexpr int result = factorial(5); // OK：在编译时计算
std::cout << "Factorial of 5 is: " << result << std::endl;
// int runtime = 5;
// std::cout << "Factorial of runtime: " << factorial(runtime) << std::endl;
// 错误：factorial 必须在编译时调用
return 0;
}</div><h2 id=使用constinit显式要求编译时初始化>使用<code>constinit</code>显式要求编译时初始化 <a href=#%e4%bd%bf%e7%94%a8constinit%e6%98%be%e5%bc%8f%e8%a6%81%e6%b1%82%e7%bc%96%e8%af%91%e6%97%b6%e5%88%9d%e5%a7%8b%e5%8c%96 class=anchor>🔗</a></h2><p><code>constinit</code> 关键字用于显式要求全局或静态变量在编译期完成初始化。
如果变量无法在编译时初始化，编译器将报错。
<code>constinit</code> 不能用于局部变量。</p><p>与 <code>constexpr</code> 不同，<code>constinit</code> 变量可以在运行时被修改。
线程安全性：在多线程环境中，<code>constinit</code> 确保变量在编译期初始化，避免线程安全问题。</p><div class=mermaid>#include <array>// 编译时初始化
constexpr int compute(int v) { return v * v * v; }
constinit int global = compute(10);
// 错误：constinit 变量不能依赖运行时初始化
// constinit int another = global;
int main() {
global = 100; // 允许在运行时修改
// 错误：constinit 变量不是常量，不能用作数组大小
// std::array<int, global> arr;
std::cout << "Global value: " << global << std::endl;
return 0;
}</div><h2 id=总结>总结 <a href=#%e6%80%bb%e7%bb%93 class=anchor>🔗</a></h2><ul><li><code>constexpr</code>在多数情况下可以替代<code>const</code>以表达“编译期常量”的语义，可用于函数、变量、类等场景。constexpr 支持在编译期和运行期进行求值，但在某些情况下可能会退化为运行期求值。</li><li>常量表达式函数 提供了一种更清晰的编译期计算方式，能够在一定程度上取代复杂且晦涩的模板元编程。随着 C++ 标准的演进，<code>constexpr</code> 函数逐步支持了更复杂的语法和逻辑，例如条件语句、循环语句和局部变量。但对于极端复杂的计算场景，编译期计算可能导致显著的编译时间开销。</li><li><code>constexpr</code>可以在模板函数中用于类型判断，通过<code>if constexpr</code>语法有效地取代<code>std::enable_if</code>，从而简化模板编程，提高代码的可读性和可维护性。</li><li><code>constexpr</code>函数的隐式退化风险：在某些场景下，<code>constexpr</code> 函数可能在运行时执行。若需要严格保证仅在编译期求值，可以使用 <code>consteval</code> 来强制进行编译期求值，避免不必要的运行时开销。</li><li><code>constinit</code>提供了一种显式要求变量在编译时完成初始化的机制，适用于非<code>constexpr</code>变量。这在全局和静态变量的初始化中尤为有用，同时也保证了多线程环境下的初始化安全性。</li></ul></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>