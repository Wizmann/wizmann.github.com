<!doctype html><html lang=zh-CN dir=ltr><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://wizmann.top/ style=color:inherit>Maerlyn's Rainbow</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/><span itemprop=name></span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>使用新类型创建更人性化的代码</h1><time class=dim datetime=2013-12-09T15:01:00+00:00>December 9, 2013</time><div class=term-container><div class=tag><a href=https://wizmann.top/tags/cpp/>#cpp</a></div></ol></div><section class=page-section><h2 id=啥>啥？</h2><p>这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。</p><p>关键词：</p><ul><li>RAII</li><li>智能指针</li><li>接口友好</li><li>模板</li><li>模板特化</li><li>依赖编译器的缺省行为</li></ul><p>对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。</p><h2 id=一个友好的互斥锁>一个友好的互斥锁</h2><h3 id=互斥锁的定义>互斥锁的定义</h3><blockquote><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p></blockquote><h3 id=如何使用互斥锁>如何使用互斥锁</h3><p>这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyIntArray</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// 一个假想的数组类型，支持多线程下的Append Only操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    MyIntArray()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _vec.clear();
</span></span><span style=display:flex><span>        pthread_mutex_init(<span style=color:#f92672>&amp;</span>_mutex, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>int</span> v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 在这里做一些工作, 例如打Log，抽风等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vec.push_back(v);
</span></span><span style=display:flex><span>        pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    pthread_mutex_t _mutex;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _vec; 
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>代码不需要多解释，通过一个锁来保证多线程push_back函数的可重入性。</p><p>但是我们需要对代码的安全性做一些评估。</p><p>例如，我们如何处理，函数在unlock mutex之前异常结束的情况。</p><p>这并不是不可能的，例如<code>vec.push_back(v)</code>抛出了一个<code>std::bad_alloc</code>异常。或者在这之前因为一些原因，函数做出了<code>return -1</code>的行为。</p><p>也许我们在逻辑上可以接受这些错误（比如做出一些失败处理）。但是，对于因为我们没有unlock我们的同步锁，于是死锁就产生了。</p><p>这是一个极大的隐患，死锁的危害我也不用多说。</p><p>那么我们有什么方法可以避免这种局面。</p><h3 id=一个新的mutex类型>一个新的Mutex类型</h3><p>我们可以使用<strong>析构函数</strong>的特性来编写如下的类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mutex</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(<span style=color:#66d9ef>explicit</span> pthread_mutex_t<span style=color:#f92672>*</span> i_mutex_ptr)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            _mutex(i_mutex_ptr){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Mutex()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_unlock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(); <span style=color:#75715e>// disable the empty construct funtion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pthread_mutex_t <span style=color:#f92672>*</span>_mutex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>OK，如果我们使用这个类做为同步锁的管理类，那么，如果函数中出现了非预期的情况而跳出的时候。<code>Mutex</code>类就会自动调用自身的析构函数来解锁。避免了死锁的发生。</p><h3 id=总结>总结</h3><p><code>pthread_mutex_t</code>是一个类型，但是我们在这个类型之上又新建了一个新的类型来进行资源管理。以此来获得更人性化，更安全以及更可读的代码。</p><h3 id=拓展阅读>拓展阅读</h3><ul><li><a href=http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html>Pthreads mutex vs Pthreads spinlock</a></li></ul><p>对于mutex和spinlock有一个详细的介绍，并且对比了这两种锁的性能。</p><ul><li>Effective C++ 条款14</li></ul><p>以上的例子来源于此，并且做了一些简化。</p><h2 id=句柄类>句柄类</h2><p>我们都知道，由于C++没有自动内存回收机制，所以内存操作都需要代码编写者手动完成。</p><p>这就造成了潜在的内存泄露问题 ———— 不小心手贱怎么办？</p><p>于是我们就引入了句柄类，一种使用<strong>引用计数法</strong>来管理内存的方法。</p><h3 id=一个泛型句柄类>一个泛型句柄类</h3><p>代码来自《C++ Primer 第4版》，有小小的格式上的改动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* generic handle class: Provides pointerlike behavior. Although
</span></span></span><span style=display:flex><span><span style=color:#75715e>access through
</span></span></span><span style=display:flex><span><span style=color:#75715e>* an unbound Handle is checked and throws a runtime_error exception.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* The object to which the Handle points is deleted when the last
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle goes away.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Users should allocate new objects of type T and bind them to a
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Once an object is bound to a Handle,, the user must not delete
</span></span></span><span style=display:flex><span><span style=color:#75715e>that object.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handle</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// unbound handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(T <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)<span style=color:#f92672>:</span> ptr(p), use(<span style=color:#66d9ef>new</span> size_t(<span style=color:#ae81ff>1</span>)) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overloaded operators to support pointer behavior
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>();
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy control: normal pointer behavior, but last Handle deletes the object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span> h)<span style=color:#f92672>:</span> ptr(h.ptr), use(h.use) { <span style=color:#f92672>++*</span>use; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Handle<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Handle() { rem_ref(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// shared object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t <span style=color:#f92672>*</span>use;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// count of how many Handle spointto *ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rem_ref</span>()
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--*</span>use <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>delete</span> ptr; <span style=color:#66d9ef>delete</span> use; } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们从代码中可以看到，Handle类中使用了<code>size_t *use</code>用来对于对象进行引用计数。如果计数为0，则Handle类会删除自身。也许我们会忘记释放内存，但是编译器会帮你管理好你的对象的。</p><h3 id=句柄类的另一个优点>句柄类的另一个优点</h3><p>句柄类的另一个优点是可以降低文件间的编译依存关系。</p><p>句柄类可以将接口从实现中分离，从而分离编译依赖。</p><p>例如，我们有一个<code>Person</code>类，又声明了<code>PersonImpl</code>句柄类。</p><p>则我们如果修改了<code>Person</code>类的实现部分，并且保持接口部分不变。则我们只需要重新编译含入<code>Person</code>类的文件。含入<code>PersonImpl</code>类的文件不需要重新编译。</p><h3 id=shared_ptr>shared_ptr</h3><p>shared_ptr是boost中引入的新类型，原理和句柄类类似，但是加入了如下特性。</p><ul><li>线程安全</li><li>支持自定义析构操作（删除器）</li><li>有现成的库为啥不用</li></ul><p>在《Effective C++》一书中，作者对于<code>shared_ptr</code>大为推崇，用了很大篇幅来介绍它的用法，在这里就不赘述了。</p><h3 id=潜在问题>潜在问题</h3><p>有失有得，我们在一定程度上提升了内存安全性的同时，我们也必须付出一定的代价。</p><ul><li>内存性能问题</li></ul><p>我们的一个句柄类或智能指针中，不仅有我们的对象指针，而且还保存着引用计数。如果我们处于内存敏感的场景，那么我们必须认真的考虑收益和代价。</p><ul><li>计算性能问题</li></ul><p>如果我们的句柄类需要线程安全性，那么我们也必须要付出相应的时间上的代价。</p><h3 id=拓展阅读-1>拓展阅读</h3><ul><li><p>《Effective C++》第三章 资源管理</p></li><li><p>《C++ Primer第四版》 16.5 一个泛型句柄类</p></li></ul><h2 id=防止接口误用>防止接口误用</h2><p>Python有一个非常好的特性（也许别的语言也有）。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pass_date</span>(year, month, day):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>:
</span></span><span style=display:flex><span>    pass_date(year<span style=color:#f92672>=</span><span style=color:#ae81ff>1234</span>, month<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, day<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>)
</span></span></code></pre></div><p>在函数的调用中，可以明确形参与实参的对应关系。这就可以从很大程度上解决了接口误用的问题。</p><p>而在C++中，我们可以使用新建类型来解决这个问题。</p><p>还以<code>pass_date</code>这个函数为例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Year</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> year;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Month</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> month;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Day</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> day;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Date</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> pass_date(Year year, Month month, Day day) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pass
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Date date;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    date.psss_date(Year(<span style=color:#ae81ff>1234</span>), Month(<span style=color:#ae81ff>5</span>), Day(<span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=偏特化类中的成员函数>偏特化类中的成员函数</h2><p>这个方法来源于stackoverflow上的一个<a href=http://stackoverflow.com/questions/20147821/c-how-to-partial-specialization-a-template-function-in-a-template-class>问题</a>。</p><p>我比较推崇下面这个答案，虽然它不是被顶的最多的那个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group, <span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { <span style=color:#66d9ef>return</span> pow( pow(x, p) <span style=color:#f92672>+</span> pow(y, p) <span style=color:#f92672>+</span> pow(z, p), (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> p) ); }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Here specialize for 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span><span style=color:#f92672>&lt;</span>Group, <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;spec: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sqrt( x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> z ); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Vector3D</span> {
</span></span><span style=display:flex><span>    Group x, y, z;
</span></span><span style=display:flex><span>    Vector3D(Group x, Group y, Group z) <span style=color:#f92672>:</span> x(x), y(y), z(z) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> Group Norm() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span>Group Vector3D<span style=color:#f92672>&lt;</span>Group<span style=color:#f92672>&gt;::</span>Norm() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ApplyNorm<span style=color:#f92672>&lt;</span>Group, p<span style=color:#f92672>&gt;::</span>apply(x, y, z); <span style=color:#75715e>// use the helper...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// your code goes here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Vector3D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>1.</span>, <span style=color:#ae81ff>2.</span>, <span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它使用一个新类<code>ApplyNorm</code>实现了类成员函数的偏特化。</p><h3 id=拓展阅读-2>拓展阅读</h3><p>《C++ Primer第4版》 16.6 模板特化</p></section></main><footer id=main-footer><div class=footer><a href=#></a><div class=footer-copyright><div class=dim>© 2025</div><div></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2329 </span><span>8 - 10</span></div><h3></h3><nav id=TableOfContents><ul><li><a href=#啥>啥？</a></li><li><a href=#一个友好的互斥锁>一个友好的互斥锁</a><ul><li><a href=#互斥锁的定义>互斥锁的定义</a></li><li><a href=#如何使用互斥锁>如何使用互斥锁</a></li><li><a href=#一个新的mutex类型>一个新的Mutex类型</a></li><li><a href=#总结>总结</a></li><li><a href=#拓展阅读>拓展阅读</a></li></ul></li><li><a href=#句柄类>句柄类</a><ul><li><a href=#一个泛型句柄类>一个泛型句柄类</a></li><li><a href=#句柄类的另一个优点>句柄类的另一个优点</a></li><li><a href=#shared_ptr>shared_ptr</a></li><li><a href=#潜在问题>潜在问题</a></li><li><a href=#拓展阅读-1>拓展阅读</a></li></ul></li><li><a href=#防止接口误用>防止接口误用</a></li><li><a href=#偏特化类中的成员函数>偏特化类中的成员函数</a><ul><li><a href=#拓展阅读-2>拓展阅读</a></li></ul></li></ul></nav></aside></div></div></body></html>