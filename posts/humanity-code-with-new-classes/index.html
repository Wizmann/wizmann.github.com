<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>使用新类型创建更人性化的代码 | Maerlyn's Rainbow</title>
<meta name=keywords content="cpp"><meta name=description content="啥？
这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：

RAII
智能指针
接口友好
模板
模板特化
依赖编译器的缺省行为

对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/humanity-code-with-new-classes/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/humanity-code-with-new-classes/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/humanity-code-with-new-classes/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="使用新类型创建更人性化的代码"><meta property="og:description" content="啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：
RAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-12-09T15:01:00+00:00"><meta property="article:modified_time" content="2013-12-09T15:01:00+00:00"><meta property="article:tag" content="Cpp"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用新类型创建更人性化的代码"><meta name=twitter:description content="啥？
这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：

RAII
智能指针
接口友好
模板
模板特化
依赖编译器的缺省行为

对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"使用新类型创建更人性化的代码","item":"https://wizmann.top/posts/humanity-code-with-new-classes/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"使用新类型创建更人性化的代码","name":"使用新类型创建更人性化的代码","description":"啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。\n关键词：\nRAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。\n","keywords":["cpp"],"articleBody":"啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。\n关键词：\nRAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。\n一个友好的互斥锁 互斥锁的定义 互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。\n如何使用互斥锁 这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。\n#include class MyIntArray { // 一个假想的数组类型，支持多线程下的Append Only操作。 public: MyIntArray() { _vec.clear(); pthread_mutex_init(\u0026_mutex, NULL); } int push_back(int v) { pthread_mutex_lock(\u0026_mutex); // // 在这里做一些工作, 例如打Log，抽风等 // vec.push_back(v); pthread_mutex_unlock(\u0026_mutex); return 0; } private: pthread_mutex_t _mutex; vector\u003cint\u003e _vec; }; 代码不需要多解释，通过一个锁来保证多线程push_back函数的可重入性。\n但是我们需要对代码的安全性做一些评估。\n例如，我们如何处理，函数在unlock mutex之前异常结束的情况。\n这并不是不可能的，例如vec.push_back(v)抛出了一个std::bad_alloc异常。或者在这之前因为一些原因，函数做出了return -1的行为。\n也许我们在逻辑上可以接受这些错误（比如做出一些失败处理）。但是，对于因为我们没有unlock我们的同步锁，于是死锁就产生了。\n这是一个极大的隐患，死锁的危害我也不用多说。\n那么我们有什么方法可以避免这种局面。\n一个新的Mutex类型 我们可以使用析构函数的特性来编写如下的类。\n#include class Mutex { public: Mutex(explicit pthread_mutex_t* i_mutex_ptr): _mutex(i_mutex_ptr){} void lock() { pthread_mutex_lock(_mutex); } ~Mutex() { pthread_mutex_unlock(_mutex); } private: Mutex(); // disable the empty construct funtion pthread_mutex_t *_mutex; } OK，如果我们使用这个类做为同步锁的管理类，那么，如果函数中出现了非预期的情况而跳出的时候。Mutex类就会自动调用自身的析构函数来解锁。避免了死锁的发生。\n总结 pthread_mutex_t是一个类型，但是我们在这个类型之上又新建了一个新的类型来进行资源管理。以此来获得更人性化，更安全以及更可读的代码。\n拓展阅读 Pthreads mutex vs Pthreads spinlock 对于mutex和spinlock有一个详细的介绍，并且对比了这两种锁的性能。\nEffective C++ 条款14 以上的例子来源于此，并且做了一些简化。\n句柄类 我们都知道，由于C++没有自动内存回收机制，所以内存操作都需要代码编写者手动完成。\n这就造成了潜在的内存泄露问题 ———— 不小心手贱怎么办？\n于是我们就引入了句柄类，一种使用引用计数法来管理内存的方法。\n一个泛型句柄类 代码来自《C++ Primer 第4版》，有小小的格式上的改动。\n/* generic handle class: Provides pointerlike behavior. Although access through * an unbound Handle is checked and throws a runtime_error exception. * The object to which the Handle points is deleted when the last Handle goes away. * Users should allocate new objects of type T and bind them to a Handle. * Once an object is bound to a Handle,, the user must not delete that object. */ template \u003cclass T\u003e class Handle { public: // unbound handle Handle(T *p = 0): ptr(p), use(new size_t(1)) { } // overloaded operators to support pointer behavior T\u0026 operator*(); T* operator-\u003e(); const T\u0026 operator*() const; const T* operator-\u003e() const; // copy control: normal pointer behavior, but last Handle deletes the object Handle(const Handle\u0026 h): ptr(h.ptr), use(h.use) { ++*use; } Handle\u0026 operator=(const Handle\u0026); ~Handle() { rem_ref(); } private: T* ptr; // shared object size_t *use; // count of how many Handle spointto *ptr void rem_ref() { if (--*use == 0) { delete ptr; delete use; } } }; 我们从代码中可以看到，Handle类中使用了size_t *use用来对于对象进行引用计数。如果计数为0，则Handle类会删除自身。也许我们会忘记释放内存，但是编译器会帮你管理好你的对象的。\n句柄类的另一个优点 句柄类的另一个优点是可以降低文件间的编译依存关系。\n句柄类可以将接口从实现中分离，从而分离编译依赖。\n例如，我们有一个Person类，又声明了PersonImpl句柄类。\n则我们如果修改了Person类的实现部分，并且保持接口部分不变。则我们只需要重新编译含入Person类的文件。含入PersonImpl类的文件不需要重新编译。\nshared_ptr shared_ptr是boost中引入的新类型，原理和句柄类类似，但是加入了如下特性。\n线程安全 支持自定义析构操作（删除器） 有现成的库为啥不用 在《Effective C++》一书中，作者对于shared_ptr大为推崇，用了很大篇幅来介绍它的用法，在这里就不赘述了。\n潜在问题 有失有得，我们在一定程度上提升了内存安全性的同时，我们也必须付出一定的代价。\n内存性能问题 我们的一个句柄类或智能指针中，不仅有我们的对象指针，而且还保存着引用计数。如果我们处于内存敏感的场景，那么我们必须认真的考虑收益和代价。\n计算性能问题 如果我们的句柄类需要线程安全性，那么我们也必须要付出相应的时间上的代价。\n拓展阅读 《Effective C++》第三章 资源管理\n《C++ Primer第四版》 16.5 一个泛型句柄类\n防止接口误用 Python有一个非常好的特性（也许别的语言也有）。例如：\ndef pass_date(year, month, day): pass def foo: pass_date(year=1234, month=5, day=6) 在函数的调用中，可以明确形参与实参的对应关系。这就可以从很大程度上解决了接口误用的问题。\n而在C++中，我们可以使用新建类型来解决这个问题。\n还以pass_date这个函数为例。\nstruct Year { explicit int year; }; struct Month { explicit int month; }; struct Day { explicit int day; }; class Date { public: void pass_date(Year year, Month month, Day day) { // pass } }; void foo() { Date date; date.psss_date(Year(1234), Month(5), Day(6)); } 偏特化类中的成员函数 这个方法来源于stackoverflow上的一个问题。\n我比较推崇下面这个答案，虽然它不是被顶的最多的那个。\ntemplate \u003ctypename Group, int p\u003e struct ApplyNorm { static Group apply(Group x, Group y, Group z) { return pow( pow(x, p) + pow(y, p) + pow(z, p), (1.0 / p) ); } }; // Here specialize for 2 template \u003ctypename Group\u003e struct ApplyNorm\u003cGroup, 2\u003e { static Group apply(Group x, Group y, Group z) { std::cout \u003c\u003c \"spec: \" \u003c\u003c std::endl; return sqrt( x * x + y * y + z * z ); } }; template\u003ctypename Group\u003e struct Vector3D { Group x, y, z; Vector3D(Group x, Group y, Group z) : x(x), y(y), z(z) { } template\u003cint p\u003e Group Norm() const; }; template\u003ctypename Group\u003e template\u003cint p\u003e Group Vector3D\u003cGroup\u003e::Norm() const { return ApplyNorm\u003cGroup, p\u003e::apply(x, y, z); // use the helper... } int main() { // your code goes here Vector3D\u003cdouble\u003e v(1., 2., 3.); std::cout \u003c\u003c v.Norm\u003c1\u003e() \u003c\u003c std::endl; std::cout \u003c\u003c v.Norm\u003c2\u003e() \u003c\u003c std::endl; return 0; } 它使用一个新类ApplyNorm实现了类成员函数的偏特化。\n拓展阅读 《C++ Primer第4版》 16.6 模板特化\n","wordCount":"2329","inLanguage":"zh-cn","datePublished":"2013-12-09T15:01:00Z","dateModified":"2013-12-09T15:01:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/humanity-code-with-new-classes/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">使用新类型创建更人性化的代码</h1><div class=post-meta><span title='2013-12-09 15:01:00 +0000 UTC'>December 9, 2013</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=啥>啥？<a hidden class=anchor aria-hidden=true href=#啥>#</a></h2><p>这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。</p><p>关键词：</p><ul><li>RAII</li><li>智能指针</li><li>接口友好</li><li>模板</li><li>模板特化</li><li>依赖编译器的缺省行为</li></ul><p>对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。</p><h2 id=一个友好的互斥锁>一个友好的互斥锁<a hidden class=anchor aria-hidden=true href=#一个友好的互斥锁>#</a></h2><h3 id=互斥锁的定义>互斥锁的定义<a hidden class=anchor aria-hidden=true href=#互斥锁的定义>#</a></h3><blockquote><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p></blockquote><h3 id=如何使用互斥锁>如何使用互斥锁<a hidden class=anchor aria-hidden=true href=#如何使用互斥锁>#</a></h3><p>这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyIntArray</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// 一个假想的数组类型，支持多线程下的Append Only操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    MyIntArray()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _vec.clear();
</span></span><span style=display:flex><span>        pthread_mutex_init(<span style=color:#f92672>&amp;</span>_mutex, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>int</span> v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 在这里做一些工作, 例如打Log，抽风等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vec.push_back(v);
</span></span><span style=display:flex><span>        pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    pthread_mutex_t _mutex;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _vec; 
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>代码不需要多解释，通过一个锁来保证多线程push_back函数的可重入性。</p><p>但是我们需要对代码的安全性做一些评估。</p><p>例如，我们如何处理，函数在unlock mutex之前异常结束的情况。</p><p>这并不是不可能的，例如<code>vec.push_back(v)</code>抛出了一个<code>std::bad_alloc</code>异常。或者在这之前因为一些原因，函数做出了<code>return -1</code>的行为。</p><p>也许我们在逻辑上可以接受这些错误（比如做出一些失败处理）。但是，对于因为我们没有unlock我们的同步锁，于是死锁就产生了。</p><p>这是一个极大的隐患，死锁的危害我也不用多说。</p><p>那么我们有什么方法可以避免这种局面。</p><h3 id=一个新的mutex类型>一个新的Mutex类型<a hidden class=anchor aria-hidden=true href=#一个新的mutex类型>#</a></h3><p>我们可以使用<strong>析构函数</strong>的特性来编写如下的类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mutex</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(<span style=color:#66d9ef>explicit</span> pthread_mutex_t<span style=color:#f92672>*</span> i_mutex_ptr)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            _mutex(i_mutex_ptr){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Mutex()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_unlock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(); <span style=color:#75715e>// disable the empty construct funtion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pthread_mutex_t <span style=color:#f92672>*</span>_mutex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>OK，如果我们使用这个类做为同步锁的管理类，那么，如果函数中出现了非预期的情况而跳出的时候。<code>Mutex</code>类就会自动调用自身的析构函数来解锁。避免了死锁的发生。</p><h3 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h3><p><code>pthread_mutex_t</code>是一个类型，但是我们在这个类型之上又新建了一个新的类型来进行资源管理。以此来获得更人性化，更安全以及更可读的代码。</p><h3 id=拓展阅读>拓展阅读<a hidden class=anchor aria-hidden=true href=#拓展阅读>#</a></h3><ul><li><a href=http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html>Pthreads mutex vs Pthreads spinlock</a></li></ul><p>对于mutex和spinlock有一个详细的介绍，并且对比了这两种锁的性能。</p><ul><li>Effective C++ 条款14</li></ul><p>以上的例子来源于此，并且做了一些简化。</p><h2 id=句柄类>句柄类<a hidden class=anchor aria-hidden=true href=#句柄类>#</a></h2><p>我们都知道，由于C++没有自动内存回收机制，所以内存操作都需要代码编写者手动完成。</p><p>这就造成了潜在的内存泄露问题 ———— 不小心手贱怎么办？</p><p>于是我们就引入了句柄类，一种使用<strong>引用计数法</strong>来管理内存的方法。</p><h3 id=一个泛型句柄类>一个泛型句柄类<a hidden class=anchor aria-hidden=true href=#一个泛型句柄类>#</a></h3><p>代码来自《C++ Primer 第4版》，有小小的格式上的改动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* generic handle class: Provides pointerlike behavior. Although
</span></span></span><span style=display:flex><span><span style=color:#75715e>access through
</span></span></span><span style=display:flex><span><span style=color:#75715e>* an unbound Handle is checked and throws a runtime_error exception.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* The object to which the Handle points is deleted when the last
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle goes away.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Users should allocate new objects of type T and bind them to a
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Once an object is bound to a Handle,, the user must not delete
</span></span></span><span style=display:flex><span><span style=color:#75715e>that object.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handle</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// unbound handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(T <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)<span style=color:#f92672>:</span> ptr(p), use(<span style=color:#66d9ef>new</span> size_t(<span style=color:#ae81ff>1</span>)) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overloaded operators to support pointer behavior
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>();
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy control: normal pointer behavior, but last Handle deletes the object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span> h)<span style=color:#f92672>:</span> ptr(h.ptr), use(h.use) { <span style=color:#f92672>++*</span>use; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Handle<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Handle() { rem_ref(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// shared object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t <span style=color:#f92672>*</span>use;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// count of how many Handle spointto *ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rem_ref</span>()
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--*</span>use <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>delete</span> ptr; <span style=color:#66d9ef>delete</span> use; } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们从代码中可以看到，Handle类中使用了<code>size_t *use</code>用来对于对象进行引用计数。如果计数为0，则Handle类会删除自身。也许我们会忘记释放内存，但是编译器会帮你管理好你的对象的。</p><h3 id=句柄类的另一个优点>句柄类的另一个优点<a hidden class=anchor aria-hidden=true href=#句柄类的另一个优点>#</a></h3><p>句柄类的另一个优点是可以降低文件间的编译依存关系。</p><p>句柄类可以将接口从实现中分离，从而分离编译依赖。</p><p>例如，我们有一个<code>Person</code>类，又声明了<code>PersonImpl</code>句柄类。</p><p>则我们如果修改了<code>Person</code>类的实现部分，并且保持接口部分不变。则我们只需要重新编译含入<code>Person</code>类的文件。含入<code>PersonImpl</code>类的文件不需要重新编译。</p><h3 id=shared_ptr>shared_ptr<a hidden class=anchor aria-hidden=true href=#shared_ptr>#</a></h3><p>shared_ptr是boost中引入的新类型，原理和句柄类类似，但是加入了如下特性。</p><ul><li>线程安全</li><li>支持自定义析构操作（删除器）</li><li>有现成的库为啥不用</li></ul><p>在《Effective C++》一书中，作者对于<code>shared_ptr</code>大为推崇，用了很大篇幅来介绍它的用法，在这里就不赘述了。</p><h3 id=潜在问题>潜在问题<a hidden class=anchor aria-hidden=true href=#潜在问题>#</a></h3><p>有失有得，我们在一定程度上提升了内存安全性的同时，我们也必须付出一定的代价。</p><ul><li>内存性能问题</li></ul><p>我们的一个句柄类或智能指针中，不仅有我们的对象指针，而且还保存着引用计数。如果我们处于内存敏感的场景，那么我们必须认真的考虑收益和代价。</p><ul><li>计算性能问题</li></ul><p>如果我们的句柄类需要线程安全性，那么我们也必须要付出相应的时间上的代价。</p><h3 id=拓展阅读-1>拓展阅读<a hidden class=anchor aria-hidden=true href=#拓展阅读-1>#</a></h3><ul><li><p>《Effective C++》第三章 资源管理</p></li><li><p>《C++ Primer第四版》 16.5 一个泛型句柄类</p></li></ul><h2 id=防止接口误用>防止接口误用<a hidden class=anchor aria-hidden=true href=#防止接口误用>#</a></h2><p>Python有一个非常好的特性（也许别的语言也有）。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pass_date</span>(year, month, day):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>:
</span></span><span style=display:flex><span>    pass_date(year<span style=color:#f92672>=</span><span style=color:#ae81ff>1234</span>, month<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, day<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>)
</span></span></code></pre></div><p>在函数的调用中，可以明确形参与实参的对应关系。这就可以从很大程度上解决了接口误用的问题。</p><p>而在C++中，我们可以使用新建类型来解决这个问题。</p><p>还以<code>pass_date</code>这个函数为例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Year</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> year;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Month</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> month;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Day</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> day;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Date</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> pass_date(Year year, Month month, Day day) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pass
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Date date;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    date.psss_date(Year(<span style=color:#ae81ff>1234</span>), Month(<span style=color:#ae81ff>5</span>), Day(<span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=偏特化类中的成员函数>偏特化类中的成员函数<a hidden class=anchor aria-hidden=true href=#偏特化类中的成员函数>#</a></h2><p>这个方法来源于stackoverflow上的一个<a href=http://stackoverflow.com/questions/20147821/c-how-to-partial-specialization-a-template-function-in-a-template-class>问题</a>。</p><p>我比较推崇下面这个答案，虽然它不是被顶的最多的那个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group, <span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { <span style=color:#66d9ef>return</span> pow( pow(x, p) <span style=color:#f92672>+</span> pow(y, p) <span style=color:#f92672>+</span> pow(z, p), (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> p) ); }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Here specialize for 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span><span style=color:#f92672>&lt;</span>Group, <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;spec: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sqrt( x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> z ); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Vector3D</span> {
</span></span><span style=display:flex><span>    Group x, y, z;
</span></span><span style=display:flex><span>    Vector3D(Group x, Group y, Group z) <span style=color:#f92672>:</span> x(x), y(y), z(z) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> Group Norm() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span>Group Vector3D<span style=color:#f92672>&lt;</span>Group<span style=color:#f92672>&gt;::</span>Norm() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ApplyNorm<span style=color:#f92672>&lt;</span>Group, p<span style=color:#f92672>&gt;::</span>apply(x, y, z); <span style=color:#75715e>// use the helper...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// your code goes here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Vector3D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>1.</span>, <span style=color:#ae81ff>2.</span>, <span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它使用一个新类<code>ApplyNorm</code>实现了类成员函数的偏特化。</p><h3 id=拓展阅读-2>拓展阅读<a hidden class=anchor aria-hidden=true href=#拓展阅读-2>#</a></h3><p>《C++ Primer第4版》 16.6 模板特化</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/cpp/>Cpp</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/cf-218-div-2/><span class=title>«</span><br><span>Codeforces Round #218 (Div. 2)不完全不正确题解</span>
</a><a class=next href=https://wizmann.top/posts/yunfile-cracker/><span class=title>»</span><br><span>Yunfile下载破解[废弃]</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>