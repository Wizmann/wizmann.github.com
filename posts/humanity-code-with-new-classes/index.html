<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>使用新类型创建更人性化的代码</title>
<meta name=description content="啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：
RAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。
"><link rel=canonical href=https://wizmann.top/posts/humanity-code-with-new-classes/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/humanity-code-with-new-classes/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/humanity-code-with-new-classes/><meta property="og:title" content="使用新类型创建更人性化的代码"><meta property="og:description" content="啥？
这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：

RAII
智能指针
接口友好
模板
模板特化
依赖编译器的缺省行为

对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。"><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/humanity-code-with-new-classes/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-12-09T15:01:00+00:00"><meta property="article:modified_time" content="2013-12-09T15:01:00+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="使用新类型创建更人性化的代码"><meta name=twitter:description content="啥？
这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：

RAII
智能指针
接口友好
模板
模板特化
依赖编译器的缺省行为

对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"使用新类型创建更人性化的代码","datePublished":"2013-12-09T15:01:00+00:00","dateModified":"2013-12-09T15:01:00+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":2329,"description":"啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。\n关键词：\nRAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h2 id=啥>啥？</h2><p>这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。</p><p>关键词：</p><ul><li>RAII</li><li>智能指针</li><li>接口友好</li><li>模板</li><li>模板特化</li><li>依赖编译器的缺省行为</li></ul><p>对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。</p><h2 id=一个友好的互斥锁>一个友好的互斥锁</h2><h3 id=互斥锁的定义>互斥锁的定义</h3><blockquote><p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。</p></blockquote><h3 id=如何使用互斥锁>如何使用互斥锁</h3><p>这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyIntArray</span> {
</span></span><span style=display:flex><span><span style=color:#75715e>// 一个假想的数组类型，支持多线程下的Append Only操作。
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    MyIntArray()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        _vec.clear();
</span></span><span style=display:flex><span>        pthread_mutex_init(<span style=color:#f92672>&amp;</span>_mutex, NULL);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>push_back</span>(<span style=color:#66d9ef>int</span> v)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// 在这里做一些工作, 例如打Log，抽风等
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>//
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        vec.push_back(v);
</span></span><span style=display:flex><span>        pthread_mutex_unlock(<span style=color:#f92672>&amp;</span>_mutex);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    pthread_mutex_t _mutex;
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _vec; 
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>代码不需要多解释，通过一个锁来保证多线程push_back函数的可重入性。</p><p>但是我们需要对代码的安全性做一些评估。</p><p>例如，我们如何处理，函数在unlock mutex之前异常结束的情况。</p><p>这并不是不可能的，例如<code>vec.push_back(v)</code>抛出了一个<code>std::bad_alloc</code>异常。或者在这之前因为一些原因，函数做出了<code>return -1</code>的行为。</p><p>也许我们在逻辑上可以接受这些错误（比如做出一些失败处理）。但是，对于因为我们没有unlock我们的同步锁，于是死锁就产生了。</p><p>这是一个极大的隐患，死锁的危害我也不用多说。</p><p>那么我们有什么方法可以避免这种局面。</p><h3 id=一个新的mutex类型>一个新的Mutex类型</h3><p>我们可以使用<strong>析构函数</strong>的特性来编写如下的类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Mutex</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(<span style=color:#66d9ef>explicit</span> pthread_mutex_t<span style=color:#f92672>*</span> i_mutex_ptr)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            _mutex(i_mutex_ptr){}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>lock</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_lock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Mutex()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        pthread_mutex_unlock(_mutex);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    Mutex(); <span style=color:#75715e>// disable the empty construct funtion
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    pthread_mutex_t <span style=color:#f92672>*</span>_mutex;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>OK，如果我们使用这个类做为同步锁的管理类，那么，如果函数中出现了非预期的情况而跳出的时候。<code>Mutex</code>类就会自动调用自身的析构函数来解锁。避免了死锁的发生。</p><h3 id=总结>总结</h3><p><code>pthread_mutex_t</code>是一个类型，但是我们在这个类型之上又新建了一个新的类型来进行资源管理。以此来获得更人性化，更安全以及更可读的代码。</p><h3 id=拓展阅读>拓展阅读</h3><ul><li><a href=http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html target=_blank rel=noopener>Pthreads mutex vs Pthreads spinlock</a></li></ul><p>对于mutex和spinlock有一个详细的介绍，并且对比了这两种锁的性能。</p><ul><li>Effective C++ 条款14</li></ul><p>以上的例子来源于此，并且做了一些简化。</p><h2 id=句柄类>句柄类</h2><p>我们都知道，由于C++没有自动内存回收机制，所以内存操作都需要代码编写者手动完成。</p><p>这就造成了潜在的内存泄露问题 ———— 不小心手贱怎么办？</p><p>于是我们就引入了句柄类，一种使用<strong>引用计数法</strong>来管理内存的方法。</p><h3 id=一个泛型句柄类>一个泛型句柄类</h3><p>代码来自《C++ Primer 第4版》，有小小的格式上的改动。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>/* generic handle class: Provides pointerlike behavior. Although
</span></span></span><span style=display:flex><span><span style=color:#75715e>access through
</span></span></span><span style=display:flex><span><span style=color:#75715e>* an unbound Handle is checked and throws a runtime_error exception.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* The object to which the Handle points is deleted when the last
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle goes away.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Users should allocate new objects of type T and bind them to a
</span></span></span><span style=display:flex><span><span style=color:#75715e>Handle.
</span></span></span><span style=display:flex><span><span style=color:#75715e>* Once an object is bound to a Handle,, the user must not delete
</span></span></span><span style=display:flex><span><span style=color:#75715e>that object.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>T</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Handle</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// unbound handle
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(T <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>)<span style=color:#f92672>:</span> ptr(p), use(<span style=color:#66d9ef>new</span> size_t(<span style=color:#ae81ff>1</span>)) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// overloaded operators to support pointer behavior
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>();
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// copy control: normal pointer behavior, but last Handle deletes the object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Handle(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span> h)<span style=color:#f92672>:</span> ptr(h.ptr), use(h.use) { <span style=color:#f92672>++*</span>use; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Handle<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span>(<span style=color:#66d9ef>const</span> Handle<span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>Handle() { rem_ref(); }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> ptr;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// shared object
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t <span style=color:#f92672>*</span>use;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// count of how many Handle spointto *ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>rem_ref</span>()
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--*</span>use <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>delete</span> ptr; <span style=color:#66d9ef>delete</span> use; } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们从代码中可以看到，Handle类中使用了<code>size_t *use</code>用来对于对象进行引用计数。如果计数为0，则Handle类会删除自身。也许我们会忘记释放内存，但是编译器会帮你管理好你的对象的。</p><h3 id=句柄类的另一个优点>句柄类的另一个优点</h3><p>句柄类的另一个优点是可以降低文件间的编译依存关系。</p><p>句柄类可以将接口从实现中分离，从而分离编译依赖。</p><p>例如，我们有一个<code>Person</code>类，又声明了<code>PersonImpl</code>句柄类。</p><p>则我们如果修改了<code>Person</code>类的实现部分，并且保持接口部分不变。则我们只需要重新编译含入<code>Person</code>类的文件。含入<code>PersonImpl</code>类的文件不需要重新编译。</p><h3 id=shared_ptr>shared_ptr</h3><p>shared_ptr是boost中引入的新类型，原理和句柄类类似，但是加入了如下特性。</p><ul><li>线程安全</li><li>支持自定义析构操作（删除器）</li><li>有现成的库为啥不用</li></ul><p>在《Effective C++》一书中，作者对于<code>shared_ptr</code>大为推崇，用了很大篇幅来介绍它的用法，在这里就不赘述了。</p><h3 id=潜在问题>潜在问题</h3><p>有失有得，我们在一定程度上提升了内存安全性的同时，我们也必须付出一定的代价。</p><ul><li>内存性能问题</li></ul><p>我们的一个句柄类或智能指针中，不仅有我们的对象指针，而且还保存着引用计数。如果我们处于内存敏感的场景，那么我们必须认真的考虑收益和代价。</p><ul><li>计算性能问题</li></ul><p>如果我们的句柄类需要线程安全性，那么我们也必须要付出相应的时间上的代价。</p><h3 id=拓展阅读-1>拓展阅读</h3><ul><li><p>《Effective C++》第三章 资源管理</p></li><li><p>《C++ Primer第四版》 16.5 一个泛型句柄类</p></li></ul><h2 id=防止接口误用>防止接口误用</h2><p>Python有一个非常好的特性（也许别的语言也有）。例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pass_date</span>(year, month, day):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>foo</span>:
</span></span><span style=display:flex><span>    pass_date(year<span style=color:#f92672>=</span><span style=color:#ae81ff>1234</span>, month<span style=color:#f92672>=</span><span style=color:#ae81ff>5</span>, day<span style=color:#f92672>=</span><span style=color:#ae81ff>6</span>)
</span></span></code></pre></div><p>在函数的调用中，可以明确形参与实参的对应关系。这就可以从很大程度上解决了接口误用的问题。</p><p>而在C++中，我们可以使用新建类型来解决这个问题。</p><p>还以<code>pass_date</code>这个函数为例。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Year</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> year;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Month</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> month;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Day</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> <span style=color:#66d9ef>int</span> day;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Date</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> pass_date(Year year, Month month, Day day) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pass
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>foo</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Date date;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    date.psss_date(Year(<span style=color:#ae81ff>1234</span>), Month(<span style=color:#ae81ff>5</span>), Day(<span style=color:#ae81ff>6</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=偏特化类中的成员函数>偏特化类中的成员函数</h2><p>这个方法来源于stackoverflow上的一个<a href=http://stackoverflow.com/questions/20147821/c-how-to-partial-specialization-a-template-function-in-a-template-class target=_blank rel=noopener>问题</a>。</p><p>我比较推崇下面这个答案，虽然它不是被顶的最多的那个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group, <span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { <span style=color:#66d9ef>return</span> pow( pow(x, p) <span style=color:#f92672>+</span> pow(y, p) <span style=color:#f92672>+</span> pow(z, p), (<span style=color:#ae81ff>1.0</span> <span style=color:#f92672>/</span> p) ); }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Here specialize for 2
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ApplyNorm</span><span style=color:#f92672>&lt;</span>Group, <span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> Group <span style=color:#a6e22e>apply</span>(Group x, Group y, Group z)
</span></span><span style=display:flex><span>    { 
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;spec: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sqrt( x <span style=color:#f92672>*</span> x <span style=color:#f92672>+</span> y <span style=color:#f92672>*</span> y <span style=color:#f92672>+</span> z <span style=color:#f92672>*</span> z ); 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Vector3D</span> {
</span></span><span style=display:flex><span>    Group x, y, z;
</span></span><span style=display:flex><span>    Vector3D(Group x, Group y, Group z) <span style=color:#f92672>:</span> x(x), y(y), z(z) {
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> Group Norm() <span style=color:#66d9ef>const</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> Group<span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span> p<span style=color:#f92672>&gt;</span> 
</span></span><span style=display:flex><span>Group Vector3D<span style=color:#f92672>&lt;</span>Group<span style=color:#f92672>&gt;::</span>Norm() <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ApplyNorm<span style=color:#f92672>&lt;</span>Group, p<span style=color:#f92672>&gt;::</span>apply(x, y, z); <span style=color:#75715e>// use the helper...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// your code goes here
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    Vector3D<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>double</span><span style=color:#f92672>&gt;</span> v(<span style=color:#ae81ff>1.</span>, <span style=color:#ae81ff>2.</span>, <span style=color:#ae81ff>3.</span>);
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> v.Norm<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>2</span><span style=color:#f92672>&gt;</span>() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>它使用一个新类<code>ApplyNorm</code>实现了类成员函数的偏特化。</p><h3 id=拓展阅读-2>拓展阅读</h3><p>《C++ Primer第4版》 16.6 模板特化</p></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>