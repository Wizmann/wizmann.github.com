<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>阻塞TCP流 - phxrpc代码阅读(3) | Maerlyn's Rainbow</title>
<meta name=keywords content="phxrpc,tcpip,poll,socket"><meta name=description content="写在前面
phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/phxrpc-3/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/phxrpc-3/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/phxrpc-3/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="阻塞TCP流 - phxrpc代码阅读(3)"><meta property="og:description" content="写在前面 phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-03T22:22:14+00:00"><meta property="article:modified_time" content="2016-10-03T22:22:14+00:00"><meta property="article:tag" content="Phxrpc"><meta property="article:tag" content="Tcpip"><meta property="article:tag" content="Poll"><meta property="article:tag" content="Socket"><meta name=twitter:card content="summary"><meta name=twitter:title content="阻塞TCP流 - phxrpc代码阅读(3)"><meta name=twitter:description content="写在前面
phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"阻塞TCP流 - phxrpc代码阅读(3)","item":"https://wizmann.top/posts/phxrpc-3/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"阻塞TCP流 - phxrpc代码阅读(3)","name":"阻塞TCP流 - phxrpc代码阅读(3)","description":"写在前面 phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）\n","keywords":["phxrpc","tcpip","poll","socket"],"articleBody":"写在前面 phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）\nBlockTcpStreamBuf class BlockTcpStreamBuf继承自BaseTcpStreamBuf。其中重写了precv和psend两个函数，并且持有了一个文件描述符(file descriptor)：socket_。\nprecv和psend直接调用了中的recv(2)和send(2)，并没有其它操作。\n网络相关的操作，则由class BlockTcpStream来负责。BlockTcpStreamBuf只负责IO部分。\nif (BaseTcpUtils::SetNonBlock(sockfd, false) \u0026\u0026 BaseTcpUtils::SetNoDelay(sockfd, true)) { stream-\u003eAttach(sockfd); } else { phxrpc::log(LOG_ERR, \"set nonblock fail\"); error = -1; close(sockfd); } 在BlockTcpStream把fd传递给BlockTcpStreambuf之前，需要把fd设置为block的。而这段代码最大的槽点就是这个SetNonBlock函数，和下面的set nonblock fail日志（想一想）。完全让人摸不到头脑，达到一脸懵逼的最高境界。\n由于recv和send函数是block的，所以在读取、写入缓冲区时，如果没有足够的数据可读或没有足够的空间可写，则读取写入操作会阻塞住。\nBlockTcpStream 在这里我又想吐个槽了，为啥在这里把TCP Server和Client的工作流混为一谈。我觉得至少应该从命名上区分一下，否则极容易误用。\nTCP的工作流程 图片来源：UNIX网络编程卷一：套接字编程 4.2节\n从图中我们可以看到，TCP的服务端与客户端的工作流程是不同的，相对来说，客户端的程序要简单一些。\nBlockTcpStream中，客户端应用的函数只有BlockTcpUtils::Open，而服务端的BlockTCPUtils::Listen函数包括了bind()和listen()两个操作，而accept()则需要开发者手动调用。\nSO_REUSEADDR 在服务端的Listen()函数中，phxrpc使用了SO_REUSEADDR选项，这个选项的意在通知内核：如果端口忙，但是TCP状态位于TIME_WAIT时，可以重用端口。\n一个套接字其实是一个（协议，源地址，源端口，目标地址，目标端口）五元组。SO_REUSEADDR意味着我们可以重用源地址和源端口。当然此时的风险在于如果该原套接字发送了一些错误的数据，此时我们的应用程序的TCP工作流就会产生错乱。但是由于TCP的实现中，通过随机的消息序号规避了这个问题，所以这里的风险可以忽略不计。\n使用SO_REUSEADDR的好处是，在服务端程序崩溃和退出时（对于一般的服务端程序来说，崩溃和退出是没有区别的），可以立即重启，而不需要等待2MSL时间。\n那么我们要问了，为什么在这里我们需要等待2MSL时间呢。\n图片来源：Effective TCP/IP 3.8节\nTCP拆除连接使用了四次握手的机制，而主动关闭连接的一方在发送完最后一个ACK之后，需要等待2MSL的时间。这就是上面所说的，当服务器重启后，出现Address already in use的报错信息，需要额外等待大约1~4分钟的原因。\n究其原因，TIME-WAIT状态的意图在于避免主动关闭连接的一端最后一个ACK发送失败。此时，主机1已经完全关闭，而主机2因为没有收到FIN包的ACK，处于半关闭状态。此时主机2向主机1发送的任何信息（如延迟的ACK包等）都只会收到RST，导致连接的异常关闭。\n为了规避这个问题，主动关闭端需要等待2MSL时间。一个MSL是给最后的ACK包，而另外一个MSL，是为了等待被动关闭端重新发送FIN包。如果在TIME_WAIT期间收到了对端的数据包，会刷新TIME_WAIT状态的时间。\n参考：Effective TCP/IP 3.8 3.9节\nIO复用：Poll 图片来源：UNIX网络编程卷一：套接字编程 6.2节\nIO复用是指内核在发现进程指定的一个或多个IO条件就绪，内核就通知进程。通常来讲，常用的IO复用函数有select()和poll()。\n当poll()返回后，我们需要遍历其中的fd数组找到可操作的fd。\nstruct pollfd { int fd; /* file descriptor */ short events; /* requested events */ short revents; /* returned events */ }; 我们可以从events和revents获得该fd的状态，从而判别可读、可写、超时或出错。\n在这里，我们并没有使用poll函数的IO复用能力，而是把它做为另一个阻塞IO调用来使用。\nBlockTcpUtils::Open函数中，我们使用了poll，用来监视相应的（一个）fd是否可读。这样一来，我们就隐式（为什么说隐式呢，因为他们一不写文档，二不写注释，一切都是潜规则）规定了C/S交互的基本工作流程：当C/S连接建立后，Server端要先说话，Client端接收到消息之后，才可以进行下面的流程。\nClient：“不管你们信不信，是Server先动的手。”\n具体为什么先用poll，再把fd设为blocking的，我表示二脸懵逼。在我的实验中，即使把poll删掉，测试代码也是可以work的。可能在后面的代码阅读中，这个问题可以获得解释吧。\n和select一样，poll也存在被中断的情况，在phxrpc的代码里，我们给了中断“a second chance”。当poll被中断后，会重新再poll一次；如果这次再被中断，则直接返回TIMEOUT。\n// retry again for EINTR for (int i = 0; i \u003c 2; i++) { ret = ::poll(\u0026pfd, 1, timeout_ms); if (-1 == ret \u0026\u0026 EINTR == errno) continue; break; } if (0 == ret) errno = ETIMEDOUT; 写在最后 由于这篇文章中的知识点比较杂，写作的顺序也是随机的。所以连贯性不是那么强。如果有什么问题，忍着点吧您就。\n忍不了的话。。。那就留言交流吧~\n","wordCount":"2274","inLanguage":"zh-cn","datePublished":"2016-10-03T22:22:14Z","dateModified":"2016-10-03T22:22:14Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/phxrpc-3/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">阻塞TCP流 - phxrpc代码阅读(3)</h1><div class=post-meta><span title='2016-10-03 22:22:14 +0000 UTC'>October 3, 2016</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=写在前面>写在前面<a hidden class=anchor aria-hidden=true href=#写在前面>#</a></h2><p>phxrpc的流（<code>stream</code>和<code>streambuf</code>）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）</p><h2 id=blocktcpstreambuf>BlockTcpStreamBuf<a hidden class=anchor aria-hidden=true href=#blocktcpstreambuf>#</a></h2><p><code>class BlockTcpStreamBuf</code>继承自<code>BaseTcpStreamBuf</code>。其中重写了<code>precv</code>和<code>psend</code>两个函数，并且持有了一个文件描述符(file descriptor)：<code>socket_</code>。</p><p><code>precv</code>和<code>psend</code>直接调用了<code>&lt;sys/socket.h></code>中的<code>recv(2)</code>和<code>send(2)</code>，并没有其它操作。</p><p>网络相关的操作，则由<code>class BlockTcpStream</code>来负责。<code>BlockTcpStreamBuf</code>只负责IO部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (BaseTcpUtils<span style=color:#f92672>::</span>SetNonBlock(sockfd, false)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> BaseTcpUtils<span style=color:#f92672>::</span>SetNoDelay(sockfd, true)) {
</span></span><span style=display:flex><span>    stream<span style=color:#f92672>-&gt;</span>Attach(sockfd);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    phxrpc<span style=color:#f92672>::</span>log(LOG_ERR, <span style=color:#e6db74>&#34;set nonblock fail&#34;</span>);
</span></span><span style=display:flex><span>    error <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>BlockTcpStream</code>把fd传递给<code>BlockTcpStreambuf</code>之前，需要把fd设置为<code>block</code>的。而这段代码最大的槽点就是这个<code>SetNonBlock</code>函数，和下面的<code>set nonblock fail</code>日志（想一想）。完全让人摸不到头脑，达到一脸懵逼的最高境界。</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/87163832.jpg></p><p>由于<code>recv</code>和<code>send</code>函数是<code>block</code>的，所以在读取、写入缓冲区时，如果没有足够的数据可读或没有足够的空间可写，则读取写入操作会阻塞住。</p><h2 id=blocktcpstream>BlockTcpStream<a hidden class=anchor aria-hidden=true href=#blocktcpstream>#</a></h2><p>在这里我又想吐个槽了，为啥在这里把TCP Server和Client的工作流混为一谈。我觉得至少应该从命名上区分一下，否则极容易误用。</p><h3 id=tcp的工作流程>TCP的工作流程<a hidden class=anchor aria-hidden=true href=#tcp的工作流程>#</a></h3><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/92621506.jpg></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 4.2节</p></blockquote><p>从图中我们可以看到，TCP的服务端与客户端的工作流程是不同的，相对来说，客户端的程序要简单一些。</p><p><code>BlockTcpStream</code>中，客户端应用的函数只有<code>BlockTcpUtils::Open</code>，而服务端的<code>BlockTCPUtils::Listen</code>函数包括了<code>bind()</code>和<code>listen()</code>两个操作，而<code>accept()</code>则需要开发者手动调用。</p><h3 id=so_reuseaddr>SO_REUSEADDR<a hidden class=anchor aria-hidden=true href=#so_reuseaddr>#</a></h3><p>在服务端的<code>Listen()</code>函数中，phxrpc使用了<code>SO_REUSEADDR</code>选项，这个选项的意在通知内核：如果端口忙，但是TCP状态位于<code>TIME_WAIT</code>时，可以重用端口。</p><p>一个套接字其实是一个<code>（协议，源地址，源端口，目标地址，目标端口）</code>五元组。<code>SO_REUSEADDR</code>意味着我们可以重用源地址和源端口。当然此时的风险在于如果该原套接字发送了一些错误的数据，此时我们的应用程序的TCP工作流就会产生错乱。但是由于TCP的实现中，通过随机的消息序号规避了这个问题，所以这里的风险可以忽略不计。</p><p>使用<code>SO_REUSEADDR</code>的好处是，在服务端程序崩溃和退出时（对于一般的服务端程序来说，崩溃和退出是没有区别的），可以立即重启，而不需要等待2MSL时间。</p><p>那么我们要问了，为什么在这里我们需要等待2MSL时间呢。</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/33186679.jpg></p><blockquote><p>图片来源：Effective TCP/IP 3.8节</p></blockquote><p>TCP拆除连接使用了四次握手的机制，而主动关闭连接的一方在发送完最后一个ACK之后，需要等待2MSL的时间。这就是上面所说的，当服务器重启后，出现<code>Address already in use</code>的报错信息，需要额外等待大约1~4分钟的原因。</p><p>究其原因，TIME-WAIT状态的意图在于避免主动关闭连接的一端最后一个ACK发送失败。此时，主机1已经完全关闭，而主机2因为没有收到FIN包的ACK，处于半关闭状态。此时主机2向主机1发送的任何信息（如延迟的ACK包等）都只会收到RST，导致连接的异常关闭。</p><p>为了规避这个问题，主动关闭端需要等待2MSL时间。一个MSL是给最后的ACK包，而另外一个MSL，是为了等待被动关闭端重新发送FIN包。如果在TIME_WAIT期间收到了对端的数据包，会刷新TIME_WAIT状态的时间。</p><blockquote><p>参考：Effective TCP/IP 3.8 3.9节</p></blockquote><h3 id=io复用poll>IO复用：Poll<a hidden class=anchor aria-hidden=true href=#io复用poll>#</a></h3><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/84501111.jpg></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 6.2节</p></blockquote><p>IO复用是指内核在发现进程指定的一个或多个IO条件就绪，内核就通知进程。通常来讲，常用的IO复用函数有<code>select()</code>和<code>poll()</code>。</p><p>当<code>poll()</code>返回后，我们需要遍历其中的fd数组找到可操作的fd。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们可以从<code>events</code>和<code>revents</code>获得该fd的状态，从而判别可读、可写、超时或出错。</p><p>在这里，我们并没有使用poll函数的IO复用能力，而是把它做为另一个阻塞IO调用来使用。</p><p><code>BlockTcpUtils::Open</code>函数中，我们使用了poll，用来监视相应的（一个）fd是否可读。这样一来，我们就隐式（为什么说隐式呢，因为他们一不写文档，二不写注释，一切都是潜规则）规定了C/S交互的基本工作流程：当C/S连接建立后，Server端要先说话，Client端接收到消息之后，才可以进行下面的流程。</p><blockquote><p>Client：“不管你们信不信，是Server先动的手。”</p></blockquote><p>具体为什么先用poll，再把fd设为<code>blocking</code>的，我表示二脸懵逼。在我的实验中，即使把poll删掉，测试代码也是可以work的。可能在后面的代码阅读中，这个问题可以获得解释吧。</p><p>和select一样，poll也存在被中断的情况，在phxrpc的代码里，我们给了中断“a second chance”。当poll被中断后，会重新再poll一次；如果这次再被中断，则直接返回TIMEOUT。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// retry again for EINTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> <span style=color:#f92672>::</span>poll(<span style=color:#f92672>&amp;</span>pfd, <span style=color:#ae81ff>1</span>, timeout_ms);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> ret <span style=color:#f92672>&amp;&amp;</span> EINTR <span style=color:#f92672>==</span> errno)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>==</span> ret)
</span></span><span style=display:flex><span>    errno <span style=color:#f92672>=</span> ETIMEDOUT;
</span></span></code></pre></div><h2 id=写在最后>写在最后<a hidden class=anchor aria-hidden=true href=#写在最后>#</a></h2><p>由于这篇文章中的知识点比较杂，写作的顺序也是随机的。所以连贯性不是那么强。如果有什么问题，忍着点吧您就。</p><p>忍不了的话。。。那就留言交流吧~</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/42112021.jpg></p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/phxrpc/>Phxrpc</a></li><li><a href=https://wizmann.top/tags/tcpip/>Tcpip</a></li><li><a href=https://wizmann.top/tags/poll/>Poll</a></li><li><a href=https://wizmann.top/tags/socket/>Socket</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/ergodone/><span class=title>«</span><br><span>打造你的专属键盘 — ErgoDone</span>
</a><a class=next href=https://wizmann.top/posts/phxrpc-2/><span class=title>»</span><br><span>定时器以及其它 - phxrpc阅读笔记(2)</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>