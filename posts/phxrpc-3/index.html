<!doctype html><html lang=zh-CN dir=ltr><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://wizmann.top/ style=color:inherit>Maerlyn's Rainbow</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/><span itemprop=name></span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>阻塞TCP流 - phxrpc代码阅读(3)</h1><time class=dim datetime=2016-10-03T22:22:14+00:00>October 3, 2016</time><div class=term-container><div class=tag><a href=https://wizmann.top/tags/phxrpc/>#phxrpc</a></div><div class=tag><a href=https://wizmann.top/tags/tcpip/>#tcpip</a></div><div class=tag><a href=https://wizmann.top/tags/poll/>#poll</a></div><div class=tag><a href=https://wizmann.top/tags/socket/>#socket</a></div></ol></div><section class=page-section><h2 id=写在前面>写在前面</h2><p>phxrpc的流（<code>stream</code>和<code>streambuf</code>）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）</p><h2 id=blocktcpstreambuf>BlockTcpStreamBuf</h2><p><code>class BlockTcpStreamBuf</code>继承自<code>BaseTcpStreamBuf</code>。其中重写了<code>precv</code>和<code>psend</code>两个函数，并且持有了一个文件描述符(file descriptor)：<code>socket_</code>。</p><p><code>precv</code>和<code>psend</code>直接调用了<code>&lt;sys/socket.h></code>中的<code>recv(2)</code>和<code>send(2)</code>，并没有其它操作。</p><p>网络相关的操作，则由<code>class BlockTcpStream</code>来负责。<code>BlockTcpStreamBuf</code>只负责IO部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (BaseTcpUtils<span style=color:#f92672>::</span>SetNonBlock(sockfd, false)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> BaseTcpUtils<span style=color:#f92672>::</span>SetNoDelay(sockfd, true)) {
</span></span><span style=display:flex><span>    stream<span style=color:#f92672>-&gt;</span>Attach(sockfd);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    phxrpc<span style=color:#f92672>::</span>log(LOG_ERR, <span style=color:#e6db74>&#34;set nonblock fail&#34;</span>);
</span></span><span style=display:flex><span>    error <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>BlockTcpStream</code>把fd传递给<code>BlockTcpStreambuf</code>之前，需要把fd设置为<code>block</code>的。而这段代码最大的槽点就是这个<code>SetNonBlock</code>函数，和下面的<code>set nonblock fail</code>日志（想一想）。完全让人摸不到头脑，达到一脸懵逼的最高境界。</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/87163832.jpg alt></p><p>由于<code>recv</code>和<code>send</code>函数是<code>block</code>的，所以在读取、写入缓冲区时，如果没有足够的数据可读或没有足够的空间可写，则读取写入操作会阻塞住。</p><h2 id=blocktcpstream>BlockTcpStream</h2><p>在这里我又想吐个槽了，为啥在这里把TCP Server和Client的工作流混为一谈。我觉得至少应该从命名上区分一下，否则极容易误用。</p><h3 id=tcp的工作流程>TCP的工作流程</h3><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/92621506.jpg alt></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 4.2节</p></blockquote><p>从图中我们可以看到，TCP的服务端与客户端的工作流程是不同的，相对来说，客户端的程序要简单一些。</p><p><code>BlockTcpStream</code>中，客户端应用的函数只有<code>BlockTcpUtils::Open</code>，而服务端的<code>BlockTCPUtils::Listen</code>函数包括了<code>bind()</code>和<code>listen()</code>两个操作，而<code>accept()</code>则需要开发者手动调用。</p><h3 id=so_reuseaddr>SO_REUSEADDR</h3><p>在服务端的<code>Listen()</code>函数中，phxrpc使用了<code>SO_REUSEADDR</code>选项，这个选项的意在通知内核：如果端口忙，但是TCP状态位于<code>TIME_WAIT</code>时，可以重用端口。</p><p>一个套接字其实是一个<code>（协议，源地址，源端口，目标地址，目标端口）</code>五元组。<code>SO_REUSEADDR</code>意味着我们可以重用源地址和源端口。当然此时的风险在于如果该原套接字发送了一些错误的数据，此时我们的应用程序的TCP工作流就会产生错乱。但是由于TCP的实现中，通过随机的消息序号规避了这个问题，所以这里的风险可以忽略不计。</p><p>使用<code>SO_REUSEADDR</code>的好处是，在服务端程序崩溃和退出时（对于一般的服务端程序来说，崩溃和退出是没有区别的），可以立即重启，而不需要等待2MSL时间。</p><p>那么我们要问了，为什么在这里我们需要等待2MSL时间呢。</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/33186679.jpg alt></p><blockquote><p>图片来源：Effective TCP/IP 3.8节</p></blockquote><p>TCP拆除连接使用了四次握手的机制，而主动关闭连接的一方在发送完最后一个ACK之后，需要等待2MSL的时间。这就是上面所说的，当服务器重启后，出现<code>Address already in use</code>的报错信息，需要额外等待大约1~4分钟的原因。</p><p>究其原因，TIME-WAIT状态的意图在于避免主动关闭连接的一端最后一个ACK发送失败。此时，主机1已经完全关闭，而主机2因为没有收到FIN包的ACK，处于半关闭状态。此时主机2向主机1发送的任何信息（如延迟的ACK包等）都只会收到RST，导致连接的异常关闭。</p><p>为了规避这个问题，主动关闭端需要等待2MSL时间。一个MSL是给最后的ACK包，而另外一个MSL，是为了等待被动关闭端重新发送FIN包。如果在TIME_WAIT期间收到了对端的数据包，会刷新TIME_WAIT状态的时间。</p><blockquote><p>参考：Effective TCP/IP 3.8 3.9节</p></blockquote><h3 id=io复用poll>IO复用：Poll</h3><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/84501111.jpg alt></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 6.2节</p></blockquote><p>IO复用是指内核在发现进程指定的一个或多个IO条件就绪，内核就通知进程。通常来讲，常用的IO复用函数有<code>select()</code>和<code>poll()</code>。</p><p>当<code>poll()</code>返回后，我们需要遍历其中的fd数组找到可操作的fd。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们可以从<code>events</code>和<code>revents</code>获得该fd的状态，从而判别可读、可写、超时或出错。</p><p>在这里，我们并没有使用poll函数的IO复用能力，而是把它做为另一个阻塞IO调用来使用。</p><p><code>BlockTcpUtils::Open</code>函数中，我们使用了poll，用来监视相应的（一个）fd是否可读。这样一来，我们就隐式（为什么说隐式呢，因为他们一不写文档，二不写注释，一切都是潜规则）规定了C/S交互的基本工作流程：当C/S连接建立后，Server端要先说话，Client端接收到消息之后，才可以进行下面的流程。</p><blockquote><p>Client：“不管你们信不信，是Server先动的手。”</p></blockquote><p>具体为什么先用poll，再把fd设为<code>blocking</code>的，我表示二脸懵逼。在我的实验中，即使把poll删掉，测试代码也是可以work的。可能在后面的代码阅读中，这个问题可以获得解释吧。</p><p>和select一样，poll也存在被中断的情况，在phxrpc的代码里，我们给了中断“a second chance”。当poll被中断后，会重新再poll一次；如果这次再被中断，则直接返回TIMEOUT。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// retry again for EINTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> <span style=color:#f92672>::</span>poll(<span style=color:#f92672>&amp;</span>pfd, <span style=color:#ae81ff>1</span>, timeout_ms);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> ret <span style=color:#f92672>&amp;&amp;</span> EINTR <span style=color:#f92672>==</span> errno)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>==</span> ret)
</span></span><span style=display:flex><span>    errno <span style=color:#f92672>=</span> ETIMEDOUT;
</span></span></code></pre></div><h2 id=写在最后>写在最后</h2><p>由于这篇文章中的知识点比较杂，写作的顺序也是随机的。所以连贯性不是那么强。如果有什么问题，忍着点吧您就。</p><p>忍不了的话。。。那就留言交流吧~</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/42112021.jpg alt></p></section></main><footer id=main-footer><div class=footer><a href=#></a><div class=footer-copyright><div class=dim>© 2025</div><div></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2274 </span><span>5 - 7</span></div><h3></h3><nav id=TableOfContents><ul><li><a href=#写在前面>写在前面</a></li><li><a href=#blocktcpstreambuf>BlockTcpStreamBuf</a></li><li><a href=#blocktcpstream>BlockTcpStream</a><ul><li><a href=#tcp的工作流程>TCP的工作流程</a></li><li><a href=#so_reuseaddr>SO_REUSEADDR</a></li><li><a href=#io复用poll>IO复用：Poll</a></li></ul></li><li><a href=#写在最后>写在最后</a></li></ul></nav><h3></h3><ul><li><a href=/posts/phxrpc-2/>定时器以及其它 - phxrpc阅读笔记(2)</a></li><li><a href=/posts/phxrpc-1/>自定义你的stream buffer - phxrpc阅读笔记(1)</a></li></ul></aside></div></div></body></html>