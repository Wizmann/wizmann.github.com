<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>阻塞TCP流 - phxrpc代码阅读(3)</title>
<meta name=description content="写在前面 phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）
"><link rel=canonical href=https://wizmann.top/posts/phxrpc-3/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/phxrpc-3/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/phxrpc-3/><meta property="og:title" content="阻塞TCP流 - phxrpc代码阅读(3)"><meta property="og:description" content="写在前面
phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）"><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/phxrpc-3/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-10-03T22:22:14+00:00"><meta property="article:modified_time" content="2016-10-03T22:22:14+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="阻塞TCP流 - phxrpc代码阅读(3)"><meta name=twitter:description content="写在前面
phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"阻塞TCP流 - phxrpc代码阅读(3)","datePublished":"2016-10-03T22:22:14+00:00","dateModified":"2016-10-03T22:22:14+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":2274,"description":"写在前面 phxrpc的流（stream和streambuf）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h2 id=写在前面>写在前面</h2><p>phxrpc的流（<code>stream</code>和<code>streambuf</code>）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）</p><h2 id=blocktcpstreambuf>BlockTcpStreamBuf</h2><p><code>class BlockTcpStreamBuf</code>继承自<code>BaseTcpStreamBuf</code>。其中重写了<code>precv</code>和<code>psend</code>两个函数，并且持有了一个文件描述符(file descriptor)：<code>socket_</code>。</p><p><code>precv</code>和<code>psend</code>直接调用了<code>&lt;sys/socket.h></code>中的<code>recv(2)</code>和<code>send(2)</code>，并没有其它操作。</p><p>网络相关的操作，则由<code>class BlockTcpStream</code>来负责。<code>BlockTcpStreamBuf</code>只负责IO部分。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>if</span> (BaseTcpUtils<span style=color:#f92672>::</span>SetNonBlock(sockfd, false)
</span></span><span style=display:flex><span>        <span style=color:#f92672>&amp;&amp;</span> BaseTcpUtils<span style=color:#f92672>::</span>SetNoDelay(sockfd, true)) {
</span></span><span style=display:flex><span>    stream<span style=color:#f92672>-&gt;</span>Attach(sockfd);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    phxrpc<span style=color:#f92672>::</span>log(LOG_ERR, <span style=color:#e6db74>&#34;set nonblock fail&#34;</span>);
</span></span><span style=display:flex><span>    error <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    close(sockfd);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>BlockTcpStream</code>把fd传递给<code>BlockTcpStreambuf</code>之前，需要把fd设置为<code>block</code>的。而这段代码最大的槽点就是这个<code>SetNonBlock</code>函数，和下面的<code>set nonblock fail</code>日志（想一想）。完全让人摸不到头脑，达到一脸懵逼的最高境界。</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/87163832.jpg alt></p><p>由于<code>recv</code>和<code>send</code>函数是<code>block</code>的，所以在读取、写入缓冲区时，如果没有足够的数据可读或没有足够的空间可写，则读取写入操作会阻塞住。</p><h2 id=blocktcpstream>BlockTcpStream</h2><p>在这里我又想吐个槽了，为啥在这里把TCP Server和Client的工作流混为一谈。我觉得至少应该从命名上区分一下，否则极容易误用。</p><h3 id=tcp的工作流程>TCP的工作流程</h3><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/92621506.jpg alt></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 4.2节</p></blockquote><p>从图中我们可以看到，TCP的服务端与客户端的工作流程是不同的，相对来说，客户端的程序要简单一些。</p><p><code>BlockTcpStream</code>中，客户端应用的函数只有<code>BlockTcpUtils::Open</code>，而服务端的<code>BlockTCPUtils::Listen</code>函数包括了<code>bind()</code>和<code>listen()</code>两个操作，而<code>accept()</code>则需要开发者手动调用。</p><h3 id=so_reuseaddr>SO_REUSEADDR</h3><p>在服务端的<code>Listen()</code>函数中，phxrpc使用了<code>SO_REUSEADDR</code>选项，这个选项的意在通知内核：如果端口忙，但是TCP状态位于<code>TIME_WAIT</code>时，可以重用端口。</p><p>一个套接字其实是一个<code>（协议，源地址，源端口，目标地址，目标端口）</code>五元组。<code>SO_REUSEADDR</code>意味着我们可以重用源地址和源端口。当然此时的风险在于如果该原套接字发送了一些错误的数据，此时我们的应用程序的TCP工作流就会产生错乱。但是由于TCP的实现中，通过随机的消息序号规避了这个问题，所以这里的风险可以忽略不计。</p><p>使用<code>SO_REUSEADDR</code>的好处是，在服务端程序崩溃和退出时（对于一般的服务端程序来说，崩溃和退出是没有区别的），可以立即重启，而不需要等待2MSL时间。</p><p>那么我们要问了，为什么在这里我们需要等待2MSL时间呢。</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/33186679.jpg alt></p><blockquote><p>图片来源：Effective TCP/IP 3.8节</p></blockquote><p>TCP拆除连接使用了四次握手的机制，而主动关闭连接的一方在发送完最后一个ACK之后，需要等待2MSL的时间。这就是上面所说的，当服务器重启后，出现<code>Address already in use</code>的报错信息，需要额外等待大约1~4分钟的原因。</p><p>究其原因，TIME-WAIT状态的意图在于避免主动关闭连接的一端最后一个ACK发送失败。此时，主机1已经完全关闭，而主机2因为没有收到FIN包的ACK，处于半关闭状态。此时主机2向主机1发送的任何信息（如延迟的ACK包等）都只会收到RST，导致连接的异常关闭。</p><p>为了规避这个问题，主动关闭端需要等待2MSL时间。一个MSL是给最后的ACK包，而另外一个MSL，是为了等待被动关闭端重新发送FIN包。如果在TIME_WAIT期间收到了对端的数据包，会刷新TIME_WAIT状态的时间。</p><blockquote><p>参考：Effective TCP/IP 3.8 3.9节</p></blockquote><h3 id=io复用poll>IO复用：Poll</h3><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/84501111.jpg alt></p><blockquote><p>图片来源：UNIX网络编程卷一：套接字编程 6.2节</p></blockquote><p>IO复用是指内核在发现进程指定的一个或多个IO条件就绪，内核就通知进程。通常来讲，常用的IO复用函数有<code>select()</code>和<code>poll()</code>。</p><p>当<code>poll()</code>返回后，我们需要遍历其中的fd数组找到可操作的fd。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>pollfd</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>int</span>   fd;         <span style=color:#75715e>/* file descriptor */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> events;     <span style=color:#75715e>/* requested events */</span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>short</span> revents;    <span style=color:#75715e>/* returned events */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>我们可以从<code>events</code>和<code>revents</code>获得该fd的状态，从而判别可读、可写、超时或出错。</p><p>在这里，我们并没有使用poll函数的IO复用能力，而是把它做为另一个阻塞IO调用来使用。</p><p><code>BlockTcpUtils::Open</code>函数中，我们使用了poll，用来监视相应的（一个）fd是否可读。这样一来，我们就隐式（为什么说隐式呢，因为他们一不写文档，二不写注释，一切都是潜规则）规定了C/S交互的基本工作流程：当C/S连接建立后，Server端要先说话，Client端接收到消息之后，才可以进行下面的流程。</p><blockquote><p>Client：“不管你们信不信，是Server先动的手。”</p></blockquote><p>具体为什么先用poll，再把fd设为<code>blocking</code>的，我表示二脸懵逼。在我的实验中，即使把poll删掉，测试代码也是可以work的。可能在后面的代码阅读中，这个问题可以获得解释吧。</p><p>和select一样，poll也存在被中断的情况，在phxrpc的代码里，我们给了中断“a second chance”。当poll被中断后，会重新再poll一次；如果这次再被中断，则直接返回TIMEOUT。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// retry again for EINTR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    ret <span style=color:#f92672>=</span> <span style=color:#f92672>::</span>poll(<span style=color:#f92672>&amp;</span>pfd, <span style=color:#ae81ff>1</span>, timeout_ms);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> ret <span style=color:#f92672>&amp;&amp;</span> EINTR <span style=color:#f92672>==</span> errno)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (<span style=color:#ae81ff>0</span> <span style=color:#f92672>==</span> ret)
</span></span><span style=display:flex><span>    errno <span style=color:#f92672>=</span> ETIMEDOUT;
</span></span></code></pre></div><h2 id=写在最后>写在最后</h2><p>由于这篇文章中的知识点比较杂，写作的顺序也是随机的。所以连贯性不是那么强。如果有什么问题，忍着点吧您就。</p><p>忍不了的话。。。那就留言交流吧~</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/42112021.jpg alt></p></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>