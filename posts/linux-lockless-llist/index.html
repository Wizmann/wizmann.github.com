<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>Linux内核中的少锁链表</h1><div class=tip><time datetime="2013-11-28 00:00:00 +0000 UTC">2013/11/28</time>
<span class=split>·</span>
<span>2898 words </span><span class=split>·</span>
<span>6 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/linux>linux</a>
<a href=/tags/lock-less>lock-less</a>
<a href=/tags/%E9%93%BE%E8%A1%A8>链表</a>
<a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程</a></div></div><hr><div class=content><h1 id=前言>前言 <a href=#%e5%89%8d%e8%a8%80 class=anchor>🔗</a></h1><p>最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(<a href=http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773>戳我</a>)</p><p>我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。</p><h1 id=正文>正文 <a href=#%e6%ad%a3%e6%96%87 class=anchor>🔗</a></h1><h2 id=talk-is-cheap>Talk is cheap <a href=#talk-is-cheap class=anchor>🔗</a></h2><blockquote><p>Lock-less NULL terminated single linked list</p></blockquote><p><a href=https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h>linux-2.6/include/linux/llist.h</a></p><p><a href=https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c>linux-2.6/lib/llist.c</a></p><h2 id=知识准备>知识准备 <a href=#%e7%9f%a5%e8%af%86%e5%87%86%e5%a4%87 class=anchor>🔗</a></h2><h3 id=volatile>volatile <a href=#volatile class=anchor>🔗</a></h3><blockquote><p>volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。</p></blockquote><blockquote><p>通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。</p></blockquote><blockquote><p>如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。</p></blockquote><blockquote><p>From: <a href=http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F>http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F</a></p></blockquote><h3 id=typeof>typeof <a href=#typeof class=anchor>🔗</a></h3><blockquote><p>Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.</p></blockquote><blockquote><p>From: <a href=http://gcc.gnu.org/onlinedocs/gcc/Typeof.html>http://gcc.gnu.org/onlinedocs/gcc/Typeof.html</a></p></blockquote><p><code>typeof</code>和<code>sizeof</code>类似，sizeof求的是变量/类型的大小，而typeof是求变量/类型的<strong>数据类型</strong>。</p><p>typeof在#define中的应用很多，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define max(a,b) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>   ({ typeof (a) _a = (a); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>       typeof (b) _b = (b); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>     _a &gt; _b ? _a : _b; })
</span></span></span></code></pre></div><p><code>typeof(a)</code>获得了<code>a</code>的类型，声明了一个同类型的<code>_a</code>变量。</p><p>p.s. 上面是一个安全的用<code>#define</code>实现的<code>max</code>函数。</p><h3 id=access_once>ACCESS_ONCE <a href=#access_once class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))；
</span></span></span></code></pre></div><p><code>ACCESS_ONCE</code>使用了一个类型转换，使用<code>volatile</code>修饰 <code>x</code>。避免编译器优化带来的潜在岐义。</p><h3 id=cmpxchg>cmpxchg <a href=#cmpxchg class=anchor>🔗</a></h3><blockquote><p>compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.</p></blockquote><blockquote><p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value.</p></blockquote><blockquote><p>This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.</p></blockquote><blockquote><p>The result of the operation must indicate whether it performed the substitution; this can be done either with a simple Boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).</p></blockquote><blockquote><p>&mldr;</p></blockquote><blockquote><p>In the x86 (since 80486) and Itanium architectures this is implemented as the compare and exchange (CMPXCHG) instruction, though here the LOCK prefix should be there to make it really atomic.</p></blockquote><blockquote><p>From: <a href=http://en.wikipedia.org/wiki/Compare-and-swap>http://en.wikipedia.org/wiki/Compare-and-swap</a></p></blockquote><p><code>cmpxchg</code>是在Intel平台上<code>atomic compare-and-swap</code>操作的实现。</p><p><code>cmpxchg</code>还被用来实现<code>spinlock</code>，<a href=http://stackoverflow.com/questions/6935442/x86-spinlock-using-cmpxchg>戳我</a>。</p><h2 id=show-me-the-code>Show me the code <a href=#show-me-the-code class=anchor>🔗</a></h2><h3 id=数据类型>数据类型 <a href=#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_head {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>一个简单的类型包裹。</p><p><code>llist_head</code>是链表头，而<code>llist_node</code>是链表中<strong>链</strong>的部分。</p><h3 id=初始化>初始化 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96 class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD_INIT(name)        { NULL }
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD(name)        struct llist_head name = LLIST_HEAD_INIT(name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * init_llist_head - initialize lock-less list head
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_llist_head</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        list<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表的遍历>链表的遍历 <a href=#%e9%93%be%e8%a1%a8%e7%9a%84%e9%81%8d%e5%8e%86 class=anchor>🔗</a></h3><h4 id=llist_entry>llist_entry <a href=#llist_entry class=anchor>🔗</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_entry - get the struct of this entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the &amp;struct llist_node pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_entry(ptr, type, member)                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        container_of(ptr, type, member)
</span></span></span></code></pre></div><p>声明一个链表时，我们需要把<code>llist_node</code>包含在链表节点中，<code>llist_head</code>是链表头。</p><p><code>llist_entry</code>是从链表节点中的<code>llist_node</code>成员变量获得链表节点的地址。</p><p><code>llist_entry</code>宏是从<code>container_of</code>宏继承而来的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * container_of - cast a member of a structure out to the containing structure
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the pointer to the member.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the container struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the member within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define container_of(ptr, type, member) ({                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        (type *)( (char *)__mptr - offsetof(type,member) );})
</span></span></span></code></pre></div><p>具体原理可以小小参考一下<a href=http://hi.baidu.com/holinux/item/af2e32c9dcbd3953ac00ef49>这里</a>。</p><h4 id=for_each>for_each <a href=#for_each class=anchor>🔗</a></h4><h5 id=llist_for_each>llist_for_each <a href=#llist_for_each class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each - iterate over some deleted entries of a lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the &amp;struct llist_node to use as a loop cursor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being deleted from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each(pos, node)                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = (node); pos; (pos) = (pos)-&gt;next)
</span></span></span></code></pre></div><p>一个<code>for循环</code>。简单的宏。</p><h5 id=llist_for_each_entry>llist_for_each_entry <a href=#llist_for_each_entry class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the fist entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry(pos, node, member)                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = llist_entry((node), typeof(*(pos)), member);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;(pos)-&gt;member != NULL;                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             (pos) = llist_entry((pos)-&gt;member.next, typeof(*(pos)), member))
</span></span></span></code></pre></div><p>遍历链表的类。
用伪代码来表述一下就是。</p><div class=mermaid>for ((pos) = 链表节点;
&(pos)->next指针 != NULL;
(pos) = 链表下一个节点) {
// 遍历操作
pos.foo = bar;
}</div><h5 id=llist_for_each_entry_safe>llist_for_each_entry_safe <a href=#llist_for_each_entry_safe class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry_safe - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                               safe against removal of list entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @n:                another type * to use as temporary storage
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry_safe(pos, n, node, member)                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for (pos = llist_entry((node), typeof(*pos), member);                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;pos-&gt;member != NULL &amp;&amp;                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                (n = llist_entry(pos-&gt;member.next, typeof(*n), member), true); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             pos = n)
</span></span></span></code></pre></div><p><code>safe</code>表示单链表中的节点有可能被增加/删除。</p><p>使用<code>(n = llist_entry(pos->member.next, typeof(*n), member), true)</code>可以保持遍历的安全性。</p><h6 id=llist_next>llist_next <a href=#llist_next class=anchor>🔗</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_next</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表元素的操作>链表元素的操作 <a href=#%e9%93%be%e8%a1%a8%e5%85%83%e7%b4%a0%e7%9a%84%e6%93%8d%e4%bd%9c class=anchor>🔗</a></h3><h5 id=llist_add_batch>llist_add_batch <a href=#llist_add_batch class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add_batch - add several linked entries in batch
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_first:        first entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_last:        last entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return whether list is empty before adding.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add_batch</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_first, <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_last,
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>first;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>批量增加命令，使用<code>cmpxchg</code>保持线程安全。</p><h5 id=llist_add>llist_add <a href=#llist_add class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add - add a new entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new:        new entry to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns true if the list was empty prior to adding this entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>llist_add_batch</span>(new, new, head);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_empty>llist_empty <a href=#llist_empty class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_empty - tests whether a lock-less list is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the list to test
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Not guaranteed to be accurate or up to date.  Just a quick way to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * test whether the list is empty without deleting something from the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_empty</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first) <span style=color:#f92672>==</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>ACCESS_ONCE</code>避免编译器优化，保持线程安全性。</p><h5 id=llist_del_all>llist_del_all <a href=#llist_del_all class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_all - delete all entries from lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head of lock-less list to delete all entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, delete all entries and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * return the pointer to the first entry.  The order of entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted is from the newest to the oldest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_all</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_del_first>llist_del_first <a href=#llist_del_first class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first - delete the first entry of lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, return the first entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted, this is the newest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Only one llist_del_first user can be used simultaneously with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * multiple llist_add users without lock.  Because otherwise
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first, llist_add, llist_add (or llist_del_all, llist_add,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add) sequence in another user may change @head-&gt;first-&gt;next,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * but keep @head-&gt;first.  If multiple consumers are needed, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * use llist_del_all or use lock between consumers.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_first</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>entry, <span style=color:#f92672>*</span>old_entry, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        entry <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>                old_entry <span style=color:#f92672>=</span> entry;
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> entry<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> old_entry)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> entry;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>删除第一个值。同样的无锁操作。</p><h5 id=llist_reverse_order>llist_reverse_order <a href=#llist_reverse_order class=anchor>🔗</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_reverse_order - reverse order of a llist chain
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        first item of the list to be reversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Reverse the order of a chain of llist entries and return the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * new first entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_reverse_order</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>tmp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_head;
</span></span><span style=display:flex><span>                new_head <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> new_head;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL_GPL</span>(llist_reverse_order);
</span></span></code></pre></div><p>如何反转一个单链表</p><h2 id=少锁链表是如何实现的>少锁链表是如何实现的 <a href=#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84 class=anchor>🔗</a></h2><h3 id=add函数中的原子操作>add函数中的原子操作 <a href=#add%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span></code></pre></div><p>其中<code>cmpxchg</code>的性质类似于锁。保证赋值是成功的且是是原子的。</p><h3 id=del_first中的原子操作>del_first中的原子操作 <a href=#del_first%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span></code></pre></div><h3 id=del_all中的原子操作>del_all中的原子操作 <a href=#del_all%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span></code></pre></div><h3 id=少锁链表如何处理并发>少锁链表如何处理并发 <a href=#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%b9%b6%e5%8f%91 class=anchor>🔗</a></h3><p>在llist.h中有如下的注释表明如果两种操作并发执行，是否需要加额外的锁。</p><div class=mermaid>/*
* | add | del_first | del_all
* add | - | - | -
* del_first | | L | L
* del_all | | | -
*/</div><p><code>add</code>操作和头指针没有关系，所以它可以和其它操作并行。
<code>del_first</code>依赖于<code>list->first->next</code>在操作时不变化。
而<code>del_all</code>只对<code>list->first</code>的指针进行操作。所以是可以并行的。</p><h3 id=少锁链表如何处理遍历>少锁链表如何处理遍历 <a href=#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e9%81%8d%e5%8e%86 class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The list entries deleted via llist_del_all can be traversed with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traversing function such as llist_for_each etc.  But the list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * entries can not be traversed safely before deleted from the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The order of deleted entries is from the newest to the oldest added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * one.  If you want to traverse from the oldest to the newest, you
</span></span></span><span style=display:flex><span><span style=color:#75715e> * must reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><p>大概意思是说只有从列表上删除下来的元素才可以安全的遍历。（这点理解的不深入）</p><h2 id=后记>后记 <a href=#%e5%90%8e%e8%ae%b0 class=anchor>🔗</a></h2><p>本来是想把这llist的代码看明白的。但是，大概只看懂了60%。。。</p><p>以后如果有新的想法，看到了新的东西，也许会有不少有用的update吧。。</p></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>