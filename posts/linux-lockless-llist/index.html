<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Date: 2013-11-28
Title: Linux内核中的少锁链表
Tags: linux, lock-less, 链表, 并发编程
Slug: linux-lockless-llist
前言
最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/linux-lockless-llist/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/linux-lockless-llist/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/linux-lockless-llist/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:description" content="Date: 2013-11-28 Title: Linux内核中的少锁链表 Tags: linux, lock-less, 链表, 并发编程 Slug: linux-lockless-llist
前言 最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Date: 2013-11-28
Title: Linux内核中的少锁链表
Tags: linux, lock-less, 链表, 并发编程
Slug: linux-lockless-llist
前言
最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://wizmann.top/posts/linux-lockless-llist/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Date: 2013-11-28 Title: Linux内核中的少锁链表 Tags: linux, lock-less, 链表, 并发编程 Slug: linux-lockless-llist\n前言 最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)\n","keywords":[],"articleBody":"Date: 2013-11-28 Title: Linux内核中的少锁链表 Tags: linux, lock-less, 链表, 并发编程 Slug: linux-lockless-llist\n前言 最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)\n我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。\n正文 Talk is cheap Lock-less NULL terminated single linked list\nlinux-2.6/include/linux/llist.h\nlinux-2.6/lib/llist.c\n知识准备 volatile volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。\n通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。\n如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。\nFrom: http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F\ntypeof Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.\nFrom: http://gcc.gnu.org/onlinedocs/gcc/Typeof.html\ntypeof和sizeof类似，sizeof求的是变量/类型的大小，而typeof是求变量/类型的数据类型。\ntypeof在#define中的应用很多，例如：\n#define max(a,b) \\ ({ typeof (a) _a = (a); \\ typeof (b) _b = (b); \\ _a \u003e _b ? _a : _b; }) typeof(a)获得了a的类型，声明了一个同类型的_a变量。\np.s. 上面是一个安全的用#define实现的max函数。\nACCESS_ONCE #define ACCESS_ONCE(x) (*(volatile typeof(x) *)\u0026(x))； ACCESS_ONCE使用了一个类型转换，使用volatile修饰 x。避免编译器优化带来的潜在岐义。\ncmpxchg compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.\nIt compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value.\nThis is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.\nThe result of the operation must indicate whether it performed the substitution; this can be done either with a simple Boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).\n…\nIn the x86 (since 80486) and Itanium architectures this is implemented as the compare and exchange (CMPXCHG) instruction, though here the LOCK prefix should be there to make it really atomic.\nFrom: http://en.wikipedia.org/wiki/Compare-and-swap\ncmpxchg是在Intel平台上atomic compare-and-swap操作的实现。\ncmpxchg还被用来实现spinlock，戳我。\nShow me the code 数据类型 struct llist_head { struct llist_node *first; }; struct llist_node { struct llist_node *next; }; 一个简单的类型包裹。\nllist_head是链表头，而llist_node是链表中链的部分。\n初始化 #define LLIST_HEAD_INIT(name) { NULL } #define LLIST_HEAD(name) struct llist_head name = LLIST_HEAD_INIT(name) /** * init_llist_head - initialize lock-less list head * @head: the head for your lock-less list */ static inline void init_llist_head(struct llist_head *list) { list-\u003efirst = NULL; } 链表的遍历 llist_entry /** * llist_entry - get the struct of this entry * @ptr: the \u0026struct llist_node pointer. * @type: the type of the struct this is embedded in. * @member: the name of the llist_node within the struct. */ #define llist_entry(ptr, type, member) \\ container_of(ptr, type, member) 声明一个链表时，我们需要把llist_node包含在链表节点中，llist_head是链表头。\nllist_entry是从链表节点中的llist_node成员变量获得链表节点的地址。\nllist_entry宏是从container_of宏继承而来的。\n/** * container_of - cast a member of a structure out to the containing structure * @ptr: the pointer to the member. * @type: the type of the container struct this is embedded in. * @member: the name of the member within the struct. * */ #define container_of(ptr, type, member) ({ \\ const typeof( ((type *)0)-\u003emember ) *__mptr = (ptr); \\ (type *)( (char *)__mptr - offsetof(type,member) );}) 具体原理可以小小参考一下这里。\nfor_each llist_for_each /** * llist_for_each - iterate over some deleted entries of a lock-less list * @pos: the \u0026struct llist_node to use as a loop cursor * @node: the first entry of deleted list entries * * In general, some entries of the lock-less list can be traversed * safely only after being deleted from list, so start with an entry * instead of list head. * * If being used on entries deleted from lock-less list directly, the * traverse order is from the newest to the oldest added entry. If * you want to traverse from the oldest to the newest, you must * reverse the order by yourself before traversing. */ #define llist_for_each(pos, node) \\ for ((pos) = (node); pos; (pos) = (pos)-\u003enext) 一个for循环。简单的宏。\nllist_for_each_entry /** * llist_for_each_entry - iterate over some deleted entries of lock-less list of given type * @pos: the type * to use as a loop cursor. * @node: the fist entry of deleted list entries. * @member: the name of the llist_node with the struct. * * In general, some entries of the lock-less list can be traversed * safely only after being removed from list, so start with an entry * instead of list head. * * If being used on entries deleted from lock-less list directly, the * traverse order is from the newest to the oldest added entry. If * you want to traverse from the oldest to the newest, you must * reverse the order by yourself before traversing. */ #define llist_for_each_entry(pos, node, member) \\ for ((pos) = llist_entry((node), typeof(*(pos)), member); \\ \u0026(pos)-\u003emember != NULL; \\ (pos) = llist_entry((pos)-\u003emember.next, typeof(*(pos)), member)) 遍历链表的类。 用伪代码来表述一下就是。\nf } o r p ( o p s o 遍 . s \u0026 ( 历 f ) ( p 操 o p o 作 o = o s s ) = 链 ) 表 - = b 节 \u003e a 点 n 链 r ; e 表 ; x 下 t 一 指 个 针 节 点 ! ) = { N U L L ; llist_for_each_entry_safe /** * llist_for_each_entry_safe - iterate over some deleted entries of lock-less list of given type * safe against removal of list entry * @pos: the type * to use as a loop cursor. * @n: another type * to use as temporary storage * @node: the first entry of deleted list entries. * @member: the name of the llist_node with the struct. * * In general, some entries of the lock-less list can be traversed * safely only after being removed from list, so start with an entry * instead of list head. * * If being used on entries deleted from lock-less list directly, the * traverse order is from the newest to the oldest added entry. If * you want to traverse from the oldest to the newest, you must * reverse the order by yourself before traversing. */ #define llist_for_each_entry_safe(pos, n, node, member) \\ for (pos = llist_entry((node), typeof(*pos), member); \\ \u0026pos-\u003emember != NULL \u0026\u0026 \\ (n = llist_entry(pos-\u003emember.next, typeof(*n), member), true); \\ pos = n) safe表示单链表中的节点有可能被增加/删除。\n使用(n = llist_entry(pos-\u003emember.next, typeof(*n), member), true)可以保持遍历的安全性。\nllist_next static inline struct llist_node *llist_next(struct llist_node *node) { return node-\u003enext; } 链表元素的操作 llist_add_batch /** * llist_add_batch - add several linked entries in batch * @new_first: first entry in batch to be added * @new_last: last entry in batch to be added * @head: the head for your lock-less list * * Return whether list is empty before adding. */ bool llist_add_batch(struct llist_node *new_first, struct llist_node *new_last, struct llist_head *head) { struct llist_node *first; do { new_last-\u003enext = first = ACCESS_ONCE(head-\u003efirst); } while (cmpxchg(\u0026head-\u003efirst, first, new_first) != first); return !first; } 批量增加命令，使用cmpxchg保持线程安全。\nllist_add /** * llist_add - add a new entry * @new: new entry to be added * @head: the head for your lock-less list * * Returns true if the list was empty prior to adding this entry. */ static inline bool llist_add(struct llist_node *new, struct llist_head *head) { return llist_add_batch(new, new, head); } llist_empty /** * llist_empty - tests whether a lock-less list is empty * @head: the list to test * * Not guaranteed to be accurate or up to date. Just a quick way to * test whether the list is empty without deleting something from the * list. */ static inline bool llist_empty(const struct llist_head *head) { return ACCESS_ONCE(head-\u003efirst) == NULL; } 使用ACCESS_ONCE避免编译器优化，保持线程安全性。\nllist_del_all /** * llist_del_all - delete all entries from lock-less list * @head: the head of lock-less list to delete all entries * * If list is empty, return NULL, otherwise, delete all entries and * return the pointer to the first entry. The order of entries * deleted is from the newest to the oldest added one. */ static inline struct llist_node *llist_del_all(struct llist_head *head) { return xchg(\u0026head-\u003efirst, NULL); } llist_del_first /** * llist_del_first - delete the first entry of lock-less list * @head: the head for your lock-less list * * If list is empty, return NULL, otherwise, return the first entry * deleted, this is the newest added one. * * Only one llist_del_first user can be used simultaneously with * multiple llist_add users without lock. Because otherwise * llist_del_first, llist_add, llist_add (or llist_del_all, llist_add, * llist_add) sequence in another user may change @head-\u003efirst-\u003enext, * but keep @head-\u003efirst. If multiple consumers are needed, please * use llist_del_all or use lock between consumers. */ struct llist_node *llist_del_first(struct llist_head *head) { struct llist_node *entry, *old_entry, *next; entry = head-\u003efirst; for (;;) { if (entry == NULL) return NULL; old_entry = entry; next = entry-\u003enext; entry = cmpxchg(\u0026head-\u003efirst, old_entry, next); if (entry == old_entry) break; } return entry; } 删除第一个值。同样的无锁操作。\nllist_reverse_order /** * llist_reverse_order - reverse order of a llist chain * @head: first item of the list to be reversed * * Reverse the order of a chain of llist entries and return the * new first entry. */ struct llist_node *llist_reverse_order(struct llist_node *head) { struct llist_node *new_head = NULL; while (head) { struct llist_node *tmp = head; head = head-\u003enext; tmp-\u003enext = new_head; new_head = tmp; } return new_head; } EXPORT_SYMBOL_GPL(llist_reverse_order); 如何反转一个单链表\n少锁链表是如何实现的 add函数中的原子操作 do { new_last-\u003enext = first = ACCESS_ONCE(head-\u003efirst); } while (cmpxchg(\u0026head-\u003efirst, first, new_first) != first); 其中cmpxchg的性质类似于锁。保证赋值是成功的且是是原子的。\ndel_first中的原子操作 entry = cmpxchg(\u0026head-\u003efirst, old_entry, next); del_all中的原子操作 return xchg(\u0026head-\u003efirst, NULL); 少锁链表如何处理并发 在llist.h中有如下的注释表明如果两种操作并发执行，是否需要加额外的锁。\na d d d e e d l l _ _ f a i l r l s t a d d d e l _ f L i r s t d e l _ L a l l add操作和头指针没有关系，所以它可以和其它操作并行。 del_first依赖于list-\u003efirst-\u003enext在操作时不变化。 而del_all只对list-\u003efirst的指针进行操作。所以是可以并行的。\n少锁链表如何处理遍历 /* * The list entries deleted via llist_del_all can be traversed with * traversing function such as llist_for_each etc. But the list * entries can not be traversed safely before deleted from the list. * The order of deleted entries is from the newest to the oldest added * one. If you want to traverse from the oldest to the newest, you * must reverse the order by yourself before traversing. */ 大概意思是说只有从列表上删除下来的元素才可以安全的遍历。（这点理解的不深入）\n后记 本来是想把这llist的代码看明白的。但是，大概只看懂了60%。。。\n以后如果有新的想法，看到了新的东西，也许会有不少有用的update吧。。\n","wordCount":"2827","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/linux-lockless-llist/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>wizmann</div></header><div class=post-content><p>Date: 2013-11-28
Title: Linux内核中的少锁链表
Tags: linux, lock-less, 链表, 并发编程
Slug: linux-lockless-llist</p><h1 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h1><p>最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(<a href=http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773>戳我</a>)</p><p>我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。</p><h1 id=正文>正文<a hidden class=anchor aria-hidden=true href=#正文>#</a></h1><h2 id=talk-is-cheap>Talk is cheap<a hidden class=anchor aria-hidden=true href=#talk-is-cheap>#</a></h2><blockquote><p>Lock-less NULL terminated single linked list</p></blockquote><p><a href=https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h>linux-2.6/include/linux/llist.h</a></p><p><a href=https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c>linux-2.6/lib/llist.c</a></p><h2 id=知识准备>知识准备<a hidden class=anchor aria-hidden=true href=#知识准备>#</a></h2><h3 id=volatile>volatile<a hidden class=anchor aria-hidden=true href=#volatile>#</a></h3><blockquote><p>volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。</p></blockquote><blockquote><p>通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。</p></blockquote><blockquote><p>如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。</p></blockquote><blockquote><p>From: <a href=http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F>http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F</a></p></blockquote><h3 id=typeof>typeof<a hidden class=anchor aria-hidden=true href=#typeof>#</a></h3><blockquote><p>Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.</p></blockquote><blockquote><p>From: <a href=http://gcc.gnu.org/onlinedocs/gcc/Typeof.html>http://gcc.gnu.org/onlinedocs/gcc/Typeof.html</a></p></blockquote><p><code>typeof</code>和<code>sizeof</code>类似，sizeof求的是变量/类型的大小，而typeof是求变量/类型的<strong>数据类型</strong>。</p><p>typeof在#define中的应用很多，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define max(a,b) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>   ({ typeof (a) _a = (a); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>       typeof (b) _b = (b); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>     _a &gt; _b ? _a : _b; })
</span></span></span></code></pre></div><p><code>typeof(a)</code>获得了<code>a</code>的类型，声明了一个同类型的<code>_a</code>变量。</p><p>p.s. 上面是一个安全的用<code>#define</code>实现的<code>max</code>函数。</p><h3 id=access_once>ACCESS_ONCE<a hidden class=anchor aria-hidden=true href=#access_once>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))；
</span></span></span></code></pre></div><p><code>ACCESS_ONCE</code>使用了一个类型转换，使用<code>volatile</code>修饰 <code>x</code>。避免编译器优化带来的潜在岐义。</p><h3 id=cmpxchg>cmpxchg<a hidden class=anchor aria-hidden=true href=#cmpxchg>#</a></h3><blockquote><p>compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.</p></blockquote><blockquote><p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value.</p></blockquote><blockquote><p>This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.</p></blockquote><blockquote><p>The result of the operation must indicate whether it performed the substitution; this can be done either with a simple Boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).</p></blockquote><blockquote><p>&mldr;</p></blockquote><blockquote><p>In the x86 (since 80486) and Itanium architectures this is implemented as the compare and exchange (CMPXCHG) instruction, though here the LOCK prefix should be there to make it really atomic.</p></blockquote><blockquote><p>From: <a href=http://en.wikipedia.org/wiki/Compare-and-swap>http://en.wikipedia.org/wiki/Compare-and-swap</a></p></blockquote><p><code>cmpxchg</code>是在Intel平台上<code>atomic compare-and-swap</code>操作的实现。</p><p><code>cmpxchg</code>还被用来实现<code>spinlock</code>，<a href=http://stackoverflow.com/questions/6935442/x86-spinlock-using-cmpxchg>戳我</a>。</p><h2 id=show-me-the-code>Show me the code<a hidden class=anchor aria-hidden=true href=#show-me-the-code>#</a></h2><h3 id=数据类型>数据类型<a hidden class=anchor aria-hidden=true href=#数据类型>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_head {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>一个简单的类型包裹。</p><p><code>llist_head</code>是链表头，而<code>llist_node</code>是链表中<strong>链</strong>的部分。</p><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD_INIT(name)        { NULL }
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD(name)        struct llist_head name = LLIST_HEAD_INIT(name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * init_llist_head - initialize lock-less list head
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_llist_head</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        list<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表的遍历>链表的遍历<a hidden class=anchor aria-hidden=true href=#链表的遍历>#</a></h3><h4 id=llist_entry>llist_entry<a hidden class=anchor aria-hidden=true href=#llist_entry>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_entry - get the struct of this entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the &amp;struct llist_node pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_entry(ptr, type, member)                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        container_of(ptr, type, member)
</span></span></span></code></pre></div><p>声明一个链表时，我们需要把<code>llist_node</code>包含在链表节点中，<code>llist_head</code>是链表头。</p><p><code>llist_entry</code>是从链表节点中的<code>llist_node</code>成员变量获得链表节点的地址。</p><p><code>llist_entry</code>宏是从<code>container_of</code>宏继承而来的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * container_of - cast a member of a structure out to the containing structure
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the pointer to the member.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the container struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the member within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define container_of(ptr, type, member) ({                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        (type *)( (char *)__mptr - offsetof(type,member) );})
</span></span></span></code></pre></div><p>具体原理可以小小参考一下<a href=http://hi.baidu.com/holinux/item/af2e32c9dcbd3953ac00ef49>这里</a>。</p><h4 id=for_each>for_each<a hidden class=anchor aria-hidden=true href=#for_each>#</a></h4><h5 id=llist_for_each>llist_for_each<a hidden class=anchor aria-hidden=true href=#llist_for_each>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each - iterate over some deleted entries of a lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the &amp;struct llist_node to use as a loop cursor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being deleted from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each(pos, node)                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = (node); pos; (pos) = (pos)-&gt;next)
</span></span></span></code></pre></div><p>一个<code>for循环</code>。简单的宏。</p><h5 id=llist_for_each_entry>llist_for_each_entry<a hidden class=anchor aria-hidden=true href=#llist_for_each_entry>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the fist entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry(pos, node, member)                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = llist_entry((node), typeof(*(pos)), member);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;(pos)-&gt;member != NULL;                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             (pos) = llist_entry((pos)-&gt;member.next, typeof(*(pos)), member))
</span></span></span></code></pre></div><p>遍历链表的类。
用伪代码来表述一下就是。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 264 105"><g transform="translate(8,16)"><path d="M28 56l8-16" fill="none" stroke="currentcolor"/><path d="M36 56l8-16" fill="none" stroke="currentcolor"/><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="0" y="84" fill="currentcolor" style="font-size:1em">}</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="32" y="68" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="40" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="48" y="68" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="56" y="52" fill="currentcolor" style="font-size:1em">遍</text><text text-anchor="middle" x="56" y="68" fill="currentcolor" style="font-size:1em">.</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="64" y="20" fill="currentcolor" style="font-size:1em">&amp;</text><text text-anchor="middle" x="64" y="36" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">历</text><text text-anchor="middle" x="64" y="68" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="72" y="20" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="72" y="36" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">操</text><text text-anchor="middle" x="72" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="80" y="20" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="80" y="36" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">作</text><text text-anchor="middle" x="80" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="88" y="20" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="88" y="36" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="96" y="20" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="96" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="96" y="68" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">链</text><text text-anchor="middle" x="104" y="20" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">表</text><text text-anchor="middle" x="112" y="20" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="112" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="112" y="68" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">节</text><text text-anchor="middle" x="120" y="20" fill="currentcolor" style="font-size:1em">></text><text text-anchor="middle" x="120" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">点</text><text text-anchor="middle" x="128" y="20" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="128" y="36" fill="currentcolor" style="font-size:1em">链</text><text text-anchor="middle" x="128" y="68" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="136" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">表</text><text text-anchor="middle" x="136" y="68" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="144" y="20" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">下</text><text text-anchor="middle" x="152" y="20" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="36" fill="currentcolor" style="font-size:1em">一</text><text text-anchor="middle" x="160" y="20" fill="currentcolor" style="font-size:1em">指</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">个</text><text text-anchor="middle" x="168" y="20" fill="currentcolor" style="font-size:1em">针</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">节</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">点</text><text text-anchor="middle" x="184" y="20" fill="currentcolor" style="font-size:1em">!</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="192" y="20" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="200" y="36" fill="currentcolor" style="font-size:1em">{</text><text text-anchor="middle" x="208" y="20" fill="currentcolor" style="font-size:1em">N</text><text text-anchor="middle" x="216" y="20" fill="currentcolor" style="font-size:1em">U</text><text text-anchor="middle" x="224" y="20" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="232" y="20" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="240" y="20" fill="currentcolor" style="font-size:1em">;</text></g></svg></div><h5 id=llist_for_each_entry_safe>llist_for_each_entry_safe<a hidden class=anchor aria-hidden=true href=#llist_for_each_entry_safe>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry_safe - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                               safe against removal of list entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @n:                another type * to use as temporary storage
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry_safe(pos, n, node, member)                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for (pos = llist_entry((node), typeof(*pos), member);                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;pos-&gt;member != NULL &amp;&amp;                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                (n = llist_entry(pos-&gt;member.next, typeof(*n), member), true); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             pos = n)
</span></span></span></code></pre></div><p><code>safe</code>表示单链表中的节点有可能被增加/删除。</p><p>使用<code>(n = llist_entry(pos->member.next, typeof(*n), member), true)</code>可以保持遍历的安全性。</p><h6 id=llist_next>llist_next<a hidden class=anchor aria-hidden=true href=#llist_next>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_next</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表元素的操作>链表元素的操作<a hidden class=anchor aria-hidden=true href=#链表元素的操作>#</a></h3><h5 id=llist_add_batch>llist_add_batch<a hidden class=anchor aria-hidden=true href=#llist_add_batch>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add_batch - add several linked entries in batch
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_first:        first entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_last:        last entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return whether list is empty before adding.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add_batch</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_first, <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_last,
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>first;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>批量增加命令，使用<code>cmpxchg</code>保持线程安全。</p><h5 id=llist_add>llist_add<a hidden class=anchor aria-hidden=true href=#llist_add>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add - add a new entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new:        new entry to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns true if the list was empty prior to adding this entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>llist_add_batch</span>(new, new, head);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_empty>llist_empty<a hidden class=anchor aria-hidden=true href=#llist_empty>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_empty - tests whether a lock-less list is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the list to test
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Not guaranteed to be accurate or up to date.  Just a quick way to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * test whether the list is empty without deleting something from the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_empty</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first) <span style=color:#f92672>==</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>ACCESS_ONCE</code>避免编译器优化，保持线程安全性。</p><h5 id=llist_del_all>llist_del_all<a hidden class=anchor aria-hidden=true href=#llist_del_all>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_all - delete all entries from lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head of lock-less list to delete all entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, delete all entries and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * return the pointer to the first entry.  The order of entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted is from the newest to the oldest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_all</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_del_first>llist_del_first<a hidden class=anchor aria-hidden=true href=#llist_del_first>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first - delete the first entry of lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, return the first entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted, this is the newest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Only one llist_del_first user can be used simultaneously with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * multiple llist_add users without lock.  Because otherwise
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first, llist_add, llist_add (or llist_del_all, llist_add,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add) sequence in another user may change @head-&gt;first-&gt;next,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * but keep @head-&gt;first.  If multiple consumers are needed, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * use llist_del_all or use lock between consumers.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_first</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>entry, <span style=color:#f92672>*</span>old_entry, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        entry <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>                old_entry <span style=color:#f92672>=</span> entry;
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> entry<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> old_entry)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> entry;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>删除第一个值。同样的无锁操作。</p><h5 id=llist_reverse_order>llist_reverse_order<a hidden class=anchor aria-hidden=true href=#llist_reverse_order>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_reverse_order - reverse order of a llist chain
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        first item of the list to be reversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Reverse the order of a chain of llist entries and return the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * new first entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_reverse_order</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>tmp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_head;
</span></span><span style=display:flex><span>                new_head <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> new_head;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL_GPL</span>(llist_reverse_order);
</span></span></code></pre></div><p>如何反转一个单链表</p><h2 id=少锁链表是如何实现的>少锁链表是如何实现的<a hidden class=anchor aria-hidden=true href=#少锁链表是如何实现的>#</a></h2><h3 id=add函数中的原子操作>add函数中的原子操作<a hidden class=anchor aria-hidden=true href=#add函数中的原子操作>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span></code></pre></div><p>其中<code>cmpxchg</code>的性质类似于锁。保证赋值是成功的且是是原子的。</p><h3 id=del_first中的原子操作>del_first中的原子操作<a hidden class=anchor aria-hidden=true href=#del_first中的原子操作>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span></code></pre></div><h3 id=del_all中的原子操作>del_all中的原子操作<a hidden class=anchor aria-hidden=true href=#del_all中的原子操作>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span></code></pre></div><h3 id=少锁链表如何处理并发>少锁链表如何处理并发<a hidden class=anchor aria-hidden=true href=#少锁链表如何处理并发>#</a></h3><p>在llist.h中有如下的注释表明如果两种操作并发执行，是否需要加额外的锁。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 376 105"><g transform="translate(8,16)"><path d="M144 32h8" fill="none" stroke="currentcolor"/><path d="M240 32h8" fill="none" stroke="currentcolor"/><path d="M336 32h8" fill="none" stroke="currentcolor"/><path d="M336 64h8" fill="none" stroke="currentcolor"/><path d="M104 16V64" fill="none" stroke="currentcolor"/><path d="M192 16V64" fill="none" stroke="currentcolor"/><path d="M288 16V64" fill="none" stroke="currentcolor"/><path d="M4 8-4 40" fill="none" stroke="currentcolor"/><path d="M12 88l8-16" fill="none" stroke="currentcolor"/><circle cx="8" cy="16" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="32" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="48" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="64" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="80" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="16" cy="0" r="6" stroke="currentcolor" fill="currentcolor"/><text text-anchor="middle" x="24" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="24" y="52" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="24" y="68" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="32" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="32" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="40" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="40" y="52" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="40" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="48" y="52" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="48" y="68" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="56" y="52" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="56" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="64" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="72" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="88" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="144" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="152" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="208" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="216" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="224" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="232" y="20" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="240" y="20" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="240" y="52" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="248" y="20" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="256" y="20" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="264" y="20" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="272" y="20" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="312" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="320" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="328" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="336" y="20" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="336" y="52" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="344" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="352" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="360" y="20" fill="currentcolor" style="font-size:1em">l</text></g></svg></div><p><code>add</code>操作和头指针没有关系，所以它可以和其它操作并行。
<code>del_first</code>依赖于<code>list->first->next</code>在操作时不变化。
而<code>del_all</code>只对<code>list->first</code>的指针进行操作。所以是可以并行的。</p><h3 id=少锁链表如何处理遍历>少锁链表如何处理遍历<a hidden class=anchor aria-hidden=true href=#少锁链表如何处理遍历>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The list entries deleted via llist_del_all can be traversed with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traversing function such as llist_for_each etc.  But the list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * entries can not be traversed safely before deleted from the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The order of deleted entries is from the newest to the oldest added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * one.  If you want to traverse from the oldest to the newest, you
</span></span></span><span style=display:flex><span><span style=color:#75715e> * must reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><p>大概意思是说只有从列表上删除下来的元素才可以安全的遍历。（这点理解的不深入）</p><h2 id=后记>后记<a hidden class=anchor aria-hidden=true href=#后记>#</a></h2><p>本来是想把这llist的代码看明白的。但是，大概只看懂了60%。。。</p><p>以后如果有新的想法，看到了新的东西，也许会有不少有用的update吧。。</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/lava-store/><span class=title>«</span><br><span></span>
</a><a class=next href=https://wizmann.top/posts/metaprogramming-in-dotnet-1/><span class=title>»</span><br><span></span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>