<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>Linux内核中的少锁链表</title>
<meta name=description content="前言 最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)
我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。
"><link rel=canonical href=https://wizmann.top/posts/linux-lockless-llist/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/linux-lockless-llist/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/linux-lockless-llist/><meta property="og:title" content="Linux内核中的少锁链表"><meta property="og:description" content="前言
最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)
我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。"><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/linux-lockless-llist/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-11-28T00:00:00+00:00"><meta property="article:modified_time" content="2013-11-28T00:00:00+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="Linux内核中的少锁链表"><meta name=twitter:description content="前言
最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)
我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Linux内核中的少锁链表","datePublished":"2013-11-28T00:00:00+00:00","dateModified":"2013-11-28T00:00:00+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":2799,"description":"前言 最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(戳我)\n我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h1 id=前言>前言</h1><p>最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(<a href=http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773 target=_blank rel=noopener>戳我</a>)</p><p>我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。</p><h1 id=正文>正文</h1><h2 id=talk-is-cheap>Talk is cheap</h2><blockquote><p>Lock-less NULL terminated single linked list</p></blockquote><p><a href=https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h target=_blank rel=noopener>linux-2.6/include/linux/llist.h</a></p><p><a href=https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c target=_blank rel=noopener>linux-2.6/lib/llist.c</a></p><h2 id=知识准备>知识准备</h2><h3 id=volatile>volatile</h3><blockquote><p>volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。</p></blockquote><blockquote><p>通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。</p></blockquote><blockquote><p>如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。</p></blockquote><blockquote><p>From: <a href=http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F target=_blank rel=noopener>http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F</a></p></blockquote><h3 id=typeof>typeof</h3><blockquote><p>Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.</p></blockquote><blockquote><p>From: <a href=http://gcc.gnu.org/onlinedocs/gcc/Typeof.html target=_blank rel=noopener>http://gcc.gnu.org/onlinedocs/gcc/Typeof.html</a></p></blockquote><p><code>typeof</code>和<code>sizeof</code>类似，sizeof求的是变量/类型的大小，而typeof是求变量/类型的<strong>数据类型</strong>。</p><p>typeof在#define中的应用很多，例如：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define max(a,b) \
</span></span></span><span style=display:flex><span><span style=color:#75715e>   ({ typeof (a) _a = (a); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>       typeof (b) _b = (b); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>     _a &gt; _b ? _a : _b; })
</span></span></span></code></pre></div><p><code>typeof(a)</code>获得了<code>a</code>的类型，声明了一个同类型的<code>_a</code>变量。</p><p>p.s. 上面是一个安全的用<code>#define</code>实现的<code>max</code>函数。</p><h3 id=access_once>ACCESS_ONCE</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;(x))；
</span></span></span></code></pre></div><p><code>ACCESS_ONCE</code>使用了一个类型转换，使用<code>volatile</code>修饰 <code>x</code>。避免编译器优化带来的潜在岐义。</p><h3 id=cmpxchg>cmpxchg</h3><blockquote><p>compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.</p></blockquote><blockquote><p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value.</p></blockquote><blockquote><p>This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.</p></blockquote><blockquote><p>The result of the operation must indicate whether it performed the substitution; this can be done either with a simple Boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).</p></blockquote><blockquote><p>&mldr;</p></blockquote><blockquote><p>In the x86 (since 80486) and Itanium architectures this is implemented as the compare and exchange (CMPXCHG) instruction, though here the LOCK prefix should be there to make it really atomic.</p></blockquote><blockquote><p>From: <a href=http://en.wikipedia.org/wiki/Compare-and-swap target=_blank rel=noopener>http://en.wikipedia.org/wiki/Compare-and-swap</a></p></blockquote><p><code>cmpxchg</code>是在Intel平台上<code>atomic compare-and-swap</code>操作的实现。</p><p><code>cmpxchg</code>还被用来实现<code>spinlock</code>，<a href=http://stackoverflow.com/questions/6935442/x86-spinlock-using-cmpxchg target=_blank rel=noopener>戳我</a>。</p><h2 id=show-me-the-code>Show me the code</h2><h3 id=数据类型>数据类型</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_head {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>一个简单的类型包裹。</p><p><code>llist_head</code>是链表头，而<code>llist_node</code>是链表中<strong>链</strong>的部分。</p><h3 id=初始化>初始化</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD_INIT(name)        { NULL }
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define LLIST_HEAD(name)        struct llist_head name = LLIST_HEAD_INIT(name)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * init_llist_head - initialize lock-less list head
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init_llist_head</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>list)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        list<span style=color:#f92672>-&gt;</span>first <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表的遍历>链表的遍历</h3><h4 id=llist_entry>llist_entry</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_entry - get the struct of this entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the &amp;struct llist_node pointer.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_entry(ptr, type, member)                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        container_of(ptr, type, member)
</span></span></span></code></pre></div><p>声明一个链表时，我们需要把<code>llist_node</code>包含在链表节点中，<code>llist_head</code>是链表头。</p><p><code>llist_entry</code>是从链表节点中的<code>llist_node</code>成员变量获得链表节点的地址。</p><p><code>llist_entry</code>宏是从<code>container_of</code>宏继承而来的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * container_of - cast a member of a structure out to the containing structure
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @ptr:        the pointer to the member.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @type:        the type of the container struct this is embedded in.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the member within the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define container_of(ptr, type, member) ({                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        (type *)( (char *)__mptr - offsetof(type,member) );})
</span></span></span></code></pre></div><p>具体原理可以小小参考一下<a href=http://hi.baidu.com/holinux/item/af2e32c9dcbd3953ac00ef49 target=_blank rel=noopener>这里</a>。</p><h4 id=for_each>for_each</h4><h5 id=llist_for_each>llist_for_each</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each - iterate over some deleted entries of a lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the &amp;struct llist_node to use as a loop cursor
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being deleted from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each(pos, node)                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = (node); pos; (pos) = (pos)-&gt;next)
</span></span></span></code></pre></div><p>一个<code>for循环</code>。简单的宏。</p><h5 id=llist_for_each_entry>llist_for_each_entry</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the fist entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry(pos, node, member)                                \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for ((pos) = llist_entry((node), typeof(*(pos)), member);        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;(pos)-&gt;member != NULL;                                        \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             (pos) = llist_entry((pos)-&gt;member.next, typeof(*(pos)), member))
</span></span></span></code></pre></div><p>遍历链表的类。
用伪代码来表述一下就是。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 264 105"><g transform="translate(8,16)"><path d="M28 56l8-16" fill="none" stroke="currentcolor"/><path d="M36 56l8-16" fill="none" stroke="currentcolor"/><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="0" y="84" fill="currentcolor" style="font-size:1em">}</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="32" y="68" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="40" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="48" y="68" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="56" y="52" fill="currentcolor" style="font-size:1em">遍</text><text text-anchor="middle" x="56" y="68" fill="currentcolor" style="font-size:1em">.</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="64" y="20" fill="currentcolor" style="font-size:1em">&amp;</text><text text-anchor="middle" x="64" y="36" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">历</text><text text-anchor="middle" x="64" y="68" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="72" y="20" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="72" y="36" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">操</text><text text-anchor="middle" x="72" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="80" y="20" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="80" y="36" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">作</text><text text-anchor="middle" x="80" y="68" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="88" y="20" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="88" y="36" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="96" y="20" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="96" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="96" y="68" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">链</text><text text-anchor="middle" x="104" y="20" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">表</text><text text-anchor="middle" x="112" y="20" fill="currentcolor" style="font-size:1em">-</text><text text-anchor="middle" x="112" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="112" y="68" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">节</text><text text-anchor="middle" x="120" y="20" fill="currentcolor" style="font-size:1em">></text><text text-anchor="middle" x="120" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">点</text><text text-anchor="middle" x="128" y="20" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="128" y="36" fill="currentcolor" style="font-size:1em">链</text><text text-anchor="middle" x="128" y="68" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="136" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">表</text><text text-anchor="middle" x="136" y="68" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="144" y="20" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">下</text><text text-anchor="middle" x="152" y="20" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="36" fill="currentcolor" style="font-size:1em">一</text><text text-anchor="middle" x="160" y="20" fill="currentcolor" style="font-size:1em">指</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">个</text><text text-anchor="middle" x="168" y="20" fill="currentcolor" style="font-size:1em">针</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">节</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">点</text><text text-anchor="middle" x="184" y="20" fill="currentcolor" style="font-size:1em">!</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="192" y="20" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="200" y="36" fill="currentcolor" style="font-size:1em">{</text><text text-anchor="middle" x="208" y="20" fill="currentcolor" style="font-size:1em">N</text><text text-anchor="middle" x="216" y="20" fill="currentcolor" style="font-size:1em">U</text><text text-anchor="middle" x="224" y="20" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="232" y="20" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="240" y="20" fill="currentcolor" style="font-size:1em">;</text></g></svg></div><h5 id=llist_for_each_entry_safe>llist_for_each_entry_safe</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_for_each_entry_safe - iterate over some deleted entries of lock-less list of given type
</span></span></span><span style=display:flex><span><span style=color:#75715e> *                               safe against removal of list entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @pos:        the type * to use as a loop cursor.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @n:                another type * to use as temporary storage
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @node:        the first entry of deleted list entries.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @member:        the name of the llist_node with the struct.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * In general, some entries of the lock-less list can be traversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> * safely only after being removed from list, so start with an entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * instead of list head.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If being used on entries deleted from lock-less list directly, the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse order is from the newest to the oldest added entry.  If
</span></span></span><span style=display:flex><span><span style=color:#75715e> * you want to traverse from the oldest to the newest, you must
</span></span></span><span style=display:flex><span><span style=color:#75715e> * reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define llist_for_each_entry_safe(pos, n, node, member)                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for (pos = llist_entry((node), typeof(*pos), member);                       \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             &amp;pos-&gt;member != NULL &amp;&amp;                                               \
</span></span></span><span style=display:flex><span><span style=color:#75715e>                (n = llist_entry(pos-&gt;member.next, typeof(*n), member), true); \
</span></span></span><span style=display:flex><span><span style=color:#75715e>             pos = n)
</span></span></span></code></pre></div><p><code>safe</code>表示单链表中的节点有可能被增加/删除。</p><p>使用<code>(n = llist_entry(pos->member.next, typeof(*n), member), true)</code>可以保持遍历的安全性。</p><h6 id=llist_next>llist_next</h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_next</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>node)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> node<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=链表元素的操作>链表元素的操作</h3><h5 id=llist_add_batch>llist_add_batch</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add_batch - add several linked entries in batch
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_first:        first entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new_last:        last entry in batch to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Return whether list is empty before adding.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add_batch</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_first, <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_last,
</span></span><span style=display:flex><span>                     <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>first;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>                new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>!</span>first;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>批量增加命令，使用<code>cmpxchg</code>保持线程安全。</p><h5 id=llist_add>llist_add</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add - add a new entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @new:        new entry to be added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Returns true if the list was empty prior to adding this entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_add</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new, <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>llist_add_batch</span>(new, new, head);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_empty>llist_empty</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_empty - tests whether a lock-less list is empty
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the list to test
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Not guaranteed to be accurate or up to date.  Just a quick way to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * test whether the list is empty without deleting something from the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>llist_empty</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first) <span style=color:#f92672>==</span> NULL;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>使用<code>ACCESS_ONCE</code>避免编译器优化，保持线程安全性。</p><h5 id=llist_del_all>llist_del_all</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_all - delete all entries from lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head of lock-less list to delete all entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, delete all entries and
</span></span></span><span style=display:flex><span><span style=color:#75715e> * return the pointer to the first entry.  The order of entries
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted is from the newest to the oldest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>static</span> <span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_all</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=llist_del_first>llist_del_first</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first - delete the first entry of lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        the head for your lock-less list
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * If list is empty, return NULL, otherwise, return the first entry
</span></span></span><span style=display:flex><span><span style=color:#75715e> * deleted, this is the newest added one.
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Only one llist_del_first user can be used simultaneously with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * multiple llist_add users without lock.  Because otherwise
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_del_first, llist_add, llist_add (or llist_del_all, llist_add,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_add) sequence in another user may change @head-&gt;first-&gt;next,
</span></span></span><span style=display:flex><span><span style=color:#75715e> * but keep @head-&gt;first.  If multiple consumers are needed, please
</span></span></span><span style=display:flex><span><span style=color:#75715e> * use llist_del_all or use lock between consumers.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_del_first</span>(<span style=color:#66d9ef>struct</span> llist_head <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>entry, <span style=color:#f92672>*</span>old_entry, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        entry <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>first;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> NULL)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>                old_entry <span style=color:#f92672>=</span> entry;
</span></span><span style=display:flex><span>                next <span style=color:#f92672>=</span> entry<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (entry <span style=color:#f92672>==</span> old_entry)
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> entry;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>删除第一个值。同样的无锁操作。</p><h5 id=llist_reverse_order>llist_reverse_order</h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/**
</span></span></span><span style=display:flex><span><span style=color:#75715e> * llist_reverse_order - reverse order of a llist chain
</span></span></span><span style=display:flex><span><span style=color:#75715e> * @head:        first item of the list to be reversed
</span></span></span><span style=display:flex><span><span style=color:#75715e> *
</span></span></span><span style=display:flex><span><span style=color:#75715e> * Reverse the order of a chain of llist entries and return the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * new first entry.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span><span style=color:#a6e22e>llist_reverse_order</span>(<span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>head)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>new_head <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (head) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>struct</span> llist_node <span style=color:#f92672>*</span>tmp <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>                head <span style=color:#f92672>=</span> head<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>                tmp<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> new_head;
</span></span><span style=display:flex><span>                new_head <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> new_head;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>EXPORT_SYMBOL_GPL</span>(llist_reverse_order);
</span></span></code></pre></div><p>如何反转一个单链表</p><h2 id=少锁链表是如何实现的>少锁链表是如何实现的</h2><h3 id=add函数中的原子操作>add函数中的原子操作</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>do</span> {
</span></span><span style=display:flex><span>    new_last<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> first <span style=color:#f92672>=</span> <span style=color:#a6e22e>ACCESS_ONCE</span>(head<span style=color:#f92672>-&gt;</span>first);
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>while</span> (<span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, first, new_first) <span style=color:#f92672>!=</span> first);
</span></span></code></pre></div><p>其中<code>cmpxchg</code>的性质类似于锁。保证赋值是成功的且是是原子的。</p><h3 id=del_first中的原子操作>del_first中的原子操作</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>entry <span style=color:#f92672>=</span> <span style=color:#a6e22e>cmpxchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, old_entry, next);
</span></span></code></pre></div><h3 id=del_all中的原子操作>del_all中的原子操作</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#a6e22e>xchg</span>(<span style=color:#f92672>&amp;</span>head<span style=color:#f92672>-&gt;</span>first, NULL);
</span></span></code></pre></div><h3 id=少锁链表如何处理并发>少锁链表如何处理并发</h3><p>在llist.h中有如下的注释表明如果两种操作并发执行，是否需要加额外的锁。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 376 105"><g transform="translate(8,16)"><path d="M144 32h8" fill="none" stroke="currentcolor"/><path d="M240 32h8" fill="none" stroke="currentcolor"/><path d="M336 32h8" fill="none" stroke="currentcolor"/><path d="M336 64h8" fill="none" stroke="currentcolor"/><path d="M104 16V64" fill="none" stroke="currentcolor"/><path d="M192 16V64" fill="none" stroke="currentcolor"/><path d="M288 16V64" fill="none" stroke="currentcolor"/><path d="M4 8-4 40" fill="none" stroke="currentcolor"/><path d="M12 88l8-16" fill="none" stroke="currentcolor"/><circle cx="8" cy="16" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="32" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="48" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="64" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="8" cy="80" r="6" stroke="currentcolor" fill="currentcolor"/><circle cx="16" cy="0" r="6" stroke="currentcolor" fill="currentcolor"/><text text-anchor="middle" x="24" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="24" y="52" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="24" y="68" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="32" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="32" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="68" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="40" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="40" y="52" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="40" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="48" y="52" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="48" y="68" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="56" y="52" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="56" y="68" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="64" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="72" y="68" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="88" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="136" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="144" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="152" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="208" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="216" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="224" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="232" y="20" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="240" y="20" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="240" y="52" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="248" y="20" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="256" y="20" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="264" y="20" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="272" y="20" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="312" y="20" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="320" y="20" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="328" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="336" y="20" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="336" y="52" fill="currentcolor" style="font-size:1em">L</text><text text-anchor="middle" x="344" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="352" y="20" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="360" y="20" fill="currentcolor" style="font-size:1em">l</text></g></svg></div><p><code>add</code>操作和头指针没有关系，所以它可以和其它操作并行。
<code>del_first</code>依赖于<code>list->first->next</code>在操作时不变化。
而<code>del_all</code>只对<code>list->first</code>的指针进行操作。所以是可以并行的。</p><h3 id=少锁链表如何处理遍历>少锁链表如何处理遍历</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The list entries deleted via llist_del_all can be traversed with
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traversing function such as llist_for_each etc.  But the list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * entries can not be traversed safely before deleted from the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * The order of deleted entries is from the newest to the oldest added
</span></span></span><span style=display:flex><span><span style=color:#75715e> * one.  If you want to traverse from the oldest to the newest, you
</span></span></span><span style=display:flex><span><span style=color:#75715e> * must reverse the order by yourself before traversing.
</span></span></span><span style=display:flex><span><span style=color:#75715e> */</span>
</span></span></code></pre></div><p>大概意思是说只有从列表上删除下来的元素才可以安全的遍历。（这点理解的不深入）</p><h2 id=后记>后记</h2><p>本来是想把这llist的代码看明白的。但是，大概只看懂了60%。。。</p><p>以后如果有新的想法，看到了新的东西，也许会有不少有用的update吧。。</p></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>