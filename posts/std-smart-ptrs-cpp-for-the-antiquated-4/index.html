<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>动手实现智能指针 （上篇） - C++ for the Antiquated（之四） | Maerlyn's Rainbow</title>
<meta name=keywords content="cpp,modern cpp"><meta name=description content="智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="动手实现智能指针 （上篇） - C++ for the Antiquated（之四）"><meta property="og:description" content="智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-21T00:00:00+00:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Modern Cpp"><meta name=twitter:card content="summary"><meta name=twitter:title content="动手实现智能指针 （上篇） - C++ for the Antiquated（之四）"><meta name=twitter:description content="智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"动手实现智能指针 （上篇） - C++ for the Antiquated（之四）","item":"https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"动手实现智能指针 （上篇） - C++ for the Antiquated（之四）","name":"动手实现智能指针 （上篇） - C\u002b\u002b for the Antiquated（之四）","description":"智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。\n","keywords":["cpp","modern cpp"],"articleBody":"智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。\n本文将围绕以下主题展开讨论：\nC++ 智能指针的实现原理 非侵入式智能指针与侵入式智能指针的区别 利用 atomic 避免多线程竞态条件 如何实现侵入式版本的 shared_ptr 和 weak_ptr 采用 concept 约束模板类型 探讨完美转发（std::forward）在智能指针中的应用 C++ 中的智能指针 std::shared_ptr的实现 std::shared_ptr 是一种智能指针，能够自动管理对象的生命周期。它通过引用计数的方式来跟踪有多少个 shared_ptr 实例指向同一个对象，确保当最后一个 shared_ptr 被销毁时，对象的内存能够自动释放。\n引用计数与原子操作 std::shared_ptr 的核心机制是引用计数。每个 shared_ptr 会维护一个引用计数。当多个 shared_ptr 指向同一个对象时，计数器会增加；当一个 shared_ptr 被销毁时，计数器会减少。如果计数器归零，表明没有任何 shared_ptr 再指向该对象，这时对象会被删除。\n引用计数通常由一个控制块（control block）管理。控制块不仅保存引用计数，还会保存对象本身以及与对象生命周期相关的其他信息。std::shared_ptr 的实现一般使用“非侵入式引用计数”（即不嵌入对象本身）。\n示例代码如下：\ntemplate \u003ctypename T\u003e class control_block { public: control_block(T* ptr) : ref_count(1), obj(ptr) {} // 增加引用计数 void add_ref() { ++ref_count; } // 减少引用计数 void release_ref() { if (--ref_count == 0) { delete obj; // 删除对象 delete this; // 删除控制块 } } T* get() { return obj; } private: std::atomic\u003cint\u003e ref_count; // 引用计数 T* obj; // 实际对象 }; 简化版 shared_ptr 实现 下面是一个简化版的 shared_ptr 实现示例。这个版本仍然有一些重要细节需要注意，比如原子操作和异常安全等问题，但可以帮助理解 shared_ptr 的基本原理：\ntemplate \u003ctypename T\u003e class my_shared_ptr { private: T* ptr; control_block\u003cT\u003e* ctrl_block; public: explicit my_shared_ptr(T* p = nullptr) : ptr(p), ctrl_block(new control_block\u003cT\u003e(p)) {} // 拷贝构造函数 my_shared_ptr(const my_shared_ptr\u0026 other) : ptr(other.ptr), ctrl_block(other.ctrl_block) { if (ctrl_block) { ctrl_block-\u003eadd_ref(); } } // 析构函数 ~my_shared_ptr() { if (ctrl_block) { ctrl_block-\u003erelease_ref(); } } T* operator-\u003e() { return ptr; } T\u0026 operator*() { return *ptr; } }; std::weak_ptr的实现 std::weak_ptr 是与 std::shared_ptr 配合使用的智能指针，它解决了 shared_ptr 在某些场景下的循环引用问题。\n循环引用问题发生在两个或多个对象通过 shared_ptr 相互引用时，导致引用计数永远不为零，从而引发内存泄漏。为了避免这个问题，我们引入了 weak_ptr。\n为什么需要 weak_ptr std::weak_ptr 不增加引用计数，因此它不会影响对象的生命周期。当一个对象的所有 shared_ptr 被销毁后，weak_ptr 将变为“悬挂”状态。这与普通指针的“空悬指针”（dangling pointer）不同，空悬的 weak_ptr 会返回空指针 nullptr，表明该对象的生命周期已经结束。\nweak_ptr 提供了一种访问 shared_ptr 的方式，但并不控制对象的销毁，因此它可以有效避免循环引用问题。\n通过 weak_ptr，我们可以在不延长对象生命周期的前提下，检查对象是否仍然存在，并访问它。具体来说，weak_ptr 可以通过调用 lock() 方法来创建一个 shared_ptr，如果对象还存在（即引用计数大于零），则返回一个有效的 shared_ptr，否则返回空指针。\n控制块的扩展 为了支持std::weak_ptr， 我们需要扩展控制块的功能 ，使其能同时管理对象的引用计数（ref_count）和弱引用计数（weak_count），从而保持对对象的生命周期的正确管理。\ntemplate \u003ctypename T\u003e class control_block { public: control_block(T* ptr) : ref_count(1), weak_count(1), obj(ptr) {} // 增加引用计数 void add_ref() { ++ref_count; } // 增加引用计数 bool lock() { int prev = ref_count.load(); // 使用加载当前值，避免重复读取 while (prev \u003e 0 \u0026\u0026 !ref_count.compare_exchange_weak(prev, prev + 1)) { prev = ref_count.load(); // 如果失败，重新加载当前值 } return prev \u003e 0; // 如果 prev \u003e 0，表示锁定成功 } // 减少引用计数 void release_ref() { if (--ref_count == 0) { delete obj; // 删除对象 release_control_block(); // 尝试删除控制块 } } // 增加弱引用计数 void add_weak_ref() { ++weak_count; } // 减少弱引用计数 void release_weak_ref() { if (weak_count.fetch_sub(1) == 1) { delete this; // 删除控制块 } } T* get() { return obj; } private: // 删除控制块，只有在弱引用计数为0时才删除控制块 void release_control_block() { if (weak_count == 0) { delete this; // 删除控制块 } } std::atomic\u003cint\u003e ref_count; // 强引用计数 std::atomic\u003cint\u003e weak_count; // 弱引用计数 T* obj; // 实际对象 }; weak_ptr 的简化版实现 下面是一个简化版的 weak_ptr 实现，它与 shared_ptr 共享相同的控制块。weak_ptr 本身不增加引用计数，因此不会影响对象的生命周期。\ntemplate \u003ctypename T\u003e class my_weak_ptr { public: my_weak_ptr() : ctrl_block(nullptr) {} // 从 shared_ptr 构造 my_weak_ptr my_weak_ptr(const std::shared_ptr\u003cT\u003e\u0026 shared) : ctrl_block(shared.ctrl_block) { ctrl_block-\u003eadd_weak_ref(); } ~my_weak_ptr() { if (ctrl_block) { ctrl_block-\u003erelease_weak_ref(); } } // 尝试获取指向对象的 shared_ptr std::shared_ptr\u003cT\u003e lock() { return std::shared_ptr\u003cT\u003e(*this); } private: control_block\u003cT\u003e* ctrl_block; // 控制块 }; template \u003ctypename T\u003e class my_shared_ptr { private: T* ptr; control_block\u003cT\u003e* ctrl_block; public: // ... my_shared_ptr(const my_weak_ptr\u003cT\u003e\u0026 weak_ptr) { if (weak_ptr.ctrl_block \u0026\u0026 weak_ptr.ctrl_block-\u003elock()) { ptr = weak_ptr.ptr; ctrl_block = weak_ptr.ctrl_block(); } else { throw exception(\"bad weak ptr\"); } } // ... }; 理解并优化std::atomic操作 在上面的代码示例中，我们使用了std::atomic作为智能指针的引用计数。与直接使用int变量不同，std::atomic可以在多线程环境中正确地管理对同一智能指针的引用计数。\n然而，在上述代码中，我们仅使用了std::atomic的基本操作（如自增、自减和赋值等），这些操作默认使用memory_order_seq_cst内存序（稍后会讨论）。在多线程编程中，std::atomic提供了多种内存序（memory ordering）选项，用以控制操作的可见性和执行顺序，以确保数据一致性。不同的内存序策略决定了编译器和CPU对指令的重排序程度。\n开发者的目标是选择合适的内存序，优化程序性能，同时确保程序的正确性。\n内存序的核心概念 理解内存序的关键在于重排序和跨线程可见性：\n重排序（Reordering）\n编译器和CPU可能会重排指令，以优化性能。例如，它们可能会提前执行某些计算，或者将存储操作推迟执行。正确使用std::atomic可以防止某些关键操作被错误地重排序。\n可见性（Visibility）\n在多线程环境中，一个线程对变量的修改可能不会立即被其他线程看到，或者多个线程对同一变量的操作顺序可能不确定。原子操作的内存序决定了其他线程何时能看到这些修改。\n不同内存序的作用及使用场景 memory_order_relaxed（松散顺序，最低开销） 特点：不保证顺序，仅保证操作是原子的。 作用：确保同一std::atomic变量的读写操作是原子的，但不提供线程间的同步，不影响可见性或顺序。 适用场景：适用于数据竞争不影响程序正确性的场景，如无依赖的计数（统计线程数、事件计数等）。 示例\nstd::atomic\u003cint\u003e counter{0}; counter.fetch_add(1, std::memory_order_relaxed); // 仅保证原子性，不保证可见性 这里，fetch_add确保counter自增操作不会丢失，但不同线程的修改可能会被延迟看到。\nmemory_order_acquire（获取，防止重排序到前） 特点：保证当前线程在acquire之后的所有操作不会被重排序到acquire之前，因此，其他线程中相同原子变量的释放操作（release operation）之前的写入对当前线程是可见的。 适用场景：用于读取共享数据，确保当前线程能够看到其他线程之前对该变量的修改。 memory_order_release（释放，防止重排序到后） 特点：确保当前线程在release之前的所有操作不会被重排序到release之后，因此，当前操作所在线程之前的写入，在其他线程施加占有操作（acquire operation）之后是可见的。 适用场景：用于写入共享数据，确保其他线程能在acquire读取时看到修改。 示例\nstd::atomic\u003cint\u003e flag{0}; int data = 0; void producer() { data = 42; flag.store(1, std::memory_order_release); // 让消费者可以看到 data=42 } void consumer() { while (flag.load(std::memory_order_acquire) != 1); // 确保 data=42 可见 std::cout \u003c\u003c data \u003c\u003c std::endl; // 确保 data 的修改对本线程可见 } store(release)确保data=42发生在flag=1之前。 load(acquire)确保flag=1之后，data=42对消费者线程可见。 通过acquire-release，消费者线程能够正确看到生产者线程的data修改。 memory_order_acq_rel（获取-释放，双向同步） 特点：结合acquire和release，用于**读-改-写（Read-Modify-Write, RMW）**操作，确保： 读取时使用acquire语义，保证之前的修改对当前线程可见。 写入时使用release语义，保证当前修改对后续线程可见。 适用场景：用于读-改-写（如fetch_add()、exchange()）操作，确保多个线程能够正确协调。 示例\nstd::atomic\u003cint\u003e value{0}; value.fetch_add(1, std::memory_order_acq_rel); // 读写都保证可见性 在这里，fetch_add同时读取旧值并写入新值：\n读取时使用acquire语义，确保它能看到其他线程的修改。 写入时使用release语义，确保它的修改能被其他线程看到。 memory_order_seq_cst（顺序一致性，最严格） 特点：所有使用memory_order_seq_cst的原子操作在所有线程看来都是按照相同的顺序执行的，即全局一致的时序。 适用场景： 需要严格同步的场景，如锁、同步变量、临界区保护等。 适用于多线程交互复杂、难以管理依赖关系的情况。 保证：\nseq_cst确保所有操作严格按照全局统一顺序执行，避免乱序问题。 直观比喻 relaxed：随意写笔记，但不保证别人能看到。 acquire：进门检查公告栏，确保看到之前的通知。 release：离开时更新公告栏，让后来的人看到。 acq_rel：进门看公告 + 走前更新公告。 seq_cst：所有人按同样顺序写、看公告，保证一致性。 根据不同场景合理选择内存序，可以提高并发程序的正确性和性能。\n优化控制块中的原子变量 #include template \u003ctypename T\u003e class control_block { public: control_block(T* ptr) : ref_count(1), weak_count(1), obj(ptr) {} // 增加引用计数 void add_ref() { ref_count.fetch_add(1, std::memory_order_relaxed); } // 尝试增加强引用计数（仅当对象仍然存活时） bool lock() { int prev = ref_count.load(std::memory_order_acquire); while (prev \u003e 0) { if (ref_count.compare_exchange_weak(prev, prev + 1, std::memory_order_acquire, std::memory_order_relaxed)) { return true; // 成功锁定 } } return false; // 对象已被释放 } // 释放强引用 void release_ref() { if (ref_count.fetch_sub(1, std::memory_order_acq_rel) == 1) { delete obj; // 删除对象 release_control_block(); // 尝试删除控制块 } } // 增加弱引用计数 void add_weak_ref() { weak_count.fetch_add(1, std::memory_order_relaxed); } // 释放弱引用计数 void release_weak_ref() { if (weak_count.fetch_sub(1, std::memory_order_acq_rel) == 1) { delete this; // 删除控制块 } } T* get() { return obj; } private: // 删除控制块，仅当弱引用计数也归零时 void release_control_block() { if (weak_count.fetch_sub(1, std::memory_order_acq_rel) == 1) { delete this; // 删除控制块 } } std::atomic\u003cint\u003e ref_count; // 强引用计数 std::atomic\u003cint\u003e weak_count; // 弱引用计数 T* obj; // 实际对象 }; 参考 C++内存管理：shared_ptr/weak_ptr源码 当析构函数遇到多线程 ── C++ 中线程安全的对象回调 程序员的自我修养（⑫）：C++ 的内存顺序 ","wordCount":"4041","inLanguage":"zh-cn","datePublished":"2025-01-21T00:00:00Z","dateModified":"2025-01-21T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</h1><div class=post-meta><span title='2025-01-21 00:00:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><p>智能指针（如 <code>std::shared_ptr</code> 和 <code>std::weak_ptr</code>）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 <code>boost::shared_ptr</code> 和 <code>boost::weak_ptr</code>，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。</p><p>本文将围绕以下主题展开讨论：</p><ul><li>C++ 智能指针的实现原理</li><li>非侵入式智能指针与侵入式智能指针的区别</li><li>利用 <code>atomic</code> 避免多线程竞态条件</li><li>如何实现侵入式版本的 <code>shared_ptr</code> 和 <code>weak_ptr</code></li><li>采用 <code>concept</code> 约束模板类型</li><li>探讨完美转发（<code>std::forward&lt;T></code>）在智能指针中的应用</li></ul><h2 id=c-中的智能指针>C++ 中的智能指针<a hidden class=anchor aria-hidden=true href=#c-中的智能指针>#</a></h2><h3 id=stdshared_ptr的实现><code>std::shared_ptr</code>的实现<a hidden class=anchor aria-hidden=true href=#stdshared_ptr的实现>#</a></h3><p><code>std::shared_ptr</code> 是一种智能指针，能够自动管理对象的生命周期。它通过引用计数的方式来跟踪有多少个 <code>shared_ptr</code> 实例指向同一个对象，确保当最后一个 <code>shared_ptr</code> 被销毁时，对象的内存能够自动释放。</p><h4 id=引用计数与原子操作>引用计数与原子操作<a hidden class=anchor aria-hidden=true href=#引用计数与原子操作>#</a></h4><p><code>std::shared_ptr</code> 的核心机制是引用计数。每个 <code>shared_ptr</code> 会维护一个引用计数。当多个 <code>shared_ptr</code> 指向同一个对象时，计数器会增加；当一个 <code>shared_ptr</code> 被销毁时，计数器会减少。如果计数器归零，表明没有任何 <code>shared_ptr</code> 再指向该对象，这时对象会被删除。</p><p>引用计数通常由一个控制块（control block）管理。控制块不仅保存引用计数，还会保存对象本身以及与对象生命周期相关的其他信息。<code>std::shared_ptr</code> 的实现一般使用“非侵入式引用计数”（即不嵌入对象本身）。</p><p>示例代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>control_block</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    control_block(T<span style=color:#f92672>*</span> ptr)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ref_count(<span style=color:#ae81ff>1</span>), obj(ptr) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_ref</span>() { <span style=color:#f92672>++</span>ref_count; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 减少引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release_ref</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span>ref_count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> obj;  <span style=color:#75715e>// 删除对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>; <span style=color:#75715e>// 删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>get</span>() { <span style=color:#66d9ef>return</span> obj; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ref_count;    <span style=color:#75715e>// 引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>*</span> obj;                        <span style=color:#75715e>// 实际对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h4 id=简化版-shared_ptr-实现>简化版 <code>shared_ptr</code> 实现<a hidden class=anchor aria-hidden=true href=#简化版-shared_ptr-实现>#</a></h4><p>下面是一个简化版的 <code>shared_ptr</code> 实现示例。这个版本仍然有一些重要细节需要注意，比如原子操作和异常安全等问题，但可以帮助理解 <code>shared_ptr</code> 的基本原理：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>my_shared_ptr</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> ptr;
</span></span><span style=display:flex><span>    control_block<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> ctrl_block;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>explicit</span> my_shared_ptr(T<span style=color:#f92672>*</span> p <span style=color:#f92672>=</span> <span style=color:#66d9ef>nullptr</span>) 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ptr(p), ctrl_block(<span style=color:#66d9ef>new</span> control_block<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(p)) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 拷贝构造函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    my_shared_ptr(<span style=color:#66d9ef>const</span> my_shared_ptr<span style=color:#f92672>&amp;</span> other) 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ptr(other.ptr), ctrl_block(other.ctrl_block) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ctrl_block) {
</span></span><span style=display:flex><span>            ctrl_block<span style=color:#f92672>-&gt;</span>add_ref();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 析构函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#f92672>~</span>my_shared_ptr() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ctrl_block) {
</span></span><span style=display:flex><span>            ctrl_block<span style=color:#f92672>-&gt;</span>release_ref();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>-&gt;</span>() { <span style=color:#66d9ef>return</span> ptr; }
</span></span><span style=display:flex><span>    T<span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>operator</span><span style=color:#f92672>*</span>() { <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span>ptr; }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=stdweak_ptr的实现><code>std::weak_ptr</code>的实现<a hidden class=anchor aria-hidden=true href=#stdweak_ptr的实现>#</a></h3><p><code>std::weak_ptr</code> 是与 <code>std::shared_ptr</code> 配合使用的智能指针，它解决了 <code>shared_ptr</code> 在某些场景下的循环引用问题。</p><p>循环引用问题发生在两个或多个对象通过 <code>shared_ptr</code> 相互引用时，导致引用计数永远不为零，从而引发内存泄漏。为了避免这个问题，我们引入了 <code>weak_ptr</code>。</p><h4 id=为什么需要-weak_ptr>为什么需要 <code>weak_ptr</code><a hidden class=anchor aria-hidden=true href=#为什么需要-weak_ptr>#</a></h4><p><code>std::weak_ptr</code> 不增加引用计数，因此它不会影响对象的生命周期。当一个对象的所有 <code>shared_ptr</code> 被销毁后，<code>weak_ptr</code> 将变为“悬挂”状态。这与普通指针的“空悬指针”（dangling pointer）不同，空悬的 <code>weak_ptr</code> 会返回空指针 <code>nullptr</code>，表明该对象的生命周期已经结束。</p><p><code>weak_ptr</code> 提供了一种访问 <code>shared_ptr</code> 的方式，但并不控制对象的销毁，因此它可以有效避免循环引用问题。</p><p>通过 <code>weak_ptr</code>，我们可以在不延长对象生命周期的前提下，检查对象是否仍然存在，并访问它。具体来说，<code>weak_ptr</code> 可以通过调用 <code>lock()</code> 方法来创建一个 <code>shared_ptr</code>，如果对象还存在（即引用计数大于零），则返回一个有效的 <code>shared_ptr</code>，否则返回空指针。</p><h4 id=控制块的扩展>控制块的扩展<a hidden class=anchor aria-hidden=true href=#控制块的扩展>#</a></h4><p>为了支持<code>std::weak_ptr</code>， 我们需要扩展控制块的功能 ，使其能同时管理对象的引用计数（<code>ref_count</code>）和弱引用计数（<code>weak_count</code>），从而保持对对象的生命周期的正确管理。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>control_block</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    control_block(T<span style=color:#f92672>*</span> ptr)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ref_count(<span style=color:#ae81ff>1</span>), weak_count(<span style=color:#ae81ff>1</span>), obj(ptr) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_ref</span>() { <span style=color:#f92672>++</span>ref_count; }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>lock</span>() { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> prev <span style=color:#f92672>=</span> ref_count.load();  <span style=color:#75715e>// 使用加载当前值，避免重复读取
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (prev <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>ref_count.compare_exchange_weak(prev, prev <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)) {
</span></span><span style=display:flex><span>            prev <span style=color:#f92672>=</span> ref_count.load();   <span style=color:#75715e>// 如果失败，重新加载当前值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> prev <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>;  <span style=color:#75715e>// 如果 prev &gt; 0，表示锁定成功
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 减少引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release_ref</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>--</span>ref_count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> obj;  <span style=color:#75715e>// 删除对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            release_control_block(); <span style=color:#75715e>// 尝试删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_weak_ref</span>() { <span style=color:#f92672>++</span>weak_count; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 减少弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release_weak_ref</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (weak_count.fetch_sub(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>; <span style=color:#75715e>// 删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>get</span>() { <span style=color:#66d9ef>return</span> obj; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 删除控制块，只有在弱引用计数为0时才删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> release_control_block() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (weak_count <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>; <span style=color:#75715e>// 删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ref_count;    <span style=color:#75715e>// 强引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> weak_count;   <span style=color:#75715e>// 弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>*</span> obj;                        <span style=color:#75715e>// 实际对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h4 id=weak_ptr-的简化版实现><code>weak_ptr</code> 的简化版实现<a hidden class=anchor aria-hidden=true href=#weak_ptr-的简化版实现>#</a></h4><p>下面是一个简化版的 <code>weak_ptr</code> 实现，它与 <code>shared_ptr</code> 共享相同的控制块。<code>weak_ptr</code> 本身不增加引用计数，因此不会影响对象的生命周期。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>my_weak_ptr</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    my_weak_ptr() <span style=color:#f92672>:</span> ctrl_block(<span style=color:#66d9ef>nullptr</span>) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 从 shared_ptr 构造 my_weak_ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    my_weak_ptr(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> shared)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ctrl_block(shared.ctrl_block) {
</span></span><span style=display:flex><span>        ctrl_block<span style=color:#f92672>-&gt;</span>add_weak_ref();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>~</span>my_weak_ptr() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ctrl_block) {
</span></span><span style=display:flex><span>            ctrl_block<span style=color:#f92672>-&gt;</span>release_weak_ref();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 尝试获取指向对象的 shared_ptr
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> lock() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>(<span style=color:#f92672>*</span><span style=color:#66d9ef>this</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    control_block<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> ctrl_block; <span style=color:#75715e>// 控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>my_shared_ptr</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> ptr;
</span></span><span style=display:flex><span>    control_block<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;*</span> ctrl_block;
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    my_shared_ptr(<span style=color:#66d9ef>const</span> my_weak_ptr<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;&amp;</span> weak_ptr) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (weak_ptr.ctrl_block <span style=color:#f92672>&amp;&amp;</span> weak_ptr.ctrl_block<span style=color:#f92672>-&gt;</span>lock()) {
</span></span><span style=display:flex><span>            ptr <span style=color:#f92672>=</span> weak_ptr.ptr;
</span></span><span style=display:flex><span>            ctrl_block <span style=color:#f92672>=</span> weak_ptr.ctrl_block();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#a6e22e>exception</span>(<span style=color:#e6db74>&#34;bad weak ptr&#34;</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=理解并优化stdatomict操作>理解并优化<code>std::atomic&lt;T></code>操作<a hidden class=anchor aria-hidden=true href=#理解并优化stdatomict操作>#</a></h2><p>在上面的代码示例中，我们使用了<code>std::atomic&lt;int></code>作为智能指针的引用计数。与直接使用<code>int</code>变量不同，<code>std::atomic&lt;int></code>可以在多线程环境中正确地管理对同一智能指针的引用计数。</p><p>然而，在上述代码中，我们仅使用了<code>std::atomic&lt;int></code>的基本操作（如自增、自减和赋值等），这些操作默认使用<code>memory_order_seq_cst</code>内存序（稍后会讨论）。在多线程编程中，<code>std::atomic&lt;T></code>提供了多种内存序（memory ordering）选项，用以控制操作的可见性和执行顺序，以确保数据一致性。不同的内存序策略决定了编译器和CPU对指令的重排序程度。</p><p>开发者的目标是选择合适的内存序，优化程序性能，同时确保程序的正确性。</p><h3 id=内存序的核心概念>内存序的核心概念<a hidden class=anchor aria-hidden=true href=#内存序的核心概念>#</a></h3><p>理解内存序的关键在于<strong>重排序</strong>和<strong>跨线程可见性</strong>：</p><ol><li><p><strong>重排序（Reordering）</strong><br>编译器和CPU可能会重排指令，以优化性能。例如，它们可能会提前执行某些计算，或者将存储操作推迟执行。正确使用<code>std::atomic</code>可以防止某些关键操作被错误地重排序。</p></li><li><p><strong>可见性（Visibility）</strong><br>在多线程环境中，一个线程对变量的修改可能不会立即被其他线程看到，或者多个线程对同一变量的操作顺序可能不确定。原子操作的内存序决定了其他线程何时能看到这些修改。</p></li></ol><h3 id=不同内存序的作用及使用场景>不同内存序的作用及使用场景<a hidden class=anchor aria-hidden=true href=#不同内存序的作用及使用场景>#</a></h3><h4 id=memory_order_relaxed松散顺序最低开销><code>memory_order_relaxed</code>（松散顺序，最低开销）<a hidden class=anchor aria-hidden=true href=#memory_order_relaxed松散顺序最低开销>#</a></h4><ul><li><strong>特点</strong>：不保证顺序，仅保证操作是<strong>原子的</strong>。</li><li><strong>作用</strong>：确保同一<code>std::atomic&lt;T></code>变量的读写操作是原子的，但不提供线程间的同步，不影响可见性或顺序。</li><li><strong>适用场景</strong>：适用于<strong>数据竞争不影响程序正确性</strong>的场景，如<strong>无依赖的计数</strong>（统计线程数、事件计数等）。</li></ul><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> counter{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>counter.fetch_add(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_relaxed);  <span style=color:#75715e>// 仅保证原子性，不保证可见性
</span></span></span></code></pre></div><p>这里，<code>fetch_add</code>确保<code>counter</code>自增操作不会丢失，但不同线程的修改可能会被延迟看到。</p><h4 id=memory_order_acquire获取防止重排序到前><code>memory_order_acquire</code>（获取，防止重排序到前）<a hidden class=anchor aria-hidden=true href=#memory_order_acquire获取防止重排序到前>#</a></h4><ul><li><strong>特点</strong>：保证<strong>当前线程</strong>在<code>acquire</code>之后的所有操作不会被重排序到<code>acquire</code>之前，因此，其他线程中相同原子变量的释放操作（release operation）之前的写入对当前线程是可见的。</li><li><strong>适用场景</strong>：用于<strong>读取</strong>共享数据，确保当前线程能够看到其他线程之前对该变量的修改。</li></ul><h4 id=memory_order_release释放防止重排序到后><code>memory_order_release</code>（释放，防止重排序到后）<a hidden class=anchor aria-hidden=true href=#memory_order_release释放防止重排序到后>#</a></h4><ul><li><strong>特点</strong>：确保<strong>当前线程</strong>在<code>release</code>之前的所有操作不会被重排序到<code>release</code>之后，因此，当前操作所在线程之前的写入，在其他线程施加占有操作（acquire operation）之后是可见的。</li><li><strong>适用场景</strong>：用于<strong>写入</strong>共享数据，确保其他线程能在<code>acquire</code>读取时看到修改。</li></ul><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> flag{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> data <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>producer</span>() {
</span></span><span style=display:flex><span>  data <span style=color:#f92672>=</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>  flag.store(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_release);  <span style=color:#75715e>// 让消费者可以看到 data=42
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>consumer</span>() {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (flag.load(std<span style=color:#f92672>::</span>memory_order_acquire) <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span>);  <span style=color:#75715e>// 确保 data=42 可见
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> data <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;  <span style=color:#75715e>// 确保 data 的修改对本线程可见
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><ul><li><code>store(release)</code>确保<code>data=42</code>发生在<code>flag=1</code>之前。</li><li><code>load(acquire)</code>确保<code>flag=1</code>之后，<code>data=42</code>对消费者线程可见。</li><li>通过<code>acquire-release</code>，消费者线程能够正确看到生产者线程的<code>data</code>修改。</li></ul><h4 id=memory_order_acq_rel获取-释放双向同步><code>memory_order_acq_rel</code>（获取-释放，双向同步）<a hidden class=anchor aria-hidden=true href=#memory_order_acq_rel获取-释放双向同步>#</a></h4><ul><li><strong>特点</strong>：结合<code>acquire</code>和<code>release</code>，用于**读-改-写（Read-Modify-Write, RMW）**操作，确保：<ul><li>读取时使用<code>acquire</code>语义，保证之前的修改对当前线程可见。</li><li>写入时使用<code>release</code>语义，保证当前修改对后续线程可见。</li></ul></li><li><strong>适用场景</strong>：用于<strong>读-改-写</strong>（如<code>fetch_add()</code>、<code>exchange()</code>）操作，确保多个线程能够正确协调。</li></ul><p><strong>示例</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> value{<span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>value.fetch_add(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_acq_rel);  <span style=color:#75715e>// 读写都保证可见性
</span></span></span></code></pre></div><p>在这里，<code>fetch_add</code>同时读取旧值并写入新值：</p><ul><li>读取时使用<code>acquire</code>语义，确保它能看到其他线程的修改。</li><li>写入时使用<code>release</code>语义，确保它的修改能被其他线程看到。</li></ul><h4 id=memory_order_seq_cst顺序一致性最严格><code>memory_order_seq_cst</code>（顺序一致性，最严格）<a hidden class=anchor aria-hidden=true href=#memory_order_seq_cst顺序一致性最严格>#</a></h4><ul><li><strong>特点</strong>：所有使用<code>memory_order_seq_cst</code>的原子操作在<strong>所有线程看来</strong>都是按照相同的顺序执行的，即全局一致的时序。</li><li><strong>适用场景</strong>：<ul><li>需要严格同步的场景，如<strong>锁</strong>、<strong>同步变量</strong>、<strong>临界区保护</strong>等。</li><li>适用于<strong>多线程交互复杂</strong>、难以管理依赖关系的情况。</li></ul></li></ul><p><strong>保证</strong>：</p><ul><li><code>seq_cst</code>确保所有操作严格按照全局统一顺序执行，避免乱序问题。</li></ul><h3 id=直观比喻>直观比喻<a hidden class=anchor aria-hidden=true href=#直观比喻>#</a></h3><ul><li><code>relaxed</code>：随意写笔记，但不保证别人能看到。</li><li><code>acquire</code>：<strong>进门检查公告栏</strong>，确保看到之前的通知。</li><li><code>release</code>：<strong>离开时更新公告栏</strong>，让后来的人看到。</li><li><code>acq_rel</code>：<strong>进门看公告 + 走前更新公告</strong>。</li><li><code>seq_cst</code>：<strong>所有人按同样顺序写、看公告</strong>，保证一致性。</li></ul><p>根据不同场景合理选择内存序，可以提高并发程序的正确性和性能。</p><h3 id=优化控制块中的原子变量>优化控制块中的原子变量<a hidden class=anchor aria-hidden=true href=#优化控制块中的原子变量>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;atomic&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>control_block</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    control_block(T<span style=color:#f92672>*</span> ptr)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> ref_count(<span style=color:#ae81ff>1</span>), weak_count(<span style=color:#ae81ff>1</span>), obj(ptr) {}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_ref</span>() {
</span></span><span style=display:flex><span>        ref_count.fetch_add(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 尝试增加强引用计数（仅当对象仍然存活时）
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>lock</span>() { 
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> prev <span style=color:#f92672>=</span> ref_count.load(std<span style=color:#f92672>::</span>memory_order_acquire);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (prev <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (ref_count.compare_exchange_weak(prev, prev <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, 
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>memory_order_acquire, std<span style=color:#f92672>::</span>memory_order_relaxed)) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> true; <span style=color:#75715e>// 成功锁定
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false; <span style=color:#75715e>// 对象已被释放
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 释放强引用
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release_ref</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (ref_count.fetch_sub(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_acq_rel) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> obj;  <span style=color:#75715e>// 删除对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            release_control_block(); <span style=color:#75715e>// 尝试删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 增加弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>add_weak_ref</span>() {
</span></span><span style=display:flex><span>        weak_count.fetch_add(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_relaxed);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 释放弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>release_weak_ref</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (weak_count.fetch_sub(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_acq_rel) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>; <span style=color:#75715e>// 删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    T<span style=color:#f92672>*</span> <span style=color:#a6e22e>get</span>() { <span style=color:#66d9ef>return</span> obj; }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 删除控制块，仅当弱引用计数也归零时
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>void</span> release_control_block() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (weak_count.fetch_sub(<span style=color:#ae81ff>1</span>, std<span style=color:#f92672>::</span>memory_order_acq_rel) <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>delete</span> <span style=color:#66d9ef>this</span>; <span style=color:#75715e>// 删除控制块
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> ref_count;    <span style=color:#75715e>// 强引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>atomic<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> weak_count;   <span style=color:#75715e>// 弱引用计数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    T<span style=color:#f92672>*</span> obj;                        <span style=color:#75715e>// 实际对象
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>};
</span></span></code></pre></div><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://zhuanlan.zhihu.com/p/532215950>C++内存管理：shared_ptr/weak_ptr源码</a></li><li><a href=https://www.cnblogs.com/Solstice/archive/2010/02/10/dtor_meets_threads.html>当析构函数遇到多线程 ── C++ 中线程安全的对象回调</a></li><li><a href=https://liam.page/2021/12/11/memory-order-cpp-02/>程序员的自我修养（⑫）：C++ 的内存顺序</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/cpp/>Cpp</a></li><li><a href=https://wizmann.top/tags/modern-cpp/>Modern Cpp</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/lava-store/><span class=title>«</span><br><span>论文阅读：LavaStore - 高性能、本地存储引擎的演进</span>
</a><a class=next href=https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/><span class=title>»</span><br><span>std::visit实现运行时多态 - C++ for the Antiquated（之三）</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>