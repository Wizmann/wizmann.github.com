<!doctype html><html lang=zh-CN dir=ltr><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://wizmann.top/ style=color:inherit>Maerlyn's Rainbow</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/><span itemprop=name></span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>动手实现std::visit - C++ for the Antiquated（之二）</h1><time class=dim datetime=2025-01-01T00:00:00+00:00>January 1, 2025</time><div class=term-container><div class=tag><a href=https://wizmann.top/tags/cpp/>#cpp</a></div><div class=tag><a href=https://wizmann.top/tags/modern-cpp/>#modern cpp</a></div></ol></div><section class=page-section><h2 id=stdvariant-与-stdvisit>std::variant 与 std::visit</h2><h3 id=stdvariant>std::variant</h3><p><code>std::variant</code> 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 <code>union</code> 不同，<code>std::variant</code> 能够在运行时安全地检查当前存储的类型，避免未定义行为。</p><p>其核心特点如下：</p><ul><li>类型安全：访问值时进行类型检查，防止类型错误。</li><li>固定类型集合：存储类型在编译时确定。</li><li>异常安全：在赋值失败时会进入无效状态（std::monostate）。</li></ul><h3 id=stdvisit>std::visit</h3><p><code>std::visit</code> 是一个访问器函数，用于访问 <code>std::variant</code> 中当前存储的值。它通过一个可调用对象（如 Lambda 表达式）来处理存储的值，从而实现编译时多态。</p><p>其核心特点如下：</p><ul><li>统一访问接口：无论存储的是哪种类型，都可以通过同一个函数进行访问。</li><li>类型安全：确保所有可能的类型都被正确处理。</li></ul><h3 id=代码示例>代码示例</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;type_traits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> always_false_v <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>float</span>, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> items {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>3.14f</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;foobar&#34;</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> item : items) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>visit([](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> arg) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> T <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(arg)<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;int: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;float: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;std::string: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>static_assert</span>(always_false_v<span style=color:#f92672>&lt;&gt;</span>, <span style=color:#e6db74>&#34;Unhandled type!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, item);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码分析>代码分析</h3><ol><li><p><strong><code>std::variant&lt;int, float, std::string></code></strong></p><ul><li>这是一个类型安全的联合体，可以存储 <code>int</code>、<code>float</code> 或 <code>std::string</code> 中的任意一种类型。</li><li>将多个 <code>std::variant</code> 存储在 <code>std::vector</code> 中，形成一个统一的容器。</li></ul></li><li><p><strong><code>std::visit</code></strong></p><ul><li>使用 <code>std::visit</code> 访问每个 <code>std::variant</code> 元素。</li><li>传入一个<strong>泛型 Lambda 表达式</strong>，通过 <code>if constexpr</code> 在编译时分发到不同的分支，处理不同类型的值。</li></ul></li><li><p><strong><code>if constexpr</code> 与 <code>std::is_same_v</code></strong></p><ul><li>使用 <code>std::is_same_v</code> 判断存储的实际类型。</li><li>根据类型进行不同的输出操作。</li></ul></li><li><p><strong>类型安全</strong></p><ul><li>如果添加一个未处理的类型，编译器会在 <code>static_assert</code> 中报错，提醒开发者补充处理逻辑。</li></ul></li></ol><h2 id=使用传统c实现stdvisit>使用传统C++实现std::visit</h2><h3 id=实现stdvariant>实现std::variant</h3><p>在传统 C++ 中，我们只有简单的 <code>union</code> 来实现“联合体”语义。然而，<code>union</code> 存在一些局限性：</p><ul><li>无法存储非平凡类型（例如 <code>std::string</code>）。</li><li>无法跟踪当前存储的类型。</li><li>无法进行类型安全检查。</li></ul><p>而 <code>std::variant</code> 通过类型索引和类型匹配来提供类型安全，支持多种类型的存储与访问。</p><h3 id=实现-stdvisit>实现 std::visit</h3><p>实现 <code>std::visit</code> 需要使用一个可调用对象（例如 Visitor）来访问 <code>std::variant</code> 中的值。具体来说，它在编译时根据实际类型匹配相应的 <code>operator()</code> 方法。</p><p>示例代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;type_traits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Visitor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;int: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;float: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;string: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>float</span>, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> item(<span style=color:#ae81ff>114.514f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前类型的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> item.index() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 1 (float 的索引)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前存储的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 114.514
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>bad_variant_access<span style=color:#f92672>&amp;</span> e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 类型不匹配，抛出异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 Visitor 访问值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>visit(Visitor{}, item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 1 (float 类型返回 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现的核心要点>实现的核心要点</h3><p>实现 <code>std::visit</code> 的关键在于以下几个方面：</p><ul><li><p><strong>类型索引 (<code>index()</code>)</strong><br>根据传入的 <code>std::variant</code> 参数类型，确定其在类型集合中的索引。</p></li><li><p><strong>类型访问 (<code>std::get&lt;T></code>)</strong><br>根据传入的模板类型 <code>T</code>，获取存储的值。如果类型不匹配，抛出异常，确保类型安全。</p></li><li><p><strong>类型分派 (<code>std::visit</code>)</strong><br>根据当前存储的类型，调用 <code>Visitor</code> 中对应的 <code>operator()</code> 方法。可以通过 <code>switch-case</code> 或模板匹配来实现类型分发。</p></li></ul><h3 id=代码实现0---基本框架>代码实现0 - 基本框架</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyVariant</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    MyVariant(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>        setValue(item);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> setValue(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用于存储“联合体”的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>union</span> <span style=color:#a6e22e>Storage</span> {
</span></span><span style=display:flex><span>        Storage() {}
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>Storage() {}
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>aligned_union_t<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>, Ts...<span style=color:#f92672>&gt;</span> data;
</span></span><span style=display:flex><span>    } storage;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=代码实现1---index函数>代码实现1 - index()函数</h3><p>我们使用经典的模板递归来查找类型对应的索引。同时，利用 <code>constexpr</code> 来简化编译时计算的过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t N, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TupleElement <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>tuple_element<span style=color:#f92672>&lt;</span>N, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>Types...<span style=color:#f92672>&gt;&gt;::</span>type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span> First, <span style=color:#66d9ef>typename</span>... Rest<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span><span style=color:#f92672>&lt;</span>T, First, Rest...<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>is_same<span style=color:#f92672>&lt;</span>T, First<span style=color:#f92672>&gt;::</span>value 
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> (TypeIndex<span style=color:#f92672>&lt;</span>T, Rest...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> TypeIndex<span style=color:#f92672>&lt;</span>T, Rest...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> containsType() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TypeIndex<span style=color:#f92672>&lt;</span>T, Ts...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过上述代码，我们实现了在编译期确定传入类型对应的类型索引。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>setValue(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> TargetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static_assert</span>(containsType<span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>&gt;</span>(), <span style=color:#e6db74>&#34;Type not supported&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> (<span style=color:#f92672>&amp;</span>storage.data) TargetType(item);
</span></span><span style=display:flex><span>    typeIndex <span style=color:#f92672>=</span> getTypeIndex<span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码实现2---get-函数>代码实现2 - <code>get()</code> 函数</h3><p>我们实现了一个函数 <code>MyVariant::get()</code>，通过检查 <code>typeIndex</code> 来确保获取的类型与存储类型一致。</p><p>我们也能可以通过<code>MyGet</code>函数模拟<code>std::get&lt;T></code>函数的行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyVariant</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>&amp;</span> MyGet(MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;&amp;</span> var) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> var.<span style=color:#66d9ef>template</span> get<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>&amp;</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>get() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> TargetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (TypeIndex<span style=color:#f92672>&lt;</span>T, Ts...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>!=</span> typeIndex) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Wrong type&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>*&gt;</span>(<span style=color:#f92672>&amp;</span>storage.data);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码实现3---visit函数>代码实现3 - <code>visit</code>函数</h3><p>接下来是 <code>visit()</code> 函数的实现。它通过递归方式依次访问 <code>std::variant</code> 中的每种类型，并调用与之对应的处理函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t N, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TupleElement <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>tuple_element<span style=color:#f92672>&lt;</span>N, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>Types...<span style=color:#f92672>&gt;&gt;::</span>type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> TVisitor<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visit(TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> FirstType <span style=color:#f92672>=</span> TupleElement<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>, Ts...<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> RetT <span style=color:#f92672>=</span> <span style=color:#66d9ef>decltype</span>(visitor(std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>FirstType<span style=color:#f92672>&gt;</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> visitImpl<span style=color:#f92672>&lt;</span>RetT, TVisitor, Ts...<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>TVisitor<span style=color:#f92672>&gt;</span>(visitor));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> RetT, <span style=color:#66d9ef>typename</span> TVisitor, <span style=color:#66d9ef>typename</span> First, <span style=color:#66d9ef>typename</span>... Rest<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>RetT MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visitImpl(TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (getTypeIndex<span style=color:#f92672>&lt;</span>First<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> typeIndex) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>visitor</span>(get<span style=color:#f92672>&lt;</span>First<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 递归访问剩余的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> visitImpl<span style=color:#f92672>&lt;</span>RetT, TVisitor, Rest...<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>TVisitor<span style=color:#f92672>&gt;</span>(visitor));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> RetT, <span style=color:#66d9ef>typename</span> TVisitor<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>RetT MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visitImpl(<span style=color:#a6e22e>[[maybe_unused]]</span>TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 基础情况：所有类型都已检查，未找到匹配的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Wrong type&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结</h2><p>在本文中，我们实现了一个简单版的 <code>std::variant</code> 和 <code>std::visit</code>，通过传统 C++ 实现了类型安全的联合体数据结构。我们依次通过以下步骤构建了这一系统：</p><ol><li><p><strong><code>MyVariant</code> 类的基本框架</strong>：通过联合体 (<code>union</code>) 存储不同类型的数据，并使用模板构造函数动态设置值。</p></li><li><p><strong>类型索引 (<code>index()</code>) 的实现</strong>：使用模板递归技术结合 <code>constexpr</code> 来实现类型的编译时索引查找，从而在运行时根据类型索引来访问对应的值。</p></li><li><p><strong><code>get()</code> 函数</strong>：实现了获取存储值的函数，并通过类型检查确保类型安全。如果访问了错误类型的数据，则抛出异常。</p></li><li><p><strong><code>visit()</code> 函数</strong>：实现了一个可扩展的访问机制，使得不同类型的值可以通过同一个 <code>Visitor</code> 被访问和处理。通过递归的方式，系统能够动态地访问不同类型的值，并调用相应的处理函数。</p></li></ol><p>通过这些实现，我们成功模拟了 C++ 标准库中的 <code>std::variant</code> 和 <code>std::visit</code> 功能。同时，通过对比可以看出，现代 C++ 提供了更强大的模板元编程能力。利用这些特性，我们能够使用更直观的语法，在编译期间实现高效且类型安全的联合体访问，从而提供一种灵活、类型安全的方式来处理多类型数据。</p></section></main><footer id=main-footer><div class=footer><a href=#></a><div class=footer-copyright><div class=dim>© 2025</div><div></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>2102 </span><span>9 - 11</span></div><h3></h3><nav id=TableOfContents><ul><li><a href=#stdvariant-与-stdvisit>std::variant 与 std::visit</a><ul><li><a href=#stdvariant>std::variant</a></li><li><a href=#stdvisit>std::visit</a></li><li><a href=#代码示例>代码示例</a></li><li><a href=#代码分析>代码分析</a></li></ul></li><li><a href=#使用传统c实现stdvisit>使用传统C++实现std::visit</a><ul><li><a href=#实现stdvariant>实现std::variant</a></li><li><a href=#实现-stdvisit>实现 std::visit</a></li><li><a href=#实现的核心要点>实现的核心要点</a></li><li><a href=#代码实现0---基本框架>代码实现0 - 基本框架</a></li><li><a href=#代码实现1---index函数>代码实现1 - index()函数</a></li><li><a href=#代码实现2---get-函数>代码实现2 - <code>get()</code> 函数</a></li><li><a href=#代码实现3---visit函数>代码实现3 - <code>visit</code>函数</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav><h3></h3><ul><li><a href=/posts/constexpr-cpp-for-the-antiquated-1/>constexpr详解 - C++ for the Antiquated（之一）</a></li><li><a href=/posts/cache-coherence-and-memory-order-2/>CPU缓存一致性与内存一致性（第二部分-内存一致性）</a></li><li><a href=/posts/cache-coherence-and-memory-order/>CPU缓存一致性与内存一致性（第一部分-MESI协议）</a></li><li><a href=/posts/read-paper-barrier/>内存屏障初探</a></li><li><a href=/posts/alloca-vs-placement-new/>alloca vs placement new</a></li></ul></aside></div></div></body></html>