<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>动手实现std::visit - C++ for the Antiquated（之二） | Maerlyn's Rainbow</title>
<meta name=keywords content="cpp,modern cpp"><meta name=description content="std::variant 与 std::visit
std::variant
std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="动手实现std::visit - C++ for the Antiquated（之二）"><meta property="og:description" content="std::variant 与 std::visit std::variant std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-01T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-01T00:00:00+00:00"><meta property="article:tag" content="Cpp"><meta property="article:tag" content="Modern Cpp"><meta name=twitter:card content="summary"><meta name=twitter:title content="动手实现std::visit - C++ for the Antiquated（之二）"><meta name=twitter:description content="std::variant 与 std::visit
std::variant
std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"动手实现std::visit - C++ for the Antiquated（之二）","item":"https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"动手实现std::visit - C++ for the Antiquated（之二）","name":"动手实现std::visit - C\u002b\u002b for the Antiquated（之二）","description":"std::variant 与 std::visit std::variant std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。\n","keywords":["cpp","modern cpp"],"articleBody":"std::variant 与 std::visit std::variant std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。\n其核心特点如下：\n类型安全：访问值时进行类型检查，防止类型错误。 固定类型集合：存储类型在编译时确定。 异常安全：在赋值失败时会进入无效状态（std::monostate）。 std::visit std::visit 是一个访问器函数，用于访问 std::variant 中当前存储的值。它通过一个可调用对象（如 Lambda 表达式）来处理存储的值，从而实现编译时多态。\n其核心特点如下：\n统一访问接口：无论存储的是哪种类型，都可以通过同一个函数进行访问。 类型安全：确保所有可能的类型都被正确处理。 代码示例 #include #include #include #include template\u003ctypename T\u003e inline constexpr bool always_false_v = false; int main() { std::vector\u003cstd::variant\u003cint, float, std::string\u003e\u003e items { 10, 3.14f, \"foobar\" }; for (const auto\u0026 item : items) { std::visit([](const auto\u0026 arg) { using T = std::decay_t\u003cdecltype(arg)\u003e; if constexpr (std::is_same_v\u003cT, int\u003e) { std::cout \u003c\u003c \"int: \" \u003c\u003c arg \u003c\u003c std::endl; } else if constexpr (std::is_same_v\u003cT, float\u003e) { std::cout \u003c\u003c \"float: \" \u003c\u003c arg \u003c\u003c std::endl; } else if constexpr (std::is_same_v\u003cT, std::string\u003e) { std::cout \u003c\u003c \"std::string: \" \u003c\u003c arg \u003c\u003c std::endl; } else { static_assert(always_false_v\u003c\u003e, \"Unhandled type!\"); } }, item); } return 0; } 代码分析 std::variant\n这是一个类型安全的联合体，可以存储 int、float 或 std::string 中的任意一种类型。 将多个 std::variant 存储在 std::vector 中，形成一个统一的容器。 std::visit\n使用 std::visit 访问每个 std::variant 元素。 传入一个泛型 Lambda 表达式，通过 if constexpr 在编译时分发到不同的分支，处理不同类型的值。 if constexpr 与 std::is_same_v\n使用 std::is_same_v 判断存储的实际类型。 根据类型进行不同的输出操作。 类型安全\n如果添加一个未处理的类型，编译器会在 static_assert 中报错，提醒开发者补充处理逻辑。 使用传统C++实现std::visit 实现std::variant 在传统 C++ 中，我们只有简单的 union 来实现“联合体”语义。然而，union 存在一些局限性：\n无法存储非平凡类型（例如 std::string）。 无法跟踪当前存储的类型。 无法进行类型安全检查。 而 std::variant 通过类型索引和类型匹配来提供类型安全，支持多种类型的存储与访问。\n实现 std::visit 实现 std::visit 需要使用一个可调用对象（例如 Visitor）来访问 std::variant 中的值。具体来说，它在编译时根据实际类型匹配相应的 operator() 方法。\n示例代码如下：\n#include #include #include #include struct Visitor { int operator()(const int\u0026 item) const { std::cout \u003c\u003c \"int: \" \u003c\u003c item \u003c\u003c std::endl; return 0; } int operator()(const float\u0026 item) const { std::cout \u003c\u003c \"float: \" \u003c\u003c item \u003c\u003c std::endl; return 1; } int operator()(const std::string\u0026 item) const { std::cout \u003c\u003c \"string: \" \u003c\u003c item \u003c\u003c std::endl; return 2; } }; int main() { std::variant\u003cint, float, std::string\u003e item(114.514f); // 获取当前类型的索引 std::cout \u003c\u003c item.index() \u003c\u003c std::endl; // 输出: 1 (float 的索引) // 获取当前存储的值 std::cout \u003c\u003c std::get\u003cfloat\u003e(item) \u003c\u003c std::endl; // 输出: 114.514 try { std::cout \u003c\u003c std::get\u003cint\u003e(item) \u003c\u003c std::endl; } catch (const std::bad_variant_access\u0026 e) { std::cout \u003c\u003c e.what() \u003c\u003c std::endl; // 类型不匹配，抛出异常 } // 使用 Visitor 访问值 std::cout \u003c\u003c std::visit(Visitor{}, item) \u003c\u003c std::endl; // 输出: 1 (float 类型返回 1) return 0; } 实现的核心要点 实现 std::visit 的关键在于以下几个方面：\n类型索引 (index())\n根据传入的 std::variant 参数类型，确定其在类型集合中的索引。\n类型访问 (std::get)\n根据传入的模板类型 T，获取存储的值。如果类型不匹配，抛出异常，确保类型安全。\n类型分派 (std::visit)\n根据当前存储的类型，调用 Visitor 中对应的 operator() 方法。可以通过 switch-case 或模板匹配来实现类型分发。\n代码实现0 - 基本框架 template \u003ctypename... Ts\u003e class MyVariant { public: template \u003ctypename T\u003e MyVariant(const T\u0026 item) { setValue(item); } private: template \u003ctypename T\u003e void setValue(const T\u0026 item) { // TODO } // 用于存储“联合体”的数据 union Storage { Storage() {} ~Storage() {} std::aligned_union_t\u003c0, Ts...\u003e data; } storage; }; 代码实现1 - index()函数 我们使用经典的模板递归来查找类型对应的索引。同时，利用 constexpr 来简化编译时计算的过程。\ntemplate \u003cstd::size_t N, typename... Types\u003e using TupleElement = typename std::tuple_element\u003cN, std::tuple\u003cTypes...\u003e\u003e::type; template \u003ctypename T, typename... Types\u003e struct TypeIndex; template \u003ctypename T, typename First, typename... Rest\u003e struct TypeIndex\u003cT, First, Rest...\u003e { static constexpr int value = std::is_same\u003cT, First\u003e::value ? 0 : (TypeIndex\u003cT, Rest...\u003e::value == -1 ? -1 : TypeIndex\u003cT, Rest...\u003e::value + 1); }; template \u003ctypename T\u003e struct TypeIndex\u003cT\u003e { static constexpr int value = -1; }; template \u003ctypename T, typename... Ts\u003e constexpr bool containsType() { return TypeIndex\u003cT, Ts...\u003e::value != -1; } 通过上述代码，我们实现了在编译期确定传入类型对应的类型索引。\ntemplate \u003ctypename... Ts\u003e template \u003ctypename T\u003e void MyVariant\u003cTs...\u003e::setValue(const T\u0026 item) { using TargetType = std::decay_t\u003cT\u003e; static_assert(containsType\u003cTargetType\u003e(), \"Type not supported\"); new (\u0026storage.data) TargetType(item); typeIndex = getTypeIndex\u003cTargetType\u003e(); } 代码实现2 - get() 函数 我们实现了一个函数 MyVariant::get()，通过检查 typeIndex 来确保获取的类型与存储类型一致。\n我们也能可以通过MyGet函数模拟std::get函数的行为。\ntemplate \u003ctypename... Ts\u003e class MyVariant; template \u003ctypename T, typename... Ts\u003e T\u0026 MyGet(MyVariant\u003cTs...\u003e\u0026 var) { return var.template get\u003cT\u003e(); } template \u003ctypename... Ts\u003e template \u003ctypename T\u003e T\u0026 MyVariant\u003cTs...\u003e::get() { using TargetType = std::decay_t\u003cT\u003e; if (TypeIndex\u003cT, Ts...\u003e::value != typeIndex) { throw std::runtime_error(\"Wrong type\"); } return *reinterpret_cast\u003cTargetType*\u003e(\u0026storage.data); } 代码实现3 - visit函数 接下来是 visit() 函数的实现。它通过递归方式依次访问 std::variant 中的每种类型，并调用与之对应的处理函数。\ntemplate \u003cstd::size_t N, typename... Types\u003e using TupleElement = typename std::tuple_element\u003cN, std::tuple\u003cTypes...\u003e\u003e::type; template \u003ctypename... Ts\u003e template \u003ctypename TVisitor\u003e auto MyVariant\u003cTs...\u003e::visit(TVisitor\u0026\u0026 visitor) { using FirstType = TupleElement\u003c0, Ts...\u003e; using RetT = decltype(visitor(std::declval\u003cFirstType\u003e())); return visitImpl\u003cRetT, TVisitor, Ts...\u003e(std::forward\u003cTVisitor\u003e(visitor)); } template \u003ctypename... Ts\u003e template \u003ctypename RetT, typename TVisitor, typename First, typename... Rest\u003e RetT MyVariant\u003cTs...\u003e::visitImpl(TVisitor\u0026\u0026 visitor) { if (getTypeIndex\u003cFirst\u003e() == typeIndex) { return visitor(get\u003cFirst\u003e()); } else { // 递归访问剩余的类型 return visitImpl\u003cRetT, TVisitor, Rest...\u003e(std::forward\u003cTVisitor\u003e(visitor)); } } template \u003ctypename... Ts\u003e template \u003ctypename RetT, typename TVisitor\u003e RetT MyVariant\u003cTs...\u003e::visitImpl([[maybe_unused]]TVisitor\u0026\u0026 visitor) { // 基础情况：所有类型都已检查，未找到匹配的类型 throw std::runtime_error(\"Wrong type\"); } 总结 在本文中，我们实现了一个简单版的 std::variant 和 std::visit，通过传统 C++ 实现了类型安全的联合体数据结构。我们依次通过以下步骤构建了这一系统：\nMyVariant 类的基本框架：通过联合体 (union) 存储不同类型的数据，并使用模板构造函数动态设置值。\n类型索引 (index()) 的实现：使用模板递归技术结合 constexpr 来实现类型的编译时索引查找，从而在运行时根据类型索引来访问对应的值。\nget() 函数：实现了获取存储值的函数，并通过类型检查确保类型安全。如果访问了错误类型的数据，则抛出异常。\nvisit() 函数：实现了一个可扩展的访问机制，使得不同类型的值可以通过同一个 Visitor 被访问和处理。通过递归的方式，系统能够动态地访问不同类型的值，并调用相应的处理函数。\n通过这些实现，我们成功模拟了 C++ 标准库中的 std::variant 和 std::visit 功能。同时，通过对比可以看出，现代 C++ 提供了更强大的模板元编程能力。利用这些特性，我们能够使用更直观的语法，在编译期间实现高效且类型安全的联合体访问，从而提供一种灵活、类型安全的方式来处理多类型数据。\n","wordCount":"2102","inLanguage":"zh-cn","datePublished":"2025-01-01T00:00:00Z","dateModified":"2025-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">动手实现std::visit - C++ for the Antiquated（之二）</h1><div class=post-meta><span title='2025-01-01 00:00:00 +0000 UTC'>January 1, 2025</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=stdvariant-与-stdvisit>std::variant 与 std::visit<a hidden class=anchor aria-hidden=true href=#stdvariant-与-stdvisit>#</a></h2><h3 id=stdvariant>std::variant<a hidden class=anchor aria-hidden=true href=#stdvariant>#</a></h3><p><code>std::variant</code> 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 <code>union</code> 不同，<code>std::variant</code> 能够在运行时安全地检查当前存储的类型，避免未定义行为。</p><p>其核心特点如下：</p><ul><li>类型安全：访问值时进行类型检查，防止类型错误。</li><li>固定类型集合：存储类型在编译时确定。</li><li>异常安全：在赋值失败时会进入无效状态（std::monostate）。</li></ul><h3 id=stdvisit>std::visit<a hidden class=anchor aria-hidden=true href=#stdvisit>#</a></h3><p><code>std::visit</code> 是一个访问器函数，用于访问 <code>std::variant</code> 中当前存储的值。它通过一个可调用对象（如 Lambda 表达式）来处理存储的值，从而实现编译时多态。</p><p>其核心特点如下：</p><ul><li>统一访问接口：无论存储的是哪种类型，都可以通过同一个函数进行访问。</li><li>类型安全：确保所有可能的类型都被正确处理。</li></ul><h3 id=代码示例>代码示例<a hidden class=anchor aria-hidden=true href=#代码示例>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;type_traits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>inline</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> always_false_v <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>float</span>, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;&gt;</span> items {
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>10</span>,
</span></span><span style=display:flex><span>        <span style=color:#ae81ff>3.14f</span>,
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;foobar&#34;</span>
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> item : items) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>visit([](<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> arg) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>using</span> T <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>decltype</span>(arg)<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;int: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, <span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;float: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#66d9ef>constexpr</span> (std<span style=color:#f92672>::</span>is_same_v<span style=color:#f92672>&lt;</span>T, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span>) {
</span></span><span style=display:flex><span>                std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;std::string: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> arg <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>static_assert</span>(always_false_v<span style=color:#f92672>&lt;&gt;</span>, <span style=color:#e6db74>&#34;Unhandled type!&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }, item);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码分析>代码分析<a hidden class=anchor aria-hidden=true href=#代码分析>#</a></h3><ol><li><p><strong><code>std::variant&lt;int, float, std::string></code></strong></p><ul><li>这是一个类型安全的联合体，可以存储 <code>int</code>、<code>float</code> 或 <code>std::string</code> 中的任意一种类型。</li><li>将多个 <code>std::variant</code> 存储在 <code>std::vector</code> 中，形成一个统一的容器。</li></ul></li><li><p><strong><code>std::visit</code></strong></p><ul><li>使用 <code>std::visit</code> 访问每个 <code>std::variant</code> 元素。</li><li>传入一个<strong>泛型 Lambda 表达式</strong>，通过 <code>if constexpr</code> 在编译时分发到不同的分支，处理不同类型的值。</li></ul></li><li><p><strong><code>if constexpr</code> 与 <code>std::is_same_v</code></strong></p><ul><li>使用 <code>std::is_same_v</code> 判断存储的实际类型。</li><li>根据类型进行不同的输出操作。</li></ul></li><li><p><strong>类型安全</strong></p><ul><li>如果添加一个未处理的类型，编译器会在 <code>static_assert</code> 中报错，提醒开发者补充处理逻辑。</li></ul></li></ol><h2 id=使用传统c实现stdvisit>使用传统C++实现std::visit<a hidden class=anchor aria-hidden=true href=#使用传统c实现stdvisit>#</a></h2><h3 id=实现stdvariant>实现std::variant<a hidden class=anchor aria-hidden=true href=#实现stdvariant>#</a></h3><p>在传统 C++ 中，我们只有简单的 <code>union</code> 来实现“联合体”语义。然而，<code>union</code> 存在一些局限性：</p><ul><li>无法存储非平凡类型（例如 <code>std::string</code>）。</li><li>无法跟踪当前存储的类型。</li><li>无法进行类型安全检查。</li></ul><p>而 <code>std::variant</code> 通过类型索引和类型匹配来提供类型安全，支持多种类型的存储与访问。</p><h3 id=实现-stdvisit>实现 std::visit<a hidden class=anchor aria-hidden=true href=#实现-stdvisit>#</a></h3><p>实现 <code>std::visit</code> 需要使用一个可调用对象（例如 Visitor）来访问 <code>std::variant</code> 中的值。具体来说，它在编译时根据实际类型匹配相应的 <code>operator()</code> 方法。</p><p>示例代码如下：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;variant&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;type_traits&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Visitor</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;int: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>float</span><span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;float: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>operator</span>()(<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>string<span style=color:#f92672>&amp;</span> item) <span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;string: &#34;</span> <span style=color:#f92672>&lt;&lt;</span> item <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>variant<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>float</span>, std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> item(<span style=color:#ae81ff>114.514f</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前类型的索引
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> item.index() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 1 (float 的索引)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 获取当前存储的值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>float</span><span style=color:#f92672>&gt;</span>(item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 114.514
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>get<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span>(item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (<span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>bad_variant_access<span style=color:#f92672>&amp;</span> e) {
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> e.what() <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 类型不匹配，抛出异常
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 使用 Visitor 访问值
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>visit(Visitor{}, item) <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>endl; <span style=color:#75715e>// 输出: 1 (float 类型返回 1)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=实现的核心要点>实现的核心要点<a hidden class=anchor aria-hidden=true href=#实现的核心要点>#</a></h3><p>实现 <code>std::visit</code> 的关键在于以下几个方面：</p><ul><li><p><strong>类型索引 (<code>index()</code>)</strong><br>根据传入的 <code>std::variant</code> 参数类型，确定其在类型集合中的索引。</p></li><li><p><strong>类型访问 (<code>std::get&lt;T></code>)</strong><br>根据传入的模板类型 <code>T</code>，获取存储的值。如果类型不匹配，抛出异常，确保类型安全。</p></li><li><p><strong>类型分派 (<code>std::visit</code>)</strong><br>根据当前存储的类型，调用 <code>Visitor</code> 中对应的 <code>operator()</code> 方法。可以通过 <code>switch-case</code> 或模板匹配来实现类型分发。</p></li></ul><h3 id=代码实现0---基本框架>代码实现0 - 基本框架<a hidden class=anchor aria-hidden=true href=#代码实现0---基本框架>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyVariant</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    MyVariant(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>        setValue(item);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> setValue(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// TODO
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 用于存储“联合体”的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>union</span> <span style=color:#a6e22e>Storage</span> {
</span></span><span style=display:flex><span>        Storage() {}
</span></span><span style=display:flex><span>        <span style=color:#f92672>~</span>Storage() {}
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>aligned_union_t<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>, Ts...<span style=color:#f92672>&gt;</span> data;
</span></span><span style=display:flex><span>    } storage;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=代码实现1---index函数>代码实现1 - index()函数<a hidden class=anchor aria-hidden=true href=#代码实现1---index函数>#</a></h3><p>我们使用经典的模板递归来查找类型对应的索引。同时，利用 <code>constexpr</code> 来简化编译时计算的过程。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t N, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TupleElement <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>tuple_element<span style=color:#f92672>&lt;</span>N, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>Types...<span style=color:#f92672>&gt;&gt;::</span>type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span> First, <span style=color:#66d9ef>typename</span>... Rest<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span><span style=color:#f92672>&lt;</span>T, First, Rest...<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>is_same<span style=color:#f92672>&lt;</span>T, First<span style=color:#f92672>&gt;::</span>value 
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> 
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> (TypeIndex<span style=color:#f92672>&lt;</span>T, Rest...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> TypeIndex<span style=color:#f92672>&lt;</span>T, Rest...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TypeIndex</span><span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>int</span> value <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>constexpr</span> <span style=color:#66d9ef>bool</span> containsType() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> TypeIndex<span style=color:#f92672>&lt;</span>T, Ts...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>通过上述代码，我们实现了在编译期确定传入类型对应的类型索引。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>setValue(<span style=color:#66d9ef>const</span> T<span style=color:#f92672>&amp;</span> item) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> TargetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static_assert</span>(containsType<span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>&gt;</span>(), <span style=color:#e6db74>&#34;Type not supported&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> (<span style=color:#f92672>&amp;</span>storage.data) TargetType(item);
</span></span><span style=display:flex><span>    typeIndex <span style=color:#f92672>=</span> getTypeIndex<span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码实现2---get-函数>代码实现2 - <code>get()</code> 函数<a hidden class=anchor aria-hidden=true href=#代码实现2---get-函数>#</a></h3><p>我们实现了一个函数 <code>MyVariant::get()</code>，通过检查 <code>typeIndex</code> 来确保获取的类型与存储类型一致。</p><p>我们也能可以通过<code>MyGet</code>函数模拟<code>std::get&lt;T></code>函数的行为。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MyVariant</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T, <span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>&amp;</span> MyGet(MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;&amp;</span> var) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> var.<span style=color:#66d9ef>template</span> get<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>T<span style=color:#f92672>&amp;</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>get() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> TargetType <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>decay_t<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (TypeIndex<span style=color:#f92672>&lt;</span>T, Ts...<span style=color:#f92672>&gt;::</span>value <span style=color:#f92672>!=</span> typeIndex) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Wrong type&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>*</span><span style=color:#66d9ef>reinterpret_cast</span><span style=color:#f92672>&lt;</span>TargetType<span style=color:#f92672>*&gt;</span>(<span style=color:#f92672>&amp;</span>storage.data);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=代码实现3---visit函数>代码实现3 - <code>visit</code>函数<a hidden class=anchor aria-hidden=true href=#代码实现3---visit函数>#</a></h3><p>接下来是 <code>visit()</code> 函数的实现。它通过递归方式依次访问 <code>std::variant</code> 中的每种类型，并调用与之对应的处理函数。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>size_t N, <span style=color:#66d9ef>typename</span>... Types<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> TupleElement <span style=color:#f92672>=</span> <span style=color:#66d9ef>typename</span> std<span style=color:#f92672>::</span>tuple_element<span style=color:#f92672>&lt;</span>N, std<span style=color:#f92672>::</span>tuple<span style=color:#f92672>&lt;</span>Types...<span style=color:#f92672>&gt;&gt;::</span>type;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> TVisitor<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>auto</span> MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visit(TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> FirstType <span style=color:#f92672>=</span> TupleElement<span style=color:#f92672>&lt;</span><span style=color:#ae81ff>0</span>, Ts...<span style=color:#f92672>&gt;</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>using</span> RetT <span style=color:#f92672>=</span> <span style=color:#66d9ef>decltype</span>(visitor(std<span style=color:#f92672>::</span>declval<span style=color:#f92672>&lt;</span>FirstType<span style=color:#f92672>&gt;</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> visitImpl<span style=color:#f92672>&lt;</span>RetT, TVisitor, Ts...<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>TVisitor<span style=color:#f92672>&gt;</span>(visitor));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> RetT, <span style=color:#66d9ef>typename</span> TVisitor, <span style=color:#66d9ef>typename</span> First, <span style=color:#66d9ef>typename</span>... Rest<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>RetT MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visitImpl(TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (getTypeIndex<span style=color:#f92672>&lt;</span>First<span style=color:#f92672>&gt;</span>() <span style=color:#f92672>==</span> typeIndex) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>visitor</span>(get<span style=color:#f92672>&lt;</span>First<span style=color:#f92672>&gt;</span>());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 递归访问剩余的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> visitImpl<span style=color:#f92672>&lt;</span>RetT, TVisitor, Rest...<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>forward<span style=color:#f92672>&lt;</span>TVisitor<span style=color:#f92672>&gt;</span>(visitor));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span>... Ts<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span> <span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> RetT, <span style=color:#66d9ef>typename</span> TVisitor<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>RetT MyVariant<span style=color:#f92672>&lt;</span>Ts...<span style=color:#f92672>&gt;::</span>visitImpl(<span style=color:#a6e22e>[[maybe_unused]]</span>TVisitor<span style=color:#f92672>&amp;&amp;</span> visitor) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 基础情况：所有类型都已检查，未找到匹配的类型
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>throw</span> std<span style=color:#f92672>::</span>runtime_error(<span style=color:#e6db74>&#34;Wrong type&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>在本文中，我们实现了一个简单版的 <code>std::variant</code> 和 <code>std::visit</code>，通过传统 C++ 实现了类型安全的联合体数据结构。我们依次通过以下步骤构建了这一系统：</p><ol><li><p><strong><code>MyVariant</code> 类的基本框架</strong>：通过联合体 (<code>union</code>) 存储不同类型的数据，并使用模板构造函数动态设置值。</p></li><li><p><strong>类型索引 (<code>index()</code>) 的实现</strong>：使用模板递归技术结合 <code>constexpr</code> 来实现类型的编译时索引查找，从而在运行时根据类型索引来访问对应的值。</p></li><li><p><strong><code>get()</code> 函数</strong>：实现了获取存储值的函数，并通过类型检查确保类型安全。如果访问了错误类型的数据，则抛出异常。</p></li><li><p><strong><code>visit()</code> 函数</strong>：实现了一个可扩展的访问机制，使得不同类型的值可以通过同一个 <code>Visitor</code> 被访问和处理。通过递归的方式，系统能够动态地访问不同类型的值，并调用相应的处理函数。</p></li></ol><p>通过这些实现，我们成功模拟了 C++ 标准库中的 <code>std::variant</code> 和 <code>std::visit</code> 功能。同时，通过对比可以看出，现代 C++ 提供了更强大的模板元编程能力。利用这些特性，我们能够使用更直观的语法，在编译期间实现高效且类型安全的联合体访问，从而提供一种灵活、类型安全的方式来处理多类型数据。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/cpp/>Cpp</a></li><li><a href=https://wizmann.top/tags/modern-cpp/>Modern Cpp</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/><span class=title>«</span><br><span>std::visit实现运行时多态 - C++ for the Antiquated（之三）</span>
</a><a class=next href=https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/><span class=title>»</span><br><span>constexpr详解 - C++ for the Antiquated（之一）</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>