<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Codeforces Round #290 (Div. 2) Tutorial | Maerlyn's Rainbow</title>
<meta name=keywords content="codeforces,algorithm"><meta name=description content="A. Fox And Snake
Implementation
(n, m) = map(int, raw_input().split())

res = []

for i in xrange(n):
    if i % 2 == 0:
        res.append('#' * m)
    elif (i / 2) % 2 == 0:
        res.append('.' * (m - 1) + '#')
    else:
        res.append('#' + '.' * (m - 1))

for line in res:
    print line
B. Fox And Two Dots
DFS




  
    
      
A
A
A
A
B
A
A
C
A
A
A
A


    
  

We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle."><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/cf-290-div-2/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/cf-290-div-2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/cf-290-div-2/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Codeforces Round #290 (Div. 2) Tutorial"><meta property="og:description" content="A. Fox And Snake Implementation
(n, m) = map(int, raw_input().split()) res = [] for i in xrange(n): if i % 2 == 0: res.append('#' * m) elif (i / 2) % 2 == 0: res.append('.' * (m - 1) + '#') else: res.append('#' + '.' * (m - 1)) for line in res: print line B. Fox And Two Dots DFS
A A A A B A A C A A A A We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle."><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-02-18T00:30:24+00:00"><meta property="article:modified_time" content="2015-02-18T00:30:24+00:00"><meta property="article:tag" content="Codeforces"><meta property="article:tag" content="Algorithm"><meta name=twitter:card content="summary"><meta name=twitter:title content="Codeforces Round #290 (Div. 2) Tutorial"><meta name=twitter:description content="A. Fox And Snake
Implementation
(n, m) = map(int, raw_input().split())

res = []

for i in xrange(n):
    if i % 2 == 0:
        res.append('#' * m)
    elif (i / 2) % 2 == 0:
        res.append('.' * (m - 1) + '#')
    else:
        res.append('#' + '.' * (m - 1))

for line in res:
    print line
B. Fox And Two Dots
DFS




  
    
      
A
A
A
A
B
A
A
C
A
A
A
A


    
  

We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"Codeforces Round #290 (Div. 2) Tutorial","item":"https://wizmann.top/posts/cf-290-div-2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Codeforces Round #290 (Div. 2) Tutorial","name":"Codeforces Round #290 (Div. 2) Tutorial","description":"A. Fox And Snake Implementation\n(n, m) = map(int, raw_input().split()) res = [] for i in xrange(n): if i % 2 == 0: res.append(\u0026#39;#\u0026#39; * m) elif (i / 2) % 2 == 0: res.append(\u0026#39;.\u0026#39; * (m - 1) + \u0026#39;#\u0026#39;) else: res.append(\u0026#39;#\u0026#39; + \u0026#39;.\u0026#39; * (m - 1)) for line in res: print line B. Fox And Two Dots DFS\nA A A A B A A C A A A A We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle.\n","keywords":["codeforces","algorithm"],"articleBody":"A. Fox And Snake Implementation\n(n, m) = map(int, raw_input().split()) res = [] for i in xrange(n): if i % 2 == 0: res.append('#' * m) elif (i / 2) % 2 == 0: res.append('.' * (m - 1) + '#') else: res.append('#' + '.' * (m - 1)) for line in res: print line B. Fox And Two Dots DFS\nA A A A B A A C A A A A We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle.\n#include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x const int SIZE = 54; const int mx[] = {0, 1, 0, -1}; const int my[] = {-1, 0, 1, 0}; int n, m; char g[SIZE][SIZE]; char visit[SIZE][SIZE]; bool do_dfs(int y, int x, char c, int dir) { if (visit[y][x]) { return true; } visit[y][x] = 1; for (int i = 0; i \u003c 4; i++) { int ny = y + my[i]; int nx = x + mx[i]; if (nx \u003c 0 || nx \u003e= m || ny \u003c 0 || ny \u003e= n || g[ny][nx] != c || (dir != -1 \u0026\u0026 i == (dir + 2) % 4)) { continue; } if (do_dfs(ny, nx, c, i)) { return true; } } return false; } bool dfs(int y, int x) { char c = g[y][x]; return do_dfs(y, x, c, -1); } int main() { input(n \u003e\u003e m); memset(g, 0, sizeof(g)); memset(visit, 0, sizeof(visit)); for (int i = 0; i \u003c n; i++) { input(g[i]); } try { for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c m; j++) { if (!visit[i][j]) { bool res = dfs(i, j); if (res) { print(\"Yes\"); throw \"Got it\"; } } } } print(\"No\"); } catch (...) { // pass } return 0; } C. Fox And Names Topsort\nThis is a classic interview problem. We can find the relationship between two letters from the given name list.\nBut in this instance, there is no possible lexical order because the name list is invalid.\na a a a a a So the algorithm can be describe in this way:\nIf the name list is invalid, there is no solution. Try to find the order of the letters. Topsort If topsort is success, print out the new lexical order of the name list. If failed, there is no solution. #include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x const int SIZE = 26; vector\u003cstring\u003e names; vector\u003cint\u003e g[SIZE]; vector\u003cint\u003e res; int n; int in[SIZE]; bool makeG() { for (int i = 1; i \u003c n; i++) { const string\u0026 pre = names[i - 1]; const string\u0026 now = names[i]; int len = min(pre.size(), now.size()); if (pre.size() \u003e now.size() \u0026\u0026 pre.substr(0, len) == now) { return false; } for (int j = 0; j \u003c len; j++) { if (pre[j] == now[j]) { continue; } int a = pre[j] - 'a'; int b = now[j] - 'a'; g[a].push_back(b); in[b]++; break; } } return true; } bool top_sort() { queue\u003cint\u003e q; int cnt = 0; for (int i = 0; i \u003c SIZE; i++) { if (in[i] == 0) { q.push(i); cnt++; } } while (!q.empty()) { int now = q.front(); q.pop(); res.push_back(now); for (auto next: g[now]) { in[next]--; if (in[next] == 0) { q.push(next); cnt++; } } } return cnt == SIZE; } void print_res() { for (auto i: res) { printf(\"%c\", 'a' + i); } puts(\"\"); } int main() { string name; input(n); memset(in, 0, sizeof(in)); for (int i = 0; i \u003c n; i++) { input(name); names.push_back(name); } if (makeG() \u0026\u0026 top_sort()) { print_res(); } else { puts(\"Impossible\"); } return 0; } D. Fox And Jumping Extended Euclidean algorithm\nAs we might know, for every positive integer x and y:\na x + b y = g c d ( x , y ) Let’s extend this theorem, for an array of positive integer Xs:\nA s X s = g c d ( X s ) (As is an array of constants, both positive and negative)\nIf gcd(Xs) equal to one, that is, every two number of the array is co-prime.\nSo, we can find a subarray that every two number is co-prime, and have the minimal cost.\nAs there are not too many factors in a single number, even the number here is as large as 10^9. The gcd() of the subarray won’t have too many results, and could be stored in a single unordered_map here.\nAnd,\nC++ Iterator Invalidation Rules (C++03)\nAssociative containers\n[multi]{set,map}: all iterators and references unaffected\nHere is the rule of C++ about the behavoir of the iterators when we try to add something into the map during the iteration. So we can just use one sigle map, and avoid the complexity of moving things between to containers.\n#include #include #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x const int SIZE = 500; const int INF = 0x3f3f3f3f; int gcd(int a, int b) { if (a % b == 0) { return b; } return gcd(b, a % b); } struct Card { int step; int cost; }; int n; vector\u003cCard\u003e cards; int main() { input(n); cards.resize(n); for (int i = 0; i \u003c n; i++) { input(cards[i].step); } for (int i = 0; i \u003c n; i++) { input(cards[i].cost); } unordered_map\u003cint, int\u003e mp; for (auto\u0026 card: cards) { if (mp.find(card.step) == mp.end()) { mp[card.step] = INF; } mp[card.step] = min(mp[card.step], card.cost); } for (int i = 0; i \u003c n; i++) { int thres = mp.find(1) != mp.end()? mp[1]: INF; for (auto\u0026 p: mp) { auto step = p.first; auto cost = p.second; if (step != 1 \u0026\u0026 cost \u003e= thres) { continue; } int g = gcd(step, cards[i].step); if (mp.find(g) == mp.end()) { mp[g] = INF; } if (g == step) { mp[g] = min(mp[g], cost); } mp[g] = min(mp[g], cost + cards[i].cost); } } if (mp.find(1) == mp.end()) { print(\"-1\"); } else { print(mp[1]); } return 0; } E. Fox And Dinner Max Flow Algorithm\nAs we know, every odd number must be connected to two even numbers. And, of course, one even number should be connected to two odd numbers.\nWe use the max flow algortihm. Every odd number have a path with 2 unit of flow to the source node, every even number have a path with 2 unit of flow to the sink node. And if the sum of one odd number and an even number is a prime, we connect them with a path with 1 unit of flow.\nAs the result, we have a undirected graph that every node have a degree of 2. It’s easy to find out that is an Euler circuit. We find the circuit and print it out.\nThe problem is not easy as it seems. Harsh one, indeed. I used Dinic algorithm for the max flow. Actually, I don’t like my code here.\n#include #include #include #include #include #include #include #include using namespace std; #define print(x) cout\u003c","wordCount":"1776","inLanguage":"zh-cn","datePublished":"2015-02-18T00:30:24Z","dateModified":"2015-02-18T00:30:24Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/cf-290-div-2/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Codeforces Round #290 (Div. 2) Tutorial</h1><div class=post-meta><span title='2015-02-18 00:30:24 +0000 UTC'>February 18, 2015</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=a-fox-and-snake>A. Fox And Snake<a hidden class=anchor aria-hidden=true href=#a-fox-and-snake>#</a></h2><p>Implementation</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>(n, m) <span style=color:#f92672>=</span> map(int, raw_input()<span style=color:#f92672>.</span>split())
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>res <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> xrange(n):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> i <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        res<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>*</span> m)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>elif</span> (i <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>        res<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>*</span> (m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;#&#39;</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>        res<span style=color:#f92672>.</span>append(<span style=color:#e6db74>&#39;#&#39;</span> <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>*</span> (m <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> res:
</span></span><span style=display:flex><span>    print line
</span></span></code></pre></div><h2 id=b-fox-and-two-dots>B. Fox And Two Dots<a hidden class=anchor aria-hidden=true href=#b-fox-and-two-dots>#</a></h2><p>DFS</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 40 57"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="0" y="20" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="0" y="36" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="8" y="20" fill="currentcolor" style="font-size:1em">B</text><text text-anchor="middle" x="8" y="36" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="16" y="20" fill="currentcolor" style="font-size:1em">C</text><text text-anchor="middle" x="16" y="36" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="24" y="20" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="24" y="36" fill="currentcolor" style="font-size:1em">A</text></g></svg></div><p>We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>54</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> mx[] <span style=color:#f92672>=</span> {<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>};
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> my[] <span style=color:#f92672>=</span> {<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n, m;
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> g[SIZE][SIZE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> visit[SIZE][SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>do_dfs</span>(<span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span> x, <span style=color:#66d9ef>char</span> c, <span style=color:#66d9ef>int</span> dir) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (visit[y][x]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    visit[y][x] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> ny <span style=color:#f92672>=</span> y <span style=color:#f92672>+</span> my[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> nx <span style=color:#f92672>=</span> x <span style=color:#f92672>+</span> mx[i];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nx <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> nx <span style=color:#f92672>&gt;=</span> m 
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> ny <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>||</span> ny <span style=color:#f92672>&gt;=</span> n 
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> g[ny][nx] <span style=color:#f92672>!=</span> c
</span></span><span style=display:flex><span>                <span style=color:#f92672>||</span> (dir <span style=color:#f92672>!=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> i <span style=color:#f92672>==</span> (dir <span style=color:#f92672>+</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>4</span>)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (do_dfs(ny, nx, c, i)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> y, <span style=color:#66d9ef>int</span> x) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> g[y][x];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> do_dfs(y, x, c, <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    input(n <span style=color:#f92672>&gt;&gt;</span> m);
</span></span><span style=display:flex><span>    memset(g, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(g));
</span></span><span style=display:flex><span>    memset(visit, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(visit));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(g[i]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> m; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>visit[i][j]) {
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>bool</span> res <span style=color:#f92672>=</span> dfs(i, j);
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span> (res) {
</span></span><span style=display:flex><span>                        print(<span style=color:#e6db74>&#34;Yes&#34;</span>);
</span></span><span style=display:flex><span>                        <span style=color:#66d9ef>throw</span> <span style=color:#e6db74>&#34;Got it&#34;</span>;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;No&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>catch</span> (...) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// pass
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=c-fox-and-names>C. Fox And Names<a hidden class=anchor aria-hidden=true href=#c-fox-and-names>#</a></h2><p>Topsort</p><p>This is a classic interview problem. We can find the relationship between two letters from the given name list.</p><p>But in this instance, there is no possible lexical order because the name list is invalid.</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 32 57"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="0" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="0" y="36" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="8" y="20" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">a</text></g></svg></div><p>So the algorithm can be describe in this way:</p><ol><li>If the name list is invalid, there is no solution.</li><li>Try to find the order of the letters.</li><li>Topsort</li><li>If topsort is success, print out the new lexical order of the name list. If failed, there is no solution.</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>26</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span> names;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> g[SIZE];
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> in[SIZE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>makeG</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> string<span style=color:#f92672>&amp;</span> pre <span style=color:#f92672>=</span> names[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> string<span style=color:#f92672>&amp;</span> now <span style=color:#f92672>=</span> names[i];
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> len <span style=color:#f92672>=</span> min(pre.size(), now.size());
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (pre.size() <span style=color:#f92672>&gt;</span> now.size() <span style=color:#f92672>&amp;&amp;</span> pre.substr(<span style=color:#ae81ff>0</span>, len) <span style=color:#f92672>==</span> now) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; j <span style=color:#f92672>&lt;</span> len; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (pre[j] <span style=color:#f92672>==</span> now[j]) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> pre[j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> now[j] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;a&#39;</span>;
</span></span><span style=display:flex><span>            g[a].push_back(b);
</span></span><span style=display:flex><span>            in[b]<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>top_sort</span>() {
</span></span><span style=display:flex><span>    queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> q;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cnt <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (in[i] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            q.push(i);
</span></span><span style=display:flex><span>            cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (<span style=color:#f92672>!</span>q.empty()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> now <span style=color:#f92672>=</span> q.front();
</span></span><span style=display:flex><span>        q.pop();
</span></span><span style=display:flex><span>        res.push_back(now);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> next: g[now]) {
</span></span><span style=display:flex><span>            in[next]<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (in[next] <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                q.push(next);
</span></span><span style=display:flex><span>                cnt<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> cnt <span style=color:#f92672>==</span> SIZE;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>print_res</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span> i: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%c&#34;</span>, <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>+</span> i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    puts(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    string name;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    input(n);
</span></span><span style=display:flex><span>    memset(in, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(in));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(name);
</span></span><span style=display:flex><span>        names.push_back(name);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (makeG() <span style=color:#f92672>&amp;&amp;</span> top_sort()) {
</span></span><span style=display:flex><span>        print_res();
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        puts(<span style=color:#e6db74>&#34;Impossible&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=d-fox-and-jumping>D. Fox And Jumping<a hidden class=anchor aria-hidden=true href=#d-fox-and-jumping>#</a></h2><p>Extended Euclidean algorithm</p><p>As we might know, for every positive integer <code>x</code> and <code>y</code>:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 160 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">x</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">,</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>Let&rsquo;s extend this theorem, for an array of positive integer <code>Xs</code>:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 144 25"><g transform="translate(8,16)"><circle cx="24" cy="0" r="6" stroke="currentcolor" fill="currentcolor"/><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">A</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">X</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">g</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">X</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>(<code>As</code> is an array of constants, both positive and negative)</p><p>If <code>gcd(Xs)</code> equal to one, that is, every two number of the array is co-prime.</p><p>So, we can find a subarray that every two number is co-prime, and have the minimal cost.</p><p>As there are not too many factors in a single number, even the number here is as large as 10^9. The <code>gcd()</code> of the subarray won&rsquo;t have too many results, and could be stored in a single <code>unordered_map</code> here.</p><p>And,</p><blockquote><p>C++ Iterator Invalidation Rules (C++03)</p></blockquote><blockquote><p>Associative containers</p></blockquote><blockquote><p>[multi]{set,map}: all iterators and references unaffected</p></blockquote><p>Here is the rule of C++ about the behavoir of the iterators when we try to add something into the map during the iteration. So we can just use one sigle map, and avoid the complexity of moving things between to containers.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unordered_map&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>500</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> INF <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3f3f3f3f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>gcd</span>(<span style=color:#66d9ef>int</span> a, <span style=color:#66d9ef>int</span> b) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>%</span> b <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> b;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> gcd(b, a <span style=color:#f92672>%</span> b);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Card</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> step;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> cost;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span>Card<span style=color:#f92672>&gt;</span> cards;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    input(n);
</span></span><span style=display:flex><span>    cards.resize(n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(cards[i].step);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(cards[i].cost);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    unordered_map<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span>, <span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> mp;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> card: cards) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (mp.find(card.step) <span style=color:#f92672>==</span> mp.end()) {
</span></span><span style=display:flex><span>            mp[card.step] <span style=color:#f92672>=</span> INF;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        mp[card.step] <span style=color:#f92672>=</span> min(mp[card.step], card.cost);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> thres <span style=color:#f92672>=</span> mp.find(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>!=</span> mp.end()<span style=color:#f92672>?</span> mp[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>:</span> INF;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> p: mp) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> step <span style=color:#f92672>=</span> p.first;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>auto</span> cost <span style=color:#f92672>=</span> p.second;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (step <span style=color:#f92672>!=</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> cost <span style=color:#f92672>&gt;=</span> thres) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> g <span style=color:#f92672>=</span> gcd(step, cards[i].step);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (mp.find(g) <span style=color:#f92672>==</span> mp.end()) {
</span></span><span style=display:flex><span>                mp[g] <span style=color:#f92672>=</span> INF;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (g <span style=color:#f92672>==</span> step) {
</span></span><span style=display:flex><span>                mp[g] <span style=color:#f92672>=</span> min(mp[g], cost);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            mp[g] <span style=color:#f92672>=</span> min(mp[g], cost <span style=color:#f92672>+</span> cards[i].cost);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (mp.find(<span style=color:#ae81ff>1</span>) <span style=color:#f92672>==</span> mp.end()) {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;-1&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        print(mp[<span style=color:#ae81ff>1</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=e-fox-and-dinner>E. Fox And Dinner<a hidden class=anchor aria-hidden=true href=#e-fox-and-dinner>#</a></h2><p>Max Flow Algorithm</p><p>As we know, every odd number must be connected to two even numbers. And, of course, one even number should be connected to two odd numbers.</p><p>We use the max flow algortihm. Every odd number have a path with 2 unit of flow to the <strong>source</strong> node, every even number have a path with 2 unit of flow to the <strong>sink</strong> node. And if the sum of one odd number and an even number is a prime, we connect them with a path with 1 unit of flow.</p><p>As the result, we have a undirected graph that every node have a degree of 2. It&rsquo;s easy to find out that is an <strong>Euler circuit</strong>. We find the circuit and print it out.</p><p>The problem is not easy as it seems. Harsh one, indeed. I used <strong>Dinic</strong> algorithm for the max flow. Actually, I don&rsquo;t like my code here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;queue&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stack&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout&lt;&lt;x&lt;&lt;endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin&gt;&gt;x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> NODE <span style=color:#f92672>=</span> <span style=color:#ae81ff>200</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>19</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> EDGE <span style=color:#f92672>=</span> NODE <span style=color:#f92672>*</span> NODE;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> INF  <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x3f3f3f3f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>node</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> st, end, flow, next;
</span></span><span style=display:flex><span>    node(){}
</span></span><span style=display:flex><span>    node(<span style=color:#66d9ef>int</span> ist, <span style=color:#66d9ef>int</span> iend, <span style=color:#66d9ef>int</span> iflow, <span style=color:#66d9ef>int</span> inext)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>            st(ist), end(iend), flow(iflow), next(inext) {}
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>node edge[EDGE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> head[NODE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> ind;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> source,sink;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> nums;
</span></span><span style=display:flex><span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> cnc[NODE];
</span></span><span style=display:flex><span><span style=color:#66d9ef>char</span> visit[NODE];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>addEdge</span>(<span style=color:#66d9ef>int</span> s,<span style=color:#66d9ef>int</span> e,<span style=color:#66d9ef>int</span> f)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    edge[ind]<span style=color:#f92672>=</span>node(s,e,f,head[s]);
</span></span><span style=display:flex><span>    head[s] <span style=color:#f92672>=</span> ind<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    edge[ind]<span style=color:#f92672>=</span>node(e,s,<span style=color:#ae81ff>0</span>,head[e]);
</span></span><span style=display:flex><span>    head[e] <span style=color:#f92672>=</span> ind<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> dinic
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> level[NODE],curhead[NODE],Que[NODE];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> estack[<span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>NODE<span style=color:#f92672>+</span><span style=color:#ae81ff>4</span><span style=color:#f92672>*</span>EDGE],estop;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>BFS</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        memset(level,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>sizeof</span>(level));
</span></span><span style=display:flex><span>        Que[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>=</span>source;
</span></span><span style=display:flex><span>        level[source]<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> fr<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>,tail<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>;fr<span style=color:#f92672>!=</span>tail;fr<span style=color:#f92672>=</span>(fr<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span>NODE)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> cur<span style=color:#f92672>=</span>Que[fr];
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> e<span style=color:#f92672>=</span>head[cur];e<span style=color:#f92672>!=-</span><span style=color:#ae81ff>1</span>;e<span style=color:#f92672>=</span>edge[e].next)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> next<span style=color:#f92672>=</span>edge[e].end;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(edge[e].flow <span style=color:#f92672>&amp;&amp;</span> level[next] <span style=color:#f92672>==</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    Que[tail]<span style=color:#f92672>=</span>next;
</span></span><span style=display:flex><span>                    level[next]<span style=color:#f92672>=</span>level[cur]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>                    tail<span style=color:#f92672>=</span>(tail<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)<span style=color:#f92672>%</span>NODE;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> level[sink]<span style=color:#f92672>!=-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>DFS</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> indptr,minf,e;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> res<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> cur<span style=color:#f92672>=</span>source;                                                   
</span></span><span style=display:flex><span>        estop<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        memcpy(curhead,head,<span style=color:#66d9ef>sizeof</span>(head));  
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span>(estop<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(cur<span style=color:#f92672>==</span>sink)
</span></span><span style=display:flex><span>            {                                      
</span></span><span style=display:flex><span>                minf<span style=color:#f92672>=</span>INF;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>estop<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    e<span style=color:#f92672>=</span>estack[i];
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>if</span>(edge[e].flow<span style=color:#f92672>&lt;=</span>minf)
</span></span><span style=display:flex><span>                    {
</span></span><span style=display:flex><span>                        minf<span style=color:#f92672>=</span>edge[e].flow;
</span></span><span style=display:flex><span>                        indptr<span style=color:#f92672>=</span>i;
</span></span><span style=display:flex><span>                    }
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                res<span style=color:#f92672>+=</span>minf;                                   
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span>estop<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;i<span style=color:#f92672>&gt;=</span><span style=color:#ae81ff>0</span>;i<span style=color:#f92672>--</span>)
</span></span><span style=display:flex><span>                {               
</span></span><span style=display:flex><span>                    e<span style=color:#f92672>=</span>estack[i];
</span></span><span style=display:flex><span>                    edge[e].flow<span style=color:#f92672>-=</span>minf;
</span></span><span style=display:flex><span>                    edge[e<span style=color:#f92672>^</span><span style=color:#ae81ff>1</span>].flow<span style=color:#f92672>+=</span>minf;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>                estop<span style=color:#f92672>=</span>indptr;                                    
</span></span><span style=display:flex><span>                cur<span style=color:#f92672>=</span>edge[estack[estop]].st;          
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(e<span style=color:#f92672>=</span>curhead[cur];e<span style=color:#f92672>!=-</span><span style=color:#ae81ff>1</span>;e<span style=color:#f92672>=</span>edge[e].next)
</span></span><span style=display:flex><span>            {  
</span></span><span style=display:flex><span>                curhead[cur]<span style=color:#f92672>=</span>e;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> next<span style=color:#f92672>=</span>edge[e].end;
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span>(edge[e].flow <span style=color:#f92672>&amp;&amp;</span> level[next]<span style=color:#f92672>==</span>level[cur]<span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>                {
</span></span><span style=display:flex><span>                    estack[estop<span style=color:#f92672>++</span>]<span style=color:#f92672>=</span>e;
</span></span><span style=display:flex><span>                    cur<span style=color:#f92672>=</span>next;
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>                }
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span>(e<span style=color:#f92672>==-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>            {                                           
</span></span><span style=display:flex><span>                estop<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>                level[cur]<span style=color:#f92672>=-</span><span style=color:#ae81ff>2</span>;                                    
</span></span><span style=display:flex><span>                cur<span style=color:#f92672>=</span>edge[estack[estop]].st;               
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>init</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    ind<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    memset(head,<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,<span style=color:#66d9ef>sizeof</span>(head));
</span></span><span style=display:flex><span>    memset(visit, <span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(visit));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#66d9ef>int</span> p, vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;&amp;</span> res) {
</span></span><span style=display:flex><span>    res.push_back(p);
</span></span><span style=display:flex><span>    visit[p] <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> u: cnc[p]) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (visit[u]) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        dfs(u, res);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>show_res</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> EDGE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (edge[i].flow <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> edge[i].st;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> edge[i].end;
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (a <span style=color:#f92672>==</span> source <span style=color:#f92672>||</span> b <span style=color:#f92672>==</span> source <span style=color:#f92672>||</span> a <span style=color:#f92672>==</span> sink <span style=color:#f92672>||</span> b <span style=color:#f92672>==</span> sink) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums[a <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> nums[b <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                cnc[a].push_back(b);
</span></span><span style=display:flex><span>                cnc[b].push_back(a);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/*
</span></span></span><span style=display:flex><span><span style=color:#75715e>    for (int i = 1; i &lt;= n; i++) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>        printf(&#34;%d -&gt; &#34;, i);
</span></span></span><span style=display:flex><span><span style=color:#75715e>        for (auto&amp; item: cnc[i]) {
</span></span></span><span style=display:flex><span><span style=color:#75715e>            printf(&#34;%d &#34;, item);
</span></span></span><span style=display:flex><span><span style=color:#75715e>        }
</span></span></span><span style=display:flex><span><span style=color:#75715e>        puts(&#34;&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    }
</span></span></span><span style=display:flex><span><span style=color:#75715e>    puts(&#34;---&#34;);
</span></span></span><span style=display:flex><span><span style=color:#75715e>    */</span>
</span></span><span style=display:flex><span>    vector<span style=color:#f92672>&lt;</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> res;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (visit[i]) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> tmp;
</span></span><span style=display:flex><span>        dfs(i, tmp);
</span></span><span style=display:flex><span>        res.push_back(tmp);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    print(res.size());
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> vec: res) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%d&#34;</span>, (<span style=color:#66d9ef>int</span>)vec.size());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>auto</span><span style=color:#f92672>&amp;</span> i: vec) {
</span></span><span style=display:flex><span>            printf(<span style=color:#e6db74>&#34; %d&#34;</span>, i);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        puts(<span style=color:#e6db74>&#34;&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isPrime</span>(<span style=color:#66d9ef>int</span> u) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> v <span style=color:#f92672>=</span> sqrt(u) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>; i <span style=color:#f92672>&lt;=</span> v; i <span style=color:#f92672>+=</span> <span style=color:#ae81ff>2</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>%</span> i <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    freopen(<span style=color:#e6db74>&#34;E.txt&#34;</span>, <span style=color:#e6db74>&#34;r&#34;</span>, stdin);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    input(n);
</span></span><span style=display:flex><span>    init();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    source <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    sink <span style=color:#f92672>=</span> n <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        input(x);
</span></span><span style=display:flex><span>        nums.push_back(x);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; j <span style=color:#f92672>&lt;=</span> n; j<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (nums[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (isPrime(nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>] <span style=color:#f92672>+</span> nums[j <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>])) {
</span></span><span style=display:flex><span>                addEdge(i, j, <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> u <span style=color:#f92672>=</span> nums[i <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (u <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            addEdge(source, i, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            addEdge(i, sink, <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> res <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span>(dinic<span style=color:#f92672>::</span>BFS()) {
</span></span><span style=display:flex><span>        res<span style=color:#f92672>+=</span>dinic<span style=color:#f92672>::</span>DFS();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (res <span style=color:#f92672>!=</span> n) {
</span></span><span style=display:flex><span>        puts(<span style=color:#e6db74>&#34;Impossible&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        show_res();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/codeforces/>Codeforces</a></li><li><a href=https://wizmann.top/tags/algorithm/>Algorithm</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/inspiration-from-zeromq/><span class=title>«</span><br><span>ZeroMQ启示录</span>
</a><a class=next href=https://wizmann.top/posts/cf-289-div-2/><span class=title>»</span><br><span>Codeforces Round #289 (Div. 2) Tutorial</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>