<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>内存屏障初探</h1><div class=tip><time datetime="2014-05-08 19:05:26 +0000 UTC">2014/05/08</time>
<span class=split>·</span>
<span>5204 words </span><span class=split>·</span>
<span>11 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/cpp>cpp</a>
<a href=/tags/memory-barrier>memory-barrier</a>
<a href=/tags/asm>asm</a>
<a href=/tags/multiprocess>multiprocess</a>
<a href=/tags/multithread>multithread</a>
<a href=/tags/thread>thread</a>
<a href=/tags/cocurrency>cocurrency</a></div></div><hr><div class=content><h2 id=原文地址>原文地址 <a href=#%e5%8e%9f%e6%96%87%e5%9c%b0%e5%9d%80 class=anchor>🔗</a></h2><p><a href=http://ridiculousfish.com/blog/posts/barrier.html>Barrier February 17th, 2007</a></p><h2 id=前言多核时代的挑战>前言：多核时代的挑战 <a href=#%e5%89%8d%e8%a8%80%e5%a4%9a%e6%a0%b8%e6%97%b6%e4%bb%a3%e7%9a%84%e6%8c%91%e6%88%98 class=anchor>🔗</a></h2><p>尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。</p><h2 id=线程技术探讨>线程技术探讨 <a href=#%e7%ba%bf%e7%a8%8b%e6%8a%80%e6%9c%af%e6%8e%a2%e8%ae%a8 class=anchor>🔗</a></h2><h3 id=名词解释>名词解释 <a href=#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a class=anchor>🔗</a></h3><h4 id=线程>线程 <a href=#%e7%ba%bf%e7%a8%8b class=anchor>🔗</a></h4><p>线程是一种拥有共享地址空间的、能被抢占式调度的执行上下文。</p><h4 id=多线程>多线程 <a href=#%e5%a4%9a%e7%ba%bf%e7%a8%8b class=anchor>🔗</a></h4><p>多线程是一种用于简化控制流、绕过阻塞系统调用的方法，并不专门用于实现程序的并行化。</p><h4 id=并发多线程>并发多线程 <a href=#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b class=anchor>🔗</a></h4><p>物理上并行执行的线程，旨在通过利用多核处理器优化系统性能。</p><h3 id=并发多线程的挑战>“并发多线程”的挑战 <a href=#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%8c%91%e6%88%98 class=anchor>🔗</a></h3><p>尽管并发多线程被广泛讨论，其挑战并非源自自然原因，而是我们自己的设计选择所造成的。主要问题在于，针对单线程程序的过度优化在多线程环境中不再适用。</p><p>具体来说，由于CPU的执行速度远超内存响应速度，我们开始对内存内容进行“预测”，从而避免CPU等待内存检查。这里的“预测”实际上是CPU和编译器对内存状态做出的越来越激进的假设。</p><h2 id=示例分析>示例分析 <a href=#%e7%a4%ba%e4%be%8b%e5%88%86%e6%9e%90 class=anchor>🔗</a></h2><h3 id=写线程示例>写线程示例 <a href=#%e5%86%99%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// 初始时 variable1 = variable2 = 0;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    variable1<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    variable2<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=读线程示例>读线程示例 <a href=#%e8%af%bb%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>while</span> (<span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>    local2 <span style=color:#f92672>=</span> variable2;
</span></span><span style=display:flex><span>    local1 <span style=color:#f92672>=</span> variable1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (local2 <span style=color:#f92672>&gt;</span> local1) {
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>&#34;Error!&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>正常逻辑下，local2 应当始终小于或等于 local1，因为 variable1 总是在 variable2 之后增加。</p><p>然而，现实是否如此？</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ctime&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;pthread.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sys/time.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> variable1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> variable2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#75715e>#define ITERATIONS 200000000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>writer</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>unused) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>        variable1 <span style=color:#f92672>=</span> variable1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>        variable2 <span style=color:#f92672>=</span> variable2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>reader</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>unused) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>timeval</span> start, end;
</span></span><span style=display:flex><span>    gettimeofday(<span style=color:#f92672>&amp;</span>start, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> i, failureCount <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ITERATIONS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> v2 <span style=color:#f92672>=</span> variable2;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>unsigned</span> v1 <span style=color:#f92672>=</span> variable1;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (v2 <span style=color:#f92672>&gt;</span> v1) failureCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    gettimeofday(<span style=color:#f92672>&amp;</span>end, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> seconds <span style=color:#f92672>=</span> end.tv_sec <span style=color:#f92672>+</span> end.tv_usec <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000000.</span> <span style=color:#f92672>-</span> start.tv_sec <span style=color:#f92672>-</span> start.tv_usec <span style=color:#f92672>/</span> <span style=color:#ae81ff>1000000.</span>;
</span></span><span style=display:flex><span>    printf(<span style=color:#e6db74>&#34;%u failure%s (%2.1f percent of the time) in %2.1f seconds</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>,
</span></span><span style=display:flex><span>           failureCount, failureCount <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>?</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;s&#34;</span>,
</span></span><span style=display:flex><span>           (<span style=color:#ae81ff>100.</span> <span style=color:#f92672>*</span> failureCount) <span style=color:#f92672>/</span> ITERATIONS, seconds);
</span></span><span style=display:flex><span>    exit(<span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> NULL;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>) {
</span></span><span style=display:flex><span>    pthread_t thread1, thread2;
</span></span><span style=display:flex><span>    pthread_create(<span style=color:#f92672>&amp;</span>thread1, NULL, writer, NULL);
</span></span><span style=display:flex><span>    pthread_create(<span style=color:#f92672>&amp;</span>thread2, NULL, reader, NULL);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (;;) sleep(<span style=color:#ae81ff>1000000</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>输出结果：<code>0 failures (0.0 percent of the time) in 1.2 seconds</code></p><h3 id=貌似是正确的>貌似是正确的？ <a href=#%e8%b2%8c%e4%bc%bc%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84 class=anchor>🔗</a></h3><p>程序运行的正如我们预期的那样，那么我们可以确信程序是一定正确的吗？</p><p>不能。</p><p>因为程序中的两个线程如果在同一个CPU上被调度，我们永远都会得到正确的结果。</p><h3 id=线程与不同的cpu进行绑定>线程与不同的CPU进行绑定 <a href=#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e4%b8%8d%e5%90%8c%e7%9a%84cpu%e8%bf%9b%e8%a1%8c%e7%bb%91%e5%ae%9a class=anchor>🔗</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>writer</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>unused) {
</span></span><span style=display:flex><span>    cpu_set_t cpuset;
</span></span><span style=display:flex><span>    CPU_ZERO(<span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    CPU_SET(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    sched_setaffinity(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(cpuset), <span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>reader</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>unused) {
</span></span><span style=display:flex><span>    cpu_set_t cpuset;
</span></span><span style=display:flex><span>    CPU_ZERO(<span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    CPU_SET(<span style=color:#ae81ff>2</span>, <span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    sched_setaffinity(<span style=color:#ae81ff>0</span>, <span style=color:#66d9ef>sizeof</span>(cpuset), <span style=color:#f92672>&amp;</span>cpuset);
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// p.s. 我机器是i5双核四线程，所以绑在了CPU0和CPU2上
</span></span></span></code></pre></div><p>结果：<code>0 failures (0.0 percent of the time) in 1.4 seconds</code></p><h3 id=似乎仍然是准确的>似乎仍然是准确的 <a href=#%e4%bc%bc%e4%b9%8e%e4%bb%8d%e7%84%b6%e6%98%af%e5%87%86%e7%a1%ae%e7%9a%84 class=anchor>🔗</a></h3><p>尽管如此，我们考虑到CPU对变量的操作其实是作用在寄存器上，而variable1和variable2紧密相邻，这可能导致它们位于缓存的同一行。因此，它们有可能会同时被写入缓存并一起写回内存。</p><p>为了观察不同的效果，我们尝试将这两个变量分别放置在堆和栈上。</p><div class=mermaid>0 failures (0.0 percent of the time) in 1.2 seconds
0 failures (0.0 percent of the time) in 1.2 seconds
2000000000 failures (100.0 percent of the time) in 1.2 seconds</div><p><strong>太感人了！</strong></p><h3 id=我们的敌人--编译器>我们的敌人 —— 编译器 <a href=#%e6%88%91%e4%bb%ac%e7%9a%84%e6%95%8c%e4%ba%ba--%e7%bc%96%e8%af%91%e5%99%a8 class=anchor>🔗</a></h3><blockquote><p>Multithreading bugs are very delicate.</p></blockquote><p>并行多线程的错误总是那么的奇妙，也许你的程序运行了几天安然无恙，但是在某一天某一时突然出现了难以复现的精妙bug。</p><p>如果多个线程调度在同一个CPU核心上，Bug会被掩盖。<br>如果多个变量在CPU同一行Cache上，Bug会被掩盖。<br>如果你人品足够好的话，Bug同样会被掩盖。</p><p>但是，如果我们排除了以上的情况后，问题就浮现出来了。</p><p>我们来看一看reader的反汇编代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>(gdb) disas reader
</span></span><span style=display:flex><span>Dump of assembler code <span style=color:#66d9ef>for</span> function reader(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400950</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>0</span><span style=color:#f92672>&gt;:</span> push   <span style=color:#f92672>%</span>rbx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400951</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>1</span><span style=color:#f92672>&gt;:</span> xor    <span style=color:#f92672>%</span>eax,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400953</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>3</span><span style=color:#f92672>&gt;:</span> mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x10</span>,<span style=color:#f92672>%</span>ecx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400958</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>8</span><span style=color:#f92672>&gt;:</span> mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x80</span>,<span style=color:#f92672>%</span>esi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040095d</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>13</span><span style=color:#f92672>&gt;:</span>    xor    <span style=color:#f92672>%</span>ebx,<span style=color:#f92672>%</span>ebx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040095f</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>15</span><span style=color:#f92672>&gt;:</span>    sub    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0xa0</span>,<span style=color:#f92672>%</span>rsp
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400966</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>22</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#f92672>%</span>rsp,<span style=color:#f92672>%</span>rdi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400969</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>25</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#f92672>%</span>rsp,<span style=color:#f92672>%</span>rdx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040096c</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>28</span><span style=color:#f92672>&gt;:</span>    rep stos <span style=color:#f92672>%</span>rax,<span style=color:#f92672>%</span>es:(<span style=color:#f92672>%</span>rdi)
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040096f</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>31</span><span style=color:#f92672>&gt;:</span>    xor    <span style=color:#f92672>%</span>edi,<span style=color:#f92672>%</span>edi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400971</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>33</span><span style=color:#f92672>&gt;:</span>    movq   <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x4</span>,(<span style=color:#f92672>%</span>rsp)
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400979</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>41</span><span style=color:#f92672>&gt;:</span>    callq  <span style=color:#ae81ff>0x400790</span> <span style=color:#f92672>&lt;</span>sched_setaffinity<span style=color:#960050;background-color:#1e0010>@</span>plt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040097e</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>46</span><span style=color:#f92672>&gt;:</span>    lea    <span style=color:#ae81ff>0x80</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>rdi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400986</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>54</span><span style=color:#f92672>&gt;:</span>    xor    <span style=color:#f92672>%</span>esi,<span style=color:#f92672>%</span>esi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400988</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>56</span><span style=color:#f92672>&gt;:</span>    callq  <span style=color:#ae81ff>0x400710</span> <span style=color:#f92672>&lt;</span>gettimeofday<span style=color:#960050;background-color:#1e0010>@</span>plt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040098d</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>61</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#ae81ff>0x2006e4</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>rax        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x601078</span> <span style=color:#f92672>&lt;</span>variable2_p<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400994</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>68</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#ae81ff>0x2006e6</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>edx        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x601080</span> <span style=color:#f92672>&lt;</span>variable1<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040099a</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>74</span><span style=color:#f92672>&gt;:</span>    mov    (<span style=color:#f92672>%</span>rax),<span style=color:#f92672>%</span>ecx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x000000000040099c</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>76</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x77359400</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009a1</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>81</span><span style=color:#f92672>&gt;:</span>    nopl   <span style=color:#ae81ff>0x0</span>(<span style=color:#f92672>%</span>rax)
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009a8</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>88</span><span style=color:#f92672>&gt;:</span>    cmp    <span style=color:#f92672>%</span>ecx,<span style=color:#f92672>%</span>edx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009aa</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>90</span><span style=color:#f92672>&gt;:</span>    adc    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x0</span>,<span style=color:#f92672>%</span>ebx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009ad</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>93</span><span style=color:#f92672>&gt;:</span>    sub    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x1</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009b0</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>96</span><span style=color:#f92672>&gt;:</span>    jne    <span style=color:#ae81ff>0x4009a8</span> <span style=color:#f92672>&lt;</span>reader(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>88</span><span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009b2</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>98</span><span style=color:#f92672>&gt;:</span>    lea    <span style=color:#ae81ff>0x90</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>rdi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009ba</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>106</span><span style=color:#f92672>&gt;:</span>   xor    <span style=color:#f92672>%</span>esi,<span style=color:#f92672>%</span>esi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009bc</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>108</span><span style=color:#f92672>&gt;:</span>   callq  <span style=color:#ae81ff>0x400710</span> <span style=color:#f92672>&lt;</span>gettimeofday<span style=color:#960050;background-color:#1e0010>@</span>plt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009c1</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>113</span><span style=color:#f92672>&gt;:</span>   cvtsi2sdq <span style=color:#ae81ff>0x98</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>xmm0
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009cb</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>123</span><span style=color:#f92672>&gt;:</span>   cvtsi2sdq <span style=color:#ae81ff>0x90</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>xmm1
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009d5</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>133</span><span style=color:#f92672>&gt;:</span>   movsd  <span style=color:#ae81ff>0x1a3</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>xmm3        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x400b80</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009dd</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>141</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#f92672>%</span>ebx,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009df</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>143</span><span style=color:#f92672>&gt;:</span>   cvtsi2sdq <span style=color:#ae81ff>0x88</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>xmm2
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009e9</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>153</span><span style=color:#f92672>&gt;:</span>   cmp    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x1</span>,<span style=color:#f92672>%</span>ebx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009ec</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>156</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x400b3d</span>,<span style=color:#f92672>%</span>ecx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009f1</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>161</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x1</span>,<span style=color:#f92672>%</span>edi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009f6</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>166</span><span style=color:#f92672>&gt;:</span>   divsd  <span style=color:#f92672>%</span>xmm3,<span style=color:#f92672>%</span>xmm0
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009fa</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>170</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#f92672>%</span>ebx,<span style=color:#f92672>%</span>edx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x00000000004009fc</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>172</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x400b40</span>,<span style=color:#f92672>%</span>esi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a01</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>177</span><span style=color:#f92672>&gt;:</span>   divsd  <span style=color:#f92672>%</span>xmm3,<span style=color:#f92672>%</span>xmm2
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a05</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>181</span><span style=color:#f92672>&gt;:</span>   addsd  <span style=color:#f92672>%</span>xmm0,<span style=color:#f92672>%</span>xmm1
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a09</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>185</span><span style=color:#f92672>&gt;:</span>   cvtsi2sdq <span style=color:#ae81ff>0x80</span>(<span style=color:#f92672>%</span>rsp),<span style=color:#f92672>%</span>xmm0
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a13</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>195</span><span style=color:#f92672>&gt;:</span>   subsd  <span style=color:#f92672>%</span>xmm0,<span style=color:#f92672>%</span>xmm1
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a17</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>199</span><span style=color:#f92672>&gt;:</span>   cvtsi2sd <span style=color:#f92672>%</span>rax,<span style=color:#f92672>%</span>xmm0
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a1c</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>204</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x400b3c</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a21</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>209</span><span style=color:#f92672>&gt;:</span>   cmovne <span style=color:#f92672>%</span>rax,<span style=color:#f92672>%</span>rcx
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a25</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>213</span><span style=color:#f92672>&gt;:</span>   mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x2</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a2a</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>218</span><span style=color:#f92672>&gt;:</span>   mulsd  <span style=color:#ae81ff>0x156</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>xmm0        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x400b88</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a32</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>226</span><span style=color:#f92672>&gt;:</span>   subsd  <span style=color:#f92672>%</span>xmm2,<span style=color:#f92672>%</span>xmm1
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a36</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>230</span><span style=color:#f92672>&gt;:</span>   divsd  <span style=color:#ae81ff>0x152</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>xmm0        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x400b90</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a3e</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>238</span><span style=color:#f92672>&gt;:</span>   callq  <span style=color:#ae81ff>0x400700</span> <span style=color:#f92672>&lt;</span>__printf_chk<span style=color:#960050;background-color:#1e0010>@</span>plt<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a43</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>243</span><span style=color:#f92672>&gt;:</span>   xor    <span style=color:#f92672>%</span>edi,<span style=color:#f92672>%</span>edi
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>0x0000000000400a45</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>245</span><span style=color:#f92672>&gt;:</span>   callq  <span style=color:#ae81ff>0x4006f0</span> <span style=color:#f92672>&lt;</span>exit<span style=color:#960050;background-color:#1e0010>@</span>plt<span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>简而言之，关键在以下几句：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#ae81ff>0x000000000040098d</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>61</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#ae81ff>0x2006e4</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>rax        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x601078</span> <span style=color:#f92672>&lt;</span>variable2_p<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x0000000000400994</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>68</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#ae81ff>0x2006e6</span>(<span style=color:#f92672>%</span>rip),<span style=color:#f92672>%</span>edx        <span style=color:#960050;background-color:#1e0010>#</span> <span style=color:#ae81ff>0x601080</span> <span style=color:#f92672>&lt;</span>variable1<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x000000000040099a</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>74</span><span style=color:#f92672>&gt;:</span>    mov    (<span style=color:#f92672>%</span>rax),<span style=color:#f92672>%</span>ecx
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x000000000040099c</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>76</span><span style=color:#f92672>&gt;:</span>    mov    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x77359400</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x00000000004009a1</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>81</span><span style=color:#f92672>&gt;:</span>    nopl   <span style=color:#ae81ff>0x0</span>(<span style=color:#f92672>%</span>rax)
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x00000000004009a8</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>88</span><span style=color:#f92672>&gt;:</span>    cmp    <span style=color:#f92672>%</span>ecx,<span style=color:#f92672>%</span>edx
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x00000000004009aa</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>90</span><span style=color:#f92672>&gt;:</span>    adc    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x0</span>,<span style=color:#f92672>%</span>ebx
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x00000000004009ad</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>93</span><span style=color:#f92672>&gt;:</span>    sub    <span style=color:#960050;background-color:#1e0010>$</span><span style=color:#ae81ff>0x1</span>,<span style=color:#f92672>%</span>eax
</span></span><span style=display:flex><span><span style=color:#ae81ff>0x00000000004009b0</span> <span style=color:#f92672>&lt;+</span><span style=color:#ae81ff>96</span><span style=color:#f92672>&gt;:</span>    jne    <span style=color:#ae81ff>0x4009a8</span> <span style=color:#f92672>&lt;</span>reader(<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#f92672>+</span><span style=color:#ae81ff>88</span><span style=color:#f92672>&gt;</span>
</span></span></code></pre></div><p>我们可以看出，循环体在+88～+96行，而对variable1与variable2的取值都放在了循环以外。</p><blockquote><p>注：<br>adc是带进位加法，adc $0x0, %ebx => %ebx = $0x0 + %ebx + CF<br>cmp的结果正是放在CF（大于表示为溢出），ZF（相等表示为0），PF（小于表示为-1,则低8位全为1,故有偶数个1）</p></blockquote><p>正是这个“小意外”，导致了我们的结果要不是100%正确，要不是100%错误。</p><h4 id=使用volitile>使用volitile（？） <a href=#%e4%bd%bf%e7%94%a8volitile class=anchor>🔗</a></h4><p>让我们修改一下代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>unsigned</span> variable1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>volatile</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#f92672>*</span>variable2_p <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span><span style=color:#75715e>#define ITERATIONS 500000000LL </span><span style=color:#75715e>// 调小一下数据规模，因为volatile太慢了_(:з」∠)_
</span></span></span></code></pre></div><p>我得出的来的结果是：</p><div class=mermaid>0 failures (0.0 percent of the time) in 9.6 seconds</div><p>而作者得出的结果是：
（时间上的差异不计，因为我们的数据规模不一样，我实验的次数要多一些。</p><div class=mermaid>fish ) ./a.out
12462711 failures (24.9 percent of the time) in 3.7 seconds</div><p>从作者的结果来看，看起来效果好了很多，虽然慢了30多倍，但是结果并不是全对全错了。</p><p>而从我的结果来看，volatile看似神丹妙药，解决了所有的问题。(both g++ and clang++)</p><p><strong>这是为什么呢?</strong></p><p>其原因在于体系结构的差异。volatile只能保证如下两点：</p><ul><li>volatile变量的访问不会优化成寄存器访问，而是每次都去访问“内存”（这个引号一会再解释）</li><li>volatile变量间的访问顺序不会被编译器乱序</li></ul><p>而其他的一切，volatile和编译器都不会给出任何保证。</p><p>例如，不同的CPU都有其内部的私有Cache，CPU的内存访问，如果命中了Cache，则不会真正的访问内存。但由于其私有Cache对于其它的CPU是不可见的，使用volatile就埋下的Bug的种子。</p><p>虽然在我们的实验中，程序运行的很好，没有出现Bug。但是，一是由于多线程的Bug都是subtle和delicate的，我不能保证在一个需要7x24工作的服务器程序中，它不会出现任何Bug；二是至少我们的代码是** not portable **的，如果有一天，我们从x86-64平台切换到了<code>PowerPC</code>？或是<code>IA64</code>？我们不能保证在这些体系结构上，编译器和CPU能为我们提供同样的保障。</p><p>于是有人高声疾呼： volatile不能用来做为多线程的同步机制！</p><blockquote><p>补充于20240317：在一台老旧的安卓手机上重复了实验，volatile确实无法提供相关的保障</p></blockquote><div class=mermaid>~/tmp $ clang++ -O2 a.cc && ./a.out
99880586 failures (49.9 percent of the time) in 3.0 seconds</div><h4 id=小心cpu的行为>小心CPU的行为 <a href=#%e5%b0%8f%e5%bf%83cpu%e7%9a%84%e8%a1%8c%e4%b8%ba class=anchor>🔗</a></h4><p>在先前的实验中，尽管程序的表现与预期一致，但我们无法确保CPU将始终按顺序执行代码。实际上，CPU可能会对操作顺序进行优化，例如，将var1++和var2++的执行顺序调换，这在当前主流的CPU中是常见的做法。</p><p>值得注意的是，由于乱序执行会导致功耗增加，某些处理器如ARM和Intel Atom已经取消了这一机制。然而，我们无法预知未来代码可能会在哪种硬件架构上运行，例如ARM集群，这需要我们保持警惕。</p><h4 id=避免使用锁>避免使用锁 <a href=#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e9%94%81 class=anchor>🔗</a></h4><p>通常情况下，通过引入互斥锁（mutex）似乎能够解决并发问题。然而，根据作者的测试，引入互斥锁可能会导致程序速度降低至原来的1/130，而自旋锁（spinlock）也可能使得速度降低至原来的1/4。</p><p>因此，我们应该暂缓，仔细考虑作者接下来的建议。</p><h3 id=内存屏障的应用>内存屏障的应用 <a href=#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c%e7%9a%84%e5%ba%94%e7%94%a8 class=anchor>🔗</a></h3><p>在多CPU环境中，处理器往往独立运行，不会协调彼此的操作。</p><p>目前，我们面临两个并不理想的解决方案：一是将所有线程限制在单个CPU上运行，二是通过引入重量级锁来同步操作。这些方法都不尽人意，且效率低下。</p><p>实际上，我们需要做的是，通过内存屏障技术，暂时阻止编译器或CPU对程序中的数据读写操作进行重排序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (;;) {
</span></span><span style=display:flex><span>    variable1 <span style=color:#f92672>=</span> variable1 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    barrier();
</span></span><span style=display:flex><span>    <span style=color:#f92672>*</span>variable2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>variable2 <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样我们保证了，在var1++必然早于var2++。var2++后面也可以加一道barrier，只不过在我们的场景下，提供这种保证是不必须的。</p><p>作者又做了一次试验。</p><div class=mermaid>fish ) ./a.out
260 failures (0.0 percent of the time) in 0.9 seconds</div><p>这次且错误减少了许多。</p><p>我们再把读线程写加上memory barrier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>for</span> (i<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> ITERATIONS; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> v2 <span style=color:#f92672>=</span> <span style=color:#f92672>*</span>variable2;
</span></span><span style=display:flex><span>    barrier();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> v1 <span style=color:#f92672>=</span> variable1;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (v2 <span style=color:#f92672>&gt;</span> v1) failureCount<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>看看结果：</p><div class=mermaid>fish ) ./a.out
0 failures (0.0 percent of the time) in 4.2 seconds</div><p>程序表现出了正确的结果。</p><p>我们可以看出，如果你对线程A的读写顺序做出要求，必然的，你也要对线程B的顺序做要求，以此类推，线程C，线程D……</p><p>所以，<strong>Memory barriers always come in pairs, or triplets or more.</strong></p><p>同样的，线程锁也是这样的，自己锁自己总不是一种愉快的体验（笑</p><h3 id=cpu的乱序执行>CPU的乱序执行 <a href=#cpu%e7%9a%84%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c class=anchor>🔗</a></h3><p>我们可以看到PowerPC有三种内存屏障，而DEC Alpha平台有更多。这意味着，CPU使用更激进的策略来重排指令，而强制限制其重排的代价是非常高的。</p><p>而x86平台则非常守序，作者猜测其原因是由于早期x86的指令技术并非完善，而在那时内存与CPU的速度不像现在这样悬殊，所以x86使用了<code>strongly ordered memory</code>而非像上面几款CPU一样的采用过多的指令重排序。如今，由于x86背上了向前兼容性的包袱，看似我们的"好日子"一直不会结束。</p><p>x86-64，做为x86的64位升级版，同样没有实现<code>weakly ordered</code>，或者说，保留了实现<code>weakly ordered</code>的权利。而<code>IA64</code>平台，如<code>Itanium</code>，则实现了<code>weakly ordered</code>。</p><p>作者猜测x86_64之所以保守，是为了与IA64平台对抗。x86_64的对于x86良好的兼容性可以让程序员多活几年，所以x86_64在市场的表现更好。</p><p>作者还表示，而苹果放弃IA64平台转投x86-64多少有一些可惜，因为苹果并没有移植性问题，PowerPC已经逐渐衰落，为什么不试试IA64呢。</p><p>实际上，根据Wikipedia，现在支持IA64的操作系统非常少，只有WinNT Family，Red Hat Linux，Debian/Gentoo/Suse以及其它。而从Windows Server 2008 R2之后，Microsoft也表示不再支持Itanium。所以从现在看来，IA64平台相对x86/x64来说，是失败的。</p><h3 id=双重检查锁>双重检查锁 <a href=#%e5%8f%8c%e9%87%8d%e6%a3%80%e6%9f%a5%e9%94%81 class=anchor>🔗</a></h3><p>让我们看一下如下的Obj-C代码</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>+ <span style=color:#a6e22e>getSharedObject</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> sharedObject;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>        LOCK;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>            sharedObject <span style=color:#f92672>=</span> [[self alloc] init];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        UNLOCK;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sharedObject;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这是非常经典的一种DCLP(Double Checked Lock Pattern)的实现。</p><p>这个看起来不错，但是你已经知道这并不靠谱了。当我们初始化我们的共享单例，先要再修改类内的指针，使其指向一块声明好的内存，再初始化一个sharedObject的instance。</p><p>不过，你是知道的，CPU和编译器会把一切都搞砸，它们会以任意的顺序执行我们的命令，同时处理器之间互相不通气，于是就会出现如下的情况：</p><p>线程A为指针声明了一段空间，但是还没来及初始化这个instance，线程A就被挂起了。</p><p>之后线程B接管一切，发现指针有值，结果因为访问了野指针导致程序挂掉。</p><p>不过根据上面的文章，你们应该知道怎么处理这个问题了 —— 试试内存屏障！</p><p>p.s. 如果大家对obj-c不熟悉的话，可以看我另外一篇文章。那篇文章是关于Scott Meyers大神写的一篇论文，专门用来讨论DCLP问题的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-objc data-lang=objc><span style=display:flex><span>+ <span style=color:#a6e22e>getSharedObject</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> sharedObject;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>        LOCK;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>id</span> temp <span style=color:#f92672>=</span> [[self alloc] init];
</span></span><span style=display:flex><span>            OSMemoryBarrier();
</span></span><span style=display:flex><span>            sharedObject <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        UNLOCK;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    OSMemoryBarrier();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sharedObject;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>而在《C++ and the Perils of Double-Checked Locking》一文中，Scott Meyers和Andrei Alexandrescu给出的解决方案如下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Singleton<span style=color:#f92672>*</span> Singleton<span style=color:#f92672>::</span>instance () {
</span></span><span style=display:flex><span>    Singleton<span style=color:#f92672>*</span> tmp <span style=color:#f92672>=</span> pInstance;
</span></span><span style=display:flex><span>    <span style=color:#75715e>// insert memory barrier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// clear the cache to flush ``pInstance``
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// prevents &#34;downwards migration&#34; of Singleton’s construction (by another thread);
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (tmp <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        Lock lock;
</span></span><span style=display:flex><span>        tmp <span style=color:#f92672>=</span> pInstance;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (tmp <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>            tmp <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton;
</span></span><span style=display:flex><span>            <span style=color:#75715e>// insert memory barrier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// prevent optimistic that eliminate the temporary variable ``tmp``
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#75715e>// prevents &#34;upwards migration&#34; of pInstance’s initialization
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            pInstance <span style=color:#f92672>=</span> tmp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>  tmp;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>两种解决方案的memory barrier插入的位置不同。但是都不能说是错的。因为一个是传static instance，一个是传pointer。</p><p>其实还有更“暴力”的方法。</p><p>直接来一把大锁，哐当把整个函数锁起来，并且在每一个线程内保留一个<strong>本线程专属</strong>指向单例的指针（做cache）。这样N个线程只需要调用这个函数N次，线程竞争也相对少很多。并且根据Linux下的futex技术，无竞争下的锁相对节省了不少资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>Singleton<span style=color:#f92672>*</span> Singleton<span style=color:#f92672>::</span>instance() {
</span></span><span style=display:flex><span>    Lock lock;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(pInstance <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        pInstance <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Singleton;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> pInstance;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=我们真的需要这么做吗>我们真的需要这么做吗 <a href=#%e6%88%91%e4%bb%ac%e7%9c%9f%e7%9a%84%e9%9c%80%e8%a6%81%e8%bf%99%e4%b9%88%e5%81%9a%e5%90%97 class=anchor>🔗</a></h3><p>上面的obj-c代码中，保证双重检查锁正确的，其实是第二个内存屏障。但是，在那里，我们需要的其实是一个"data dependency barrier"。</p><p>Linux内核中给出很多经过精心优化的内存屏障，我们在这里可以使用。不过，要在使用的时候写好注释，一是为了未来的验证，二是为了记录自己当时的思路。</p><p>毕竟多线程的操作要小心再小心，我们需要充足的理由，更多的小心来应对。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-obj-c data-lang=obj-c><span style=display:flex><span>+ <span style=color:#a6e22e>getSharedObject</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>id</span> sharedObject;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>        LOCK;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span> sharedObject) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>id</span> temp <span style=color:#f92672>=</span> [[self alloc] init];
</span></span><span style=display:flex><span>            OSMemoryBarrier();
</span></span><span style=display:flex><span>            sharedObject <span style=color:#f92672>=</span> temp;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        UNLOCK;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>/* data dependency memory barrier here */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sharedObject;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=一切都结束了吗>一切都结束了吗？ <a href=#%e4%b8%80%e5%88%87%e9%83%bd%e7%bb%93%e6%9d%9f%e4%ba%86%e5%90%97 class=anchor>🔗</a></h3><p>是的。不过让我们总结一下吧。</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-tk-pic/barrier_tank.png alt="Mutex Tank"></p><ul><li>处理器和编译器并不能充分保证代码执行的顺序，它们会把你的代码到处移动。所以<strong>Be warned and wary!</strong></li><li>多线程的错误是非常subtle和delicate的，所以我们很难设计测试用例</li><li>因此，别指责QA了，他们也不是故意的。RD要对自己的代码负责</li><li>锁很安全，但是也很重</li><li>内存屏障是一种更快的，不阻塞的，不会死锁的一种锁的替代物。它们总要花费更多的心思，并且也不是到处可用的银弹。但是它确实很快，有更好的伸缩性。</li><li>内存屏障往往是成对出现的。了解第二个内存屏障要出现在哪里，有助于你理解你的代码，即使你所使用的体系结构不需要第二个内存屏障。</li></ul><h3 id=扩展阅读>扩展阅读 <a href=#%e6%89%a9%e5%b1%95%e9%98%85%e8%af%bb class=anchor>🔗</a></h3><p><a href=https://www.kernel.org/doc/Documentation/memory-barriers.txt>LINUX KERNEL MEMORY BARRIERS</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.8112">Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors</a></p></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>