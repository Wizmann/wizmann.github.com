<!doctype html><html lang=zh-CN dir=ltr><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://wizmann.top/ style=color:inherit>Maerlyn's Rainbow</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a aria-current=true class=ancestor href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><div class=single-header><ol class=breadcrumbs itemscope itemtype=https://schema.org/BreadcrumbList><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/><span itemprop=name></span>
</a><meta itemprop=position content='1'></li><span>&nbsp»&nbsp</span><li itemprop=itemListElement itemscope itemtype=https://schema.org/ListItem><a itemprop=item href=https://wizmann.top/posts/><span itemprop=name>Posts</span>
</a><meta itemprop=position content='2'></li><span>&nbsp»&nbsp</span></ol><h1>Parallel patterns in C#</h1><time class=dim datetime=2017-01-22T22:52:28+00:00>January 22, 2017</time><div class=term-container><div class=tag><a href=https://wizmann.top/tags/csharp/>#csharp</a></div><div class=tag><a href=https://wizmann.top/tags/parallel/>#parallel</a></div><div class=tag><a href=https://wizmann.top/tags/thread/>#thread</a></div><div class=tag><a href=https://wizmann.top/tags/async/>#async</a></div></ol></div><section class=page-section><h2 id=写在前面>写在前面</h2><p>与C/C++所使用的，传统的基于线程的并行模式不同，C#实现了丰富的并发编程模型，其中以异步模型最为流行。</p><p>本文中我们重点讨论C#在发展过程中出现的几种异步编程模型：</p><ul><li>Async Programming Model（APM）</li><li>Event-based Async Pattern (EAP)</li><li>Task-based Async Pattern（TAP）</li><li>async/await语法糖</li></ul><h2 id=异步编程入门>异步编程入门</h2><p>同步模式是最常见，也是最被人熟知的编程模型，每一个任务按顺序执行，前一个任务执行完之后才会执行下一个任务。</p><p>异步编程和同步编程不同，程序的执行流程是由“事件”所驱动的。异步编程有两种实现方式，回调与future模式。</p><p>回调函数在Javascript中被大量使用，相信大家也都不会陌生。但是大量的回调函数会让代码失去可读性，陷入“Callback hell”。</p><p>Promise模式是回调函数的一种“包装”。我们使用一个占位符来表示“未来”将会产生的一个异步处理结果。</p><p>这个占位符在不同的语言/框架里面有不同的名字，其定义也不尽相同：</p><ul><li>Task - C#</li><li>Deferred - Python Twisted</li><li>Promise - Javascript</li></ul><p>在任务结束后，会触发绑定在这个占位符上定义的回调函数，继续预定义好的逻辑。</p><p>举个例子，同步模型就是你：</p><p>宅家想吃饭 -> 下楼买饭 -> 上楼 -> 吃饭 -> 打游戏看漂亮小姐姐。</p><p>而异步模型呢，就是：</p><p>宅家想吃饭 -> 手机叫外卖 -> 拿到了外卖定单（拿到占位符 或 注册回调）-> 打游戏看漂亮小姐姐 -> 外卖小哥把饭送上门（启动回调） -> 吃饭 -> 继续打游戏看漂亮小姐姐。</p><p>虽然从上面看，异步模型比同步模型要复杂一些。但是它却节省了耗时的“上下楼买饭”的时间，让你可以分配更多的时间用来看漂亮小姐姐。这和我们写程序时的思路是一致的，节省动辄十几几十毫秒耗时的IO时间，将更多的时间用在CPU上。</p><h2 id=thread-based-parallel>Thread Based Parallel</h2><p>基于线程的并发模型是比较传统的并发模型了，基本上所有的现代编程语言都会支持。C#中Thread的用法与Java类似，这里就不做展开。</p><p>与此同时，C#还支持Thread pool，用来运行"long-running processor-bound tasks"。</p><p>直接操作线程也许是中年程序员的必修课，但是手动管理线程会给程序带来额外的负担。所以各种模型与框架应运而生，试图降低并发编程的复杂度。</p><h2 id=async-programming-model-apm>Async Programming Model (APM)</h2><p>在我们熟悉的async/await语法糖出现之前，C#中使用APM来表示异步操作。虽然这是一种上古时期的回调模式语法，但是现在有很多库仍旧支持这种风格。如Azure Storage SDK中的<code>CloudTable.BeginExecute</code>等一系列函数。</p><p>下面是一个简单的使用APM模式的代码范例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Runtime.Remoting.Messaging;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Runtime.Remoting.Proxies;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication6
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> AsyncInvoke();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> SI = <span style=color:#66d9ef>new</span> AsyncInvoke(MyCall);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> ar = SI.BeginInvoke(MyCallback, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Main()&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (!ar.AsyncWaitHandle.WaitOne(<span style=color:#ae81ff>1000</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Main() waiting...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Main() done&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> MyCall()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>5</span>; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;running...&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;done&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> MyCallback(IAsyncResult iResult)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> result = iResult <span style=color:#66d9ef>as</span> AsyncResult;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> si = (AsyncInvoke) result.AsyncDelegate;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> ret = si.EndInvoke(result);
</span></span><span style=display:flex><span>            Console.WriteLine(ret);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果如下：</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-19/26234044-file_1484828912411_150f3.gif alt></p><p>我们可以看到：</p><ol><li>我们将<code>MyCall()</code>“包装”在一个<code>delegate</code>中，然后调用<code>BeginInvoke</code>函数实现异步执行。这个delegate的执行不会阻塞main thread。</li><li>一个异步执行的<code>delegate</code>可以有一个回调，这个回调在delegate执行完后被触发。</li><li>我们可以"long-polling"等待一个异步调用执行完。这里的“执行完”不包括条目2提到的回调（小心race condition！）。</li><li>异步执行的结果可以通过<code>delegate.EndInvoke(IAsyncResult)</code>函数获取到异步调用的结果。</li><li>由条目3我们可以知道，在callback函数中获取异步调用的结果是最合适的。</li></ol><p>所以APM风格的代码写起来非常像javascript中的回调写法，如果逻辑复杂的话，维护起来会是一个大坑。</p><h2 id=event-asynchronous-pattern-eap>Event Asynchronous Pattern (EAP)</h2><p>EAP是回调函数的另一种封装。</p><p>我们来看下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.ComponentModel;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication2
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringEventArgs</span> : EventArgs
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Content { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>event</span> EventHandler&lt;StringEventArgs&gt; _eventHandler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Solution()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _eventHandler += Handle1;
</span></span><span style=display:flex><span>            _eventHandler += Handle2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Run()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _eventHandler?.Invoke(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>new</span> StringEventArgs()
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Content = <span style=color:#e6db74>&#34;123&#34;</span>
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Handle1(<span style=color:#66d9ef>object</span> sender, StringEventArgs args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Handle1 &#34;</span> + args.Content);
</span></span><span style=display:flex><span>            Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Handle2(<span style=color:#66d9ef>object</span> sender, StringEventArgs args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Handle2 &#34;</span> + args.Content);
</span></span><span style=display:flex><span>            Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Solution sol = <span style=color:#66d9ef>new</span> Solution();
</span></span><span style=display:flex><span>            sol.Run();
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Done&#34;</span>);
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果如下：</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-20/46892581-file_1484911655343_68ae.gif alt></p><p>我们可以看出，所有的函数都执行在同一个线程上。并且<code>Handle1</code>和<code>Handle2</code>顺序执行。</p><p>在实际工程中，我们fire event的代码可以在不同的线程，之后<code>EventHandler</code>，也就是callback函数会被调用。</p><p>Event同时支持<code>BeginInvoke</code>和<code>EndInvoke</code>函数，也就意味着我们可以异步的fire相应的回调。但是注意此时我们只能注册唯一的回调，因为<code>BeginInvoke</code>只能有一个目标回调（原理：在同一时间同一线程只能有一个函数调用）。</p><h2 id=task-asynchronous-pattern-tap>Task Asynchronous Pattern (TAP)</h2><p>在.NET 4.0（现在已经到6.0了哦），C#引入了TPL，Task Parallel Library。Task的目标是统一C#中的不同异步编程风格。</p><p>TPL中的Task非常像JS中的promise和twisted中的deferred，是“未来会完成的操作的结果”的占位符。</p><p>我们来看一段简单代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication3
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Task t = Task.Run(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Task start&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>2000</span>);
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Task end&#34;</span>);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (!t.IsCompleted)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Main(): Task is running...&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Done&#34;</span>);
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码我们前面提到的APM和EAP风格的代码有明显的不同，TAP更易读，并且保持了控制流的完整性。不像APM需要在<code>EndInvoke</code>函数中获取返回值以及进行后续操作，也不像EAP一样需要根据不同的event声明不同的回调。</p><p>Task也可能“串起来”，实现多级回调的机制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication4
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t0 = Task.Run(() =&gt; <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t1 = t0.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t2 = t1.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t3 = t2.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当然我们还可以把回调写成一棵树状结构，然后一层一层的执行，不过生命是如此宝贵，我们并没有充分的理由要这么做。</p><h2 id=asyncawait语法糖>async/await语法糖</h2><p>async/await语法糖在C# 5.0中被引入，其目的是为了避免回调带来的代码复杂度。就像Twisted中的<code>@inlineCallbacks</code>一样，省去了defer复杂的回调链。</p><p><code>await</code>中有一个"wait"，说明这是一个“等待”操作。它等待的是相应的Task执行完成。</p><p>我们来看一段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> DumpWebPageAsync(<span style=color:#66d9ef>string</span> uri)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WebClient webClient = <span style=color:#66d9ef>new</span> WebClient();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> page = <span style=color:#66d9ef>await</span> webClient.DownloadStringTaskAsync(uri);
</span></span><span style=display:flex><span>    Console.WriteLine(page);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当代码执行到<code>await</code>一行时，当前函数会主动放弃当前的控制流。当使用<code>await</code>修饰的Task完成后，当前函数会从之前中断的地方继续执行。</p><p>这样做的好处是我们可以写出和同步版本非常相似的异步代码，只需要在必须的地方加上<code>await</code>关键字，提醒编译器这里是一个异步函数，需要额外的处理逻辑，但这一切都是对开发者透明的。</p><h3 id=asyncawait干了什么>async/await干了什么</h3><p>想弄清楚async/await到底干了什么，首先我们要想明白线程到底是什么、干了什么。</p><p>线程是进程内一条执行流的状态，其中包括了硬件状态（IP、Registers等）以及堆栈（栈上的局部变量和堆上的进程级内存）。那么如果我们想实现挂起/启动（Hibernating and Resuming），那么我们就要有一个机制来保存当前线程的运行状态。</p><p>所以当你写下了async/await关键字后，编译器在后面帮助你生成了状态保存和恢复运行上下文的代码。</p><h3 id=asyncawait到底干了什么>async/await到底干了什么</h3><p>想像我们有一个复杂的async函数，里面有很多个await调用，那就意味着这个函数中会有多次挂起/继续操作。同时我们还要维护这个函数的状态。如果我们是这个语法糖的设计者，我们会选择怎么样的手段来处理这个问题呢？</p><p>是的，状态机。async/await避免了代码的碎片化，它的解决方案并不是消灭了回调函数和Continuation Tasks，而是使用工具（编译器）来帮助人类进行重复劳动。当async函数从挂起中恢复时，会调用<code>MoveNext</code>函数（相信看过async函数那一长串的traceback的同学肯定对这个函数非常眼熟），<code>MoveNext</code>函数会在async函数第一次被调用以及从挂起中恢复时被调用。状态机保存了当前函数的执行状态，当<code>MoveNext</code>函数被调用时，会根据当前状态来判断接下来执行什么代码。</p><h3 id=asycnawait到底tmd干了什么>asycn/await到底TMD干了什么</h3><p>由于async/awaic语法糖是在编译期才被翻译成相应的程序代码，所以我们只能使用IL反编译器来窥探编译器到底做了怎样的处理与优化。不过反编译器你懂得，生成的代码基本没法看，讲解起来也会非常晦涩。</p><p>幸好在99%的情况下，我们并不需要知道async/await是怎样被展开的。如果你确实对这个问题感兴趣，可以参考这篇文章：<a href=https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine>Async Await and the Generated StateMachine</a>。</p><h2 id=几个常见的坑>几个常见的坑</h2><h3 id=await-与-锁>await 与 锁</h3><p>由于await会中断当前函数在当前线程的执行流，并且可能在恢复时，被指派到另外的线程。所以对await加锁明显是多此一举的。并且如果操作不当，还会造成死锁。</p><p>所以我们应该把await放到加锁的区域外。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>lock</span> (sync)
</span></span><span style=display:flex><span>{    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Prepare for async operation</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> myNum = <span style=color:#66d9ef>await</span> AlexsMethodAsync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>lock</span> (sync)
</span></span><span style=display:flex><span>{    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Use result of async operation</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=there-is-an--unfired-task-between-us>&ldquo;There is an &mldr; unfired Task between us&rdquo;</h3><p>一个async函数如果返回的是Task，那么它返回的一定是一个hot task，即已经被启动了的Task。</p><p>并且await只可能等待一个启动了的Task，否则await操作将会hang住，破坏程序既定的执行流。</p><h3 id=使用tpl-task-parallel-library>使用TPL (Task parallel library)</h3><blockquote><p>Async methods are synchronous util needed.</p></blockquote><p>如果我们想同时执行几个异步操作，使用for来遍历执行可不是一个好主意。因为这样函数执行流仍然是顺序执行相应的函数。</p><p>TPL提供了<code>WhenAll</code>、<code>WhenAny</code>等函数，让我们可以有弹性的并发执行Task。</p><p>当然我们还可以使用PLINQ，不过这就是另外一个话题了。</p><h2 id=参考链接>参考链接</h2><ul><li><a href=https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine>Async Await and the Generated StateMachine</a></li><li><a href=http://blog.stephencleary.com/2012/07/async-interop-with-iasyncresult.html>Async Interop with IAsyncResult</a></li><li><a href="https://msdn.microsoft.com/en-us/library/wewwczdw(v=vs.110).aspx">Event-based Asynchronous Pattern Overview</a></li><li><a href=https://www.safaribooksonline.com/library/view/async-in-c/9781449337155/>Async in C# 5.0</a></li><li><a href=https://www.safaribooksonline.com/library/view/essential-c-60/9780134176147/>Essential C# 6.0</a> Cpt18</li></ul></section></main><footer id=main-footer><div class=footer><a href=#></a><div class=footer-copyright><div class=dim>© 2025</div><div></div></div></div></footer></div><aside id=side-pane class=side-sticky><div class=side-details><span>3843 </span><span>13 - 16</span></div><h3></h3><nav id=TableOfContents><ul><li><a href=#写在前面>写在前面</a></li><li><a href=#异步编程入门>异步编程入门</a></li><li><a href=#thread-based-parallel>Thread Based Parallel</a></li><li><a href=#async-programming-model-apm>Async Programming Model (APM)</a></li><li><a href=#event-asynchronous-pattern-eap>Event Asynchronous Pattern (EAP)</a></li><li><a href=#task-asynchronous-pattern-tap>Task Asynchronous Pattern (TAP)</a></li><li><a href=#asyncawait语法糖>async/await语法糖</a><ul><li><a href=#asyncawait干了什么>async/await干了什么</a></li><li><a href=#asyncawait到底干了什么>async/await到底干了什么</a></li><li><a href=#asycnawait到底tmd干了什么>asycn/await到底TMD干了什么</a></li></ul></li><li><a href=#几个常见的坑>几个常见的坑</a><ul><li><a href=#await-与-锁>await 与 锁</a></li><li><a href=#there-is-an--unfired-task-between-us>&ldquo;There is an &mldr; unfired Task between us&rdquo;</a></li><li><a href=#使用tpl-task-parallel-library>使用TPL (Task parallel library)</a></li></ul></li><li><a href=#参考链接>参考链接</a></li></ul></nav><h3></h3><ul><li><a href=/posts/twisted-defer-and-deferredqueue/>Twisted Defer and DeferredQueue</a></li><li><a href=/posts/read-paper-barrier/>内存屏障初探</a></li></ul></aside></div></div></body></html>