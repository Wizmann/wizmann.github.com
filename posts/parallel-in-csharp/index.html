<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>Parallel patterns in C#</h1><div class=tip><time datetime="2017-01-22 22:52:28 +0000 UTC">2017/01/22</time>
<span class=split>·</span>
<span>3862 words </span><span class=split>·</span>
<span>8 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/csharp>csharp</a>
<a href=/tags/parallel>parallel</a>
<a href=/tags/thread>thread</a>
<a href=/tags/async>async</a></div></div><hr><div class=content><h2 id=写在前面>写在前面 <a href=#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2 class=anchor>🔗</a></h2><p>与C/C++所使用的，传统的基于线程的并行模式不同，C#实现了丰富的并发编程模型，其中以异步模型最为流行。</p><p>本文中我们重点讨论C#在发展过程中出现的几种异步编程模型：</p><ul><li>Async Programming Model（APM）</li><li>Event-based Async Pattern (EAP)</li><li>Task-based Async Pattern（TAP）</li><li>async/await语法糖</li></ul><h2 id=异步编程入门>异步编程入门 <a href=#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8 class=anchor>🔗</a></h2><p>同步模式是最常见，也是最被人熟知的编程模型，每一个任务按顺序执行，前一个任务执行完之后才会执行下一个任务。</p><p>异步编程和同步编程不同，程序的执行流程是由“事件”所驱动的。异步编程有两种实现方式，回调与future模式。</p><p>回调函数在Javascript中被大量使用，相信大家也都不会陌生。但是大量的回调函数会让代码失去可读性，陷入“Callback hell”。</p><p>Promise模式是回调函数的一种“包装”。我们使用一个占位符来表示“未来”将会产生的一个异步处理结果。</p><p>这个占位符在不同的语言/框架里面有不同的名字，其定义也不尽相同：</p><ul><li>Task - C#</li><li>Deferred - Python Twisted</li><li>Promise - Javascript</li></ul><p>在任务结束后，会触发绑定在这个占位符上定义的回调函数，继续预定义好的逻辑。</p><p>举个例子，同步模型就是你：</p><p>宅家想吃饭 -> 下楼买饭 -> 上楼 -> 吃饭 -> 打游戏看漂亮小姐姐。</p><p>而异步模型呢，就是：</p><p>宅家想吃饭 -> 手机叫外卖 -> 拿到了外卖定单（拿到占位符 或 注册回调）-> 打游戏看漂亮小姐姐 -> 外卖小哥把饭送上门（启动回调） -> 吃饭 -> 继续打游戏看漂亮小姐姐。</p><p>虽然从上面看，异步模型比同步模型要复杂一些。但是它却节省了耗时的“上下楼买饭”的时间，让你可以分配更多的时间用来看漂亮小姐姐。这和我们写程序时的思路是一致的，节省动辄十几几十毫秒耗时的IO时间，将更多的时间用在CPU上。</p><h2 id=thread-based-parallel>Thread Based Parallel <a href=#thread-based-parallel class=anchor>🔗</a></h2><p>基于线程的并发模型是比较传统的并发模型了，基本上所有的现代编程语言都会支持。C#中Thread的用法与Java类似，这里就不做展开。</p><p>与此同时，C#还支持Thread pool，用来运行"long-running processor-bound tasks"。</p><p>直接操作线程也许是中年程序员的必修课，但是手动管理线程会给程序带来额外的负担。所以各种模型与框架应运而生，试图降低并发编程的复杂度。</p><h2 id=async-programming-model-apm>Async Programming Model (APM) <a href=#async-programming-model-apm class=anchor>🔗</a></h2><p>在我们熟悉的async/await语法糖出现之前，C#中使用APM来表示异步操作。虽然这是一种上古时期的回调模式语法，但是现在有很多库仍旧支持这种风格。如Azure Storage SDK中的<code>CloudTable.BeginExecute</code>等一系列函数。</p><p>下面是一个简单的使用APM模式的代码范例：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Runtime.Remoting.Messaging;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Runtime.Remoting.Proxies;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication6
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>delegate</span> <span style=color:#66d9ef>int</span> AsyncInvoke();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> SI = <span style=color:#66d9ef>new</span> AsyncInvoke(MyCall);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> ar = SI.BeginInvoke(MyCallback, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Main()&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (!ar.AsyncWaitHandle.WaitOne(<span style=color:#ae81ff>1000</span>))
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Main() waiting...&#34;</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Main() done&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> MyCall()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; <span style=color:#ae81ff>5</span>; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;running...&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>500</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;done&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>42</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> MyCallback(IAsyncResult iResult)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> result = iResult <span style=color:#66d9ef>as</span> AsyncResult;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> si = (AsyncInvoke) result.AsyncDelegate;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> ret = si.EndInvoke(result);
</span></span><span style=display:flex><span>            Console.WriteLine(ret);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果如下：</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-19/26234044-file_1484828912411_150f3.gif alt></p><p>我们可以看到：</p><ol><li>我们将<code>MyCall()</code>“包装”在一个<code>delegate</code>中，然后调用<code>BeginInvoke</code>函数实现异步执行。这个delegate的执行不会阻塞main thread。</li><li>一个异步执行的<code>delegate</code>可以有一个回调，这个回调在delegate执行完后被触发。</li><li>我们可以"long-polling"等待一个异步调用执行完。这里的“执行完”不包括条目2提到的回调（小心race condition！）。</li><li>异步执行的结果可以通过<code>delegate.EndInvoke(IAsyncResult)</code>函数获取到异步调用的结果。</li><li>由条目3我们可以知道，在callback函数中获取异步调用的结果是最合适的。</li></ol><p>所以APM风格的代码写起来非常像javascript中的回调写法，如果逻辑复杂的话，维护起来会是一个大坑。</p><h2 id=event-asynchronous-pattern-eap>Event Asynchronous Pattern (EAP) <a href=#event-asynchronous-pattern-eap class=anchor>🔗</a></h2><p>EAP是回调函数的另一种封装。</p><p>我们来看下面的代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.ComponentModel;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication2
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StringEventArgs</span> : EventArgs
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>string</span> Content { <span style=color:#66d9ef>get</span>; <span style=color:#66d9ef>set</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Solution</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>event</span> EventHandler&lt;StringEventArgs&gt; _eventHandler;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> Solution()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _eventHandler += Handle1;
</span></span><span style=display:flex><span>            _eventHandler += Handle2;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Run()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            _eventHandler?.Invoke(<span style=color:#66d9ef>this</span>, <span style=color:#66d9ef>new</span> StringEventArgs()
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Content = <span style=color:#e6db74>&#34;123&#34;</span>
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Handle1(<span style=color:#66d9ef>object</span> sender, StringEventArgs args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Handle1 &#34;</span> + args.Content);
</span></span><span style=display:flex><span>            Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>void</span> Handle2(<span style=color:#66d9ef>object</span> sender, StringEventArgs args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Handle2 &#34;</span> + args.Content);
</span></span><span style=display:flex><span>            Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Solution sol = <span style=color:#66d9ef>new</span> Solution();
</span></span><span style=display:flex><span>            sol.Run();
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Done&#34;</span>);
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>运行结果如下：</p><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-20/46892581-file_1484911655343_68ae.gif alt></p><p>我们可以看出，所有的函数都执行在同一个线程上。并且<code>Handle1</code>和<code>Handle2</code>顺序执行。</p><p>在实际工程中，我们fire event的代码可以在不同的线程，之后<code>EventHandler</code>，也就是callback函数会被调用。</p><p>Event同时支持<code>BeginInvoke</code>和<code>EndInvoke</code>函数，也就意味着我们可以异步的fire相应的回调。但是注意此时我们只能注册唯一的回调，因为<code>BeginInvoke</code>只能有一个目标回调（原理：在同一时间同一线程只能有一个函数调用）。</p><h2 id=task-asynchronous-pattern-tap>Task Asynchronous Pattern (TAP) <a href=#task-asynchronous-pattern-tap class=anchor>🔗</a></h2><p>在.NET 4.0（现在已经到6.0了哦），C#引入了TPL，Task Parallel Library。Task的目标是统一C#中的不同异步编程风格。</p><p>TPL中的Task非常像JS中的promise和twisted中的deferred，是“未来会完成的操作的结果”的占位符。</p><p>我们来看一段简单代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication3
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Task t = Task.Run(() =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Task start&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>2000</span>);
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Task end&#34;</span>);
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>while</span> (!t.IsCompleted)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(<span style=color:#e6db74>&#34;Main(): Task is running...&#34;</span>);
</span></span><span style=display:flex><span>                Thread.Sleep(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.WriteLine(<span style=color:#e6db74>&#34;Done&#34;</span>);
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这段代码我们前面提到的APM和EAP风格的代码有明显的不同，TAP更易读，并且保持了控制流的完整性。不像APM需要在<code>EndInvoke</code>函数中获取返回值以及进行后续操作，也不像EAP一样需要根据不同的event声明不同的回调。</p><p>Task也可能“串起来”，实现多级回调的机制。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>using</span> System;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Collections.Generic;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Linq;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Text;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading.Tasks;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> ConsoleApplication4
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Program</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Main(<span style=color:#66d9ef>string</span>[] args)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t0 = Task.Run(() =&gt; <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t1 = t0.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t2 = t1.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> t3 = t2.ContinueWith((antecedent) =&gt;
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                Console.WriteLine(antecedent.Result);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> antecedent.Result + <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            Console.ReadLine();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当然我们还可以把回调写成一棵树状结构，然后一层一层的执行，不过生命是如此宝贵，我们并没有充分的理由要这么做。</p><h2 id=asyncawait语法糖>async/await语法糖 <a href=#asyncawait%e8%af%ad%e6%b3%95%e7%b3%96 class=anchor>🔗</a></h2><p>async/await语法糖在C# 5.0中被引入，其目的是为了避免回调带来的代码复杂度。就像Twisted中的<code>@inlineCallbacks</code>一样，省去了defer复杂的回调链。</p><p><code>await</code>中有一个"wait"，说明这是一个“等待”操作。它等待的是相应的Task执行完成。</p><p>我们来看一段代码：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>void</span> DumpWebPageAsync(<span style=color:#66d9ef>string</span> uri)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    WebClient webClient = <span style=color:#66d9ef>new</span> WebClient();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>string</span> page = <span style=color:#66d9ef>await</span> webClient.DownloadStringTaskAsync(uri);
</span></span><span style=display:flex><span>    Console.WriteLine(page);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>当代码执行到<code>await</code>一行时，当前函数会主动放弃当前的控制流。当使用<code>await</code>修饰的Task完成后，当前函数会从之前中断的地方继续执行。</p><p>这样做的好处是我们可以写出和同步版本非常相似的异步代码，只需要在必须的地方加上<code>await</code>关键字，提醒编译器这里是一个异步函数，需要额外的处理逻辑，但这一切都是对开发者透明的。</p><h3 id=asyncawait干了什么>async/await干了什么 <a href=#asyncawait%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88 class=anchor>🔗</a></h3><p>想弄清楚async/await到底干了什么，首先我们要想明白线程到底是什么、干了什么。</p><p>线程是进程内一条执行流的状态，其中包括了硬件状态（IP、Registers等）以及堆栈（栈上的局部变量和堆上的进程级内存）。那么如果我们想实现挂起/启动（Hibernating and Resuming），那么我们就要有一个机制来保存当前线程的运行状态。</p><p>所以当你写下了async/await关键字后，编译器在后面帮助你生成了状态保存和恢复运行上下文的代码。</p><h3 id=asyncawait到底干了什么>async/await到底干了什么 <a href=#asyncawait%e5%88%b0%e5%ba%95%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88 class=anchor>🔗</a></h3><p>想像我们有一个复杂的async函数，里面有很多个await调用，那就意味着这个函数中会有多次挂起/继续操作。同时我们还要维护这个函数的状态。如果我们是这个语法糖的设计者，我们会选择怎么样的手段来处理这个问题呢？</p><p>是的，状态机。async/await避免了代码的碎片化，它的解决方案并不是消灭了回调函数和Continuation Tasks，而是使用工具（编译器）来帮助人类进行重复劳动。当async函数从挂起中恢复时，会调用<code>MoveNext</code>函数（相信看过async函数那一长串的traceback的同学肯定对这个函数非常眼熟），<code>MoveNext</code>函数会在async函数第一次被调用以及从挂起中恢复时被调用。状态机保存了当前函数的执行状态，当<code>MoveNext</code>函数被调用时，会根据当前状态来判断接下来执行什么代码。</p><h3 id=asycnawait到底tmd干了什么>asycn/await到底TMD干了什么 <a href=#asycnawait%e5%88%b0%e5%ba%95tmd%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88 class=anchor>🔗</a></h3><p>由于async/awaic语法糖是在编译期才被翻译成相应的程序代码，所以我们只能使用IL反编译器来窥探编译器到底做了怎样的处理与优化。不过反编译器你懂得，生成的代码基本没法看，讲解起来也会非常晦涩。</p><p>幸好在99%的情况下，我们并不需要知道async/await是怎样被展开的。如果你确实对这个问题感兴趣，可以参考这篇文章：<a href=https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine>Async Await and the Generated StateMachine</a>。</p><h2 id=几个常见的坑>几个常见的坑 <a href=#%e5%87%a0%e4%b8%aa%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9d%91 class=anchor>🔗</a></h2><h3 id=await-与-锁>await 与 锁 <a href=#await-%e4%b8%8e-%e9%94%81 class=anchor>🔗</a></h3><p>由于await会中断当前函数在当前线程的执行流，并且可能在恢复时，被指派到另外的线程。所以对await加锁明显是多此一举的。并且如果操作不当，还会造成死锁。</p><p>所以我们应该把await放到加锁的区域外。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#66d9ef>lock</span> (sync)
</span></span><span style=display:flex><span>{    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Prepare for async operation</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> myNum = <span style=color:#66d9ef>await</span> AlexsMethodAsync();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>lock</span> (sync)
</span></span><span style=display:flex><span>{    
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Use result of async operation</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=there-is-an--unfired-task-between-us>&ldquo;There is an &mldr; unfired Task between us&rdquo; <a href=#there-is-an--unfired-task-between-us class=anchor>🔗</a></h3><p>一个async函数如果返回的是Task，那么它返回的一定是一个hot task，即已经被启动了的Task。</p><p>并且await只可能等待一个启动了的Task，否则await操作将会hang住，破坏程序既定的执行流。</p><h3 id=使用tpl-task-parallel-library>使用TPL (Task parallel library) <a href=#%e4%bd%bf%e7%94%a8tpl-task-parallel-library class=anchor>🔗</a></h3><blockquote><p>Async methods are synchronous util needed.</p></blockquote><p>如果我们想同时执行几个异步操作，使用for来遍历执行可不是一个好主意。因为这样函数执行流仍然是顺序执行相应的函数。</p><p>TPL提供了<code>WhenAll</code>、<code>WhenAny</code>等函数，让我们可以有弹性的并发执行Task。</p><p>当然我们还可以使用PLINQ，不过这就是另外一个话题了。</p><h2 id=参考链接>参考链接 <a href=#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5 class=anchor>🔗</a></h2><ul><li><a href=https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine>Async Await and the Generated StateMachine</a></li><li><a href=http://blog.stephencleary.com/2012/07/async-interop-with-iasyncresult.html>Async Interop with IAsyncResult</a></li><li><a href="https://msdn.microsoft.com/en-us/library/wewwczdw(v=vs.110).aspx">Event-based Asynchronous Pattern Overview</a></li><li><a href=https://www.safaribooksonline.com/library/view/async-in-c/9781449337155/>Async in C# 5.0</a></li><li><a href=https://www.safaribooksonline.com/library/view/essential-c-60/9780134176147/>Essential C# 6.0</a> Cpt18</li></ul></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>