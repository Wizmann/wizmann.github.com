<!doctype html><html lang=zh-cn dir=auto><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">RPC - phxrpc代码阅读(7)</h1><div class=post-meta><span title='2016-10-22 23:03:36 +0000 UTC'>October 22, 2016</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=前言>前言<a hidden class=anchor aria-hidden=true href=#前言>#</a></h2><p>看了这么久代码，终于我们要接近phxrpc的核心部分了。</p><p>但是出人意料的是，rpc部分并没有过多的概念和magic trick。而且因为ucontext已经被封装好了，所以在rpc里的操作，可以完全按照同步的写法来搞，开发者们不需要切换同步异步的思维模式，就可以在底层的封装之上，做自己想做的事了。</p><h2 id=线程安全的队列---threadqueue>线程安全(?)的队列 - ThreadQueue<a hidden class=anchor aria-hidden=true href=#线程安全的队列---threadqueue>#</a></h2><p>我不知道开发者为啥要起<code>ThdQueue</code>这样令人迷惑的名字，这种诡异的命名风格贯穿了整个代码。咋一看这个类是maintain一堆线程的，类似于线程池，但其实这个类就是一个<code>BlockingQueue</code>的实现。</p><p>之后，这个队列有三种操作，<code>push</code>、<code>pluck</code>和<code>break_out</code>。push操作不用多说，pluck对应的我们所理解的pop操作，即从队列中弹出元素（pluck这个词貌似是从grpc里面来的，那我就不吐槽了，毕竟Google爸爸）。</p><p>更令人疑惑的是<code>break_out</code>这个操作。从代码来看，像是清空队列，并且在dtor中也显式的调用了这个函数。</p><p>但是有以下的几个问题。</p><p>一，<code>break_out_</code>是一个bool变量，且在不同线程间共享，问题在于这个变量可能被cache住，直接访问可能会造成非预期的结果，可能需要<code>volitaile</code>，或者在<code>pluck</code>函数里加一个mem barrier。</p><p>二来，在析构函数中调用<code>break_out_</code>，有可能的一种情况是有其它线程还在<code>pluck</code>函数中，而<code>ThdQueue</code>对象已经被析构了，我们就需要承担这种不安全行为的后果（此处有广告：大铁棍子医院捅主任，张姐去了都说好）。</p><p>当然，如果这个函数只在结束进程时使用，其实写的糙一点也无所谓，因为毕竟线上服务是没有“退出”这种状态的。当我们要清空队列时，已经不需要对外提供服务，之后直接<code>kill -9</code>就好，不会触发多线程的坑。不过，这里我觉得应该还是要加小心。</p><h2 id=uthreadcaller>UThreadCaller<a hidden class=anchor aria-hidden=true href=#uthreadcaller>#</a></h2><p>这个破类让我看了一小时，分析它的keepalive是怎么实现的。结果发现这个类被没有被调用。</p><p>GG。</p><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-22/54117736.jpg></p><h2 id=一个超级文件---hshaserver>一个超级文件 - HshaServer<a hidden class=anchor aria-hidden=true href=#一个超级文件---hshaserver>#</a></h2><blockquote><p>不知道为啥开发者要把这么多文件写一块，拆开不好吗？</p></blockquote><h3 id=dataflow>DataFlow<a hidden class=anchor aria-hidden=true href=#dataflow>#</a></h3><p>DataFlow包含了Request和Response两个Queue，还附加了入队的时间戳和一个args参数指针。</p><h3 id=hshaserverstat>HshaServerStat<a hidden class=anchor aria-hidden=true href=#hshaserverstat>#</a></h3><p>一个统计类。会在后台新建一个线程，约每一秒打印一次统计日志。</p><p>这个类里有一个技巧，在<code>CallFunc()</code>函数中，每一秒循环一次并没有使用sleep家族的函数，也没有使用select的超时。而是使用了<code>condtional variable</code>。</p><p><code>std::condition_variable::wait_for</code>函数，实质是就是带超时的等待。而这里，在一般状态下，是没有线程会notify的，所以wait_for函数会睡满1s。但是在退出时，会显式的notify统计线程，破坏等待状态，使统计线程退出。</p><p><code>wait_for</code>函数的具体用法，可以参考<a href=http://en.cppreference.com/w/cpp/thread/condition_variable/wait_for>文档</a>。</p><p>下面的<code>HshaServerQos</code>也是一样的思路，Qos即“Quality of service”。</p><h3 id=worker和workerpool>Worker和WorkerPool<a hidden class=anchor aria-hidden=true href=#worker和workerpool>#</a></h3><p>这两个类其实是一个和一堆的关系，不过由于这里的诡异的写法，导致一个依赖一堆，一堆调用一个。</p><p>WorkerPool是一个全局的线程池，里面有线程（废话），输入输出队列，Disipatcher和调度器。所以Worker要反过来依赖WorkerPool里面的数据。造成了很大的耦合性。</p><p>Worker从输入队列中获取信息，并且使用<code>dispatcher</code>进行CPU密集的处理（我觉得<code>dispatcher</code>这个名字起的也有问题）。之后将结果放入输出队列，由后面的<code>HshaServerIO::ActiveSocketFunc</code>驱动协程库进行之后的IO操作。</p><h3 id=完成调度器---hshaserverio>完成调度器 - HshaServerIO<a hidden class=anchor aria-hidden=true href=#完成调度器---hshaserverio>#</a></h3><p>这个类的主要作用就是补全调度器缺少的函数，并提供了一个IO的工作函数<code>HshaServerIO::IOFunc</code>。</p><p>调度器的工作流程前面已经说过了，我们现在就从更具体化的实现上来阅读一下。</p><p><code>HshaServerIO :: AddAcceptedFd</code>，这个函数由外部调用，传入已经accept的fd，之后<code>HshaServerIO::HandlerAcceptedFd</code>将这个fd，和IO工作函数<code>IOFunc</code>一起放入调度器中进行调度。</p><p>工作函数<code>IOFunc</code>只负责将请求放入队列，而并不负责从输出队列中取出响应。这个事情由<code>HshaServerIO::ActiveSocketFunc</code>负责。</p><p>换句话说，在调度器的工作循环中，<code>epoll_wait</code>中等待的只有在进行IO的两种fd，一是读还没读完的，二是写还没写完的。</p><p>进行完CPU操作的fd，由<code>active_socket_func_</code>函数重新激活，向客户端写回响应。所以这个函数应该叫<code>activate_socket_with_resp_func_</code>更合适一些。（至少第一个单词得是个动词好不。）</p><p>后面的keepalive的处理也是非常浅显的，这里就不多说了。</p><h3 id=多线程io---hshaserverunit和hshaserver>多线程IO - HshaServerUnit和HshaServer<a hidden class=anchor aria-hidden=true href=#多线程io---hshaserverunit和hshaserver>#</a></h3><p>前面我们说了不少协程的事，但这并不代表我们不使用多线程带来的红利。或者至少在性能不符合预期的时候，用多线程来tuning一下。</p><p>HashServerUnit包装了一组线程，其中包括一个IO线程和若干CPU线程。我们在HshaServer中，还可以配置多个Unit，使得我们有多个IO线程，充分榨干CPU和IO的每一滴汗水。</p><p>由于手里也没有测试数据，也就不能更详细的来说配置服务参数的策略。但是无责任猜测，IO线程应该不超过3个。CPU线程数目应该略多于CPU核数。</p><h3 id=一个独立的acceptor>一个独立的Acceptor<a hidden class=anchor aria-hidden=true href=#一个独立的acceptor>#</a></h3><p><code>HshaServerAcceptor</code>类相对比较独立，它是用来接受访问请求。是主线程的工作循环。</p><p>这里比较奇怪的是，<code>LoopAccept</code>函数设置了CPU亲和性。使得控制线程只在CPU0上运行。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>    cpu_set_t mask;
</span></span><span style=display:flex><span>    CPU_ZERO(<span style=color:#f92672>&amp;</span>mask);
</span></span><span style=display:flex><span>    CPU_SET(<span style=color:#ae81ff>0</span>, <span style=color:#f92672>&amp;</span>mask);
</span></span><span style=display:flex><span>    pid_t thread_id <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> ret <span style=color:#f92672>=</span> sched_setaffinity(thread_id, <span style=color:#66d9ef>sizeof</span>(mask), <span style=color:#f92672>&amp;</span>mask);
</span></span></code></pre></div><p>具体原因有待探讨，可能是和中断亲和性有关。</p><h2 id=写在后面>写在后面<a hidden class=anchor aria-hidden=true href=#写在后面>#</a></h2><p>总算囫囵吞枣的把这RPC读完了，其实这里还是有好多疑问的。但是由于phxrpc的文档实在是。。。基本算是没有吧。所以可能还要去Github上提一波Issue。</p><p>在学习过程中，真的感觉自己懂的还是太少。简直药丸。</p><p>还需要更加努力才好。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/phxrpc/>Phxrpc</a></li><li><a href=https://wizmann.top/tags/rpc/>Rpc</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/phxrpc-8/><span class=title>«</span><br><span>总结 - phxrpc代码阅读(8)</span>
</a><a class=next href=https://wizmann.top/posts/phxrpc-6/><span class=title>»</span><br><span>非阻塞TCP流和HttpClient - phxrpc代码阅读(6)</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>