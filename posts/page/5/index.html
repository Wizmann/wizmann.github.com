<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Posts | Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Posts - Maerlyn's Rainbow"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wizmann.top/posts/index.xml><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Posts"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Posts"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Posts</h1></header><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2023-12-15 Title: 在SPIN/Promela中模拟CAS（Compare-and-Swap） Tags: SPIN, Promela, SPIN/Promela, CAS, Compare-ans-Swap, 多线程 Slug: simple-cas-model-in-spin-promela
CAS（Compare-And-Swap）是一种在多线程编程中常用的数据同步方法，它通过比较和交换操作来保证数据的一致性。然而，在SPIN/Promela中没有直接的CAS对应实现。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/simple-cas-model-in-spin-promela/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-08-05 23:07:02 Title: Single Number Problem Tags: 算法, leetcode, algorithm Slug: single-number-in-the-array
Introduction There are a lot of interview problem based on the 1D-array, which is the one of the easiest “data structure”.
But the problem about that simple data structure might not be that simple. Here is the summary of the problem about 1D-array.
Of course, most of them come from Leetcode.
All Twice Excpet One Given an array of integers, every element appears twice except for one. Find that single one.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/single-number-in-the-array/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-10-20 09:11:27 Title: Snake Problem Tags: binary indexed tree, algorithm, geometric Slug: snake-problem
题目 在一个平面上，有n+m条蛇，其中n条蛇沿水平方向（y轴方向）移动，m条蛇沿竖直方向（x轴方向）移动。
现给出这些蛇头和尾所在的坐标点，求出这n+m条蛇在此时共有多少个交点。在同一个方向移动的蛇不会有交点。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/snake-problem/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2023-12-17 Title: 使用 SPIN/Promela 对多线程 Concurrent FIFO Queue 进行建模与验证 Tags: SPIN, Promela, SPIN/Promela, 多线程, multi-thread, Queue, FIFO Slug: SPIN-Promela-Concurrent-Queue-1
引言 并发编程中设计和验证多线程数据结构是一项极大的挑战，即使是实现一个简单的数据结构（见《实现一个无锁消息队列》一文），都需要不少的脑力、讨论与实践才可以尽可能保证其正确性。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/spin-promela-concurrent-queue-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2025-1-21 Title: 动手实现智能指针 （上篇） - C++ for the Antiquated（之四） Tags: cpp, modern cpp Slug: std-smart-ptrs-cpp-for-the-antiquated-4
智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2025-1-1 Title: 动手实现std::visit - C++ for the Antiquated（之二） Tags: cpp, modern cpp Slug: std-visit-cpp-for-the-antiquated-2
std::variant 与 std::visit std::variant std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2025-1-4 Title: std::visit实现运行时多态 - C++ for the Antiquated（之三） Tags: cpp, modern cpp Slug: std-visit-polymorphism-cpp-for-the-antiquated-3
在传统的 C++ 中，运行时多态 通常依赖于 “接口 - 虚函数” 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 子类型多态（Subtype Polymorphism）。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-10-26 00:24:44 Title: The Checklist of Steve Yegge Tags: interview, Google Slug: steve-yegge-interview-checklist
Hey man, I don’t know that stuff
Stevey’s talking aboooooout
If my boss thinks it’s important
I’m gonna get fiiiiiiiiiired
Oooh yeah baaaby baaaay-beeeeee….
非技术部分 热身 好好读一本讲数据结构和算法的书 熟悉一些“术语”，可以强化分辨问题的能力。
Yegge推荐了 Steven S. Skiena 的《算法设计手册》，而我推荐的是 Udi Manber 的《算法引论》。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/steve-yegge-interview-checklist/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2017-04-20 23:17:45 Title: STUP - another (stupid) TCP over UDP protocol (1) Tags: STUP, TCP, UDP, networking, protocol Slug: stup-1
What is STUP? STUP is the abbreviation of “Speeded/Secure Tcp-like Udp Protocol”, which means that it’s another TCP over UDP protocol.
Why TCP over UDP?
TCP is a network protocol for general purpose, and it’s one of the most commonly used internet protocol on this planet. It is reliable, ordered and well optimized with decades of efforts.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/stup-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2017-05-04 00:53:03 Title: STUP - Packet Structure and State Machine (2) Tags: STUP, TCP, UDP, networking, protocol Slug: stup-2
STUP Packet Structure Brief Introduction of TCP & UDP Packet Structure STUP pretend itself as a protocol at the Transmission Layer, but actually it’s absolutely an Application Layer protocol. So before we start, I’d like to recall some knowledge of two important Transmission Layer protocol: TCP & UDP.
It is well known that TCP is a “connection-oriented”, “reliable”, “ordered”. To make an analogy (a little bit inappropriate), TCP is like a phone call (good cell signal strength):
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/stup-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2017-05-08 22:15:58 Title: STUP - the Implementation (3) Tags: STUP, TCP, UDP, networking, protocol Slug: stup-3
throughput and window size The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/stup-3/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-10-01 00:05:29 Title: 思维训练 - Thinkin’ in induction 2 Tags: induction, algorithm Slug: thinking-in-induction-2
最大导出子图（maximal induced graph） 你现在在组织一个学术会议。现在你有一份人员名单。假定名单中的每一个人都同意到达，并且有充足的时间交流意见。同时，每一个科学家都写下了他愿意与其进行交流的科学家的名字。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/thinking-in-induction-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-09-26 00:10:45 Title: 思维训练 - Thinkin’ in induction Tags: induction, binary tree, codeforces Slug: thinking-in-induction
热身题 - 24Game 原题请戳我
题意 给你一个包含整数1…n的集合S。接下来进行n-1次操作，每次操作从集合S中选取两个数，在加、减、乘三种运算中选取一种，将结果放回再集合S。在n-1次操作完成后，集合S中只剩下一个数。求问一种取数和运算策略，使最后的结果为24。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/thinking-in-induction/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2013-12-14 Title: 自己动手搭建第三方的Codeforces CDN Tags: codeforces, chrome-extension, useless Slug: third-party-codeforces-cdn
啥？ 校园网上CF那叫一个卡。
原因是什么呢？ 因为codeforces大量的使用了ajax技术，所以引用了很多js/css文件，并且引用的位置位于页面之前。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/third-party-codeforces-cdn/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2023-12-22 23:32:00 Title: [TL;DR] 论文阅读：Autopilot - 自动化数据中心管理 Tags: Autopilot, Data Center, Data Center Management Slug: tl-dr-autopilot-automatic-data-center-management
TL;DR Autopilot是微软用来自动化运营大规模网络服务的基础架构 其设计核心是Device Manager，一个基于Paxos的强一致性分布式状态机，用来保存整个系统的“实际真相”（ground truth），并且根据整个系统的状态确定下一步的行动 其它子模块通过与Device Manager通信，在“最终一致性”模型下获取系统信息并执行命令，确保更新可能不是即时的，但最终会在系统中传播 概述： 微软运营大规模网络服务，需要可靠的数据中心自动管理​​ 为了降低数据中心的运营和资本支出而设计​​ 负责自动化软件配置和部署、系统监控，以及执行修复操作来处理软件和硬件的故障 微观的策略则交由各个应用程序来确定。例如，确定哪些计算机应运行哪些软件，或者精确地定义和检测需要修复的故障 设计原则： 基于大规模“商品级计算机系统”的经济性和不可靠性，Autopilot采用容错和简化设计​​ 容错设计：非拜占庭式故障模型，解决数据中心的控制环境问题 “非拜占庭式故障模型”假设系统中的错误不是恶意或欺诈性的。在这种模型中，系统的故障被认为是由于一些常规原因，如硬件故障、软件缺陷或网络问题 简化设计： 强调简单性和容错性 在构建大型的可靠、可维护系统时，常常选择简单设计而非更高效或看似更优雅但更复杂的解决案。 系统概览： Autopilot分为多个组件 平衡弱一致性和强一致性之间的抉择 弱一致性：增强可用性 强一致性：简化设计 Device Manager - 状态和逻辑管理 所有关于系统应处于的“实际真相”（ground truth）状态以及更新这一状态的逻辑，都保存在一个称为 Device Manager 的强一致性状态机中，通常分布在5至10台计算机上 使用 Paxos 算法实现副本间的一致性，同时通过批处理更新以平衡延迟和吞吐量 Device Manager与“卫星服务” “卫星服务”在发现 Device Manager 状态需要时，惰性地向自身或其客户端的同步信息 如果“卫星服务”发现集群中的故障或不一致，它不会尝试纠正，而是将问题报告给 Device Manager Autopilot会综合这些信息做出下一步决定 当 Device Manager 更新其状态时，会通知“卫星服务”。“卫星服务”也会通过心跳信息尝试拉取最新的状态。简化设计的同时，并且保证最终一致性/正确性。 底层服务： 使用稳定的Windows Server操作系统镜像，包含Autopilot配置文件和服务​​ 配置服务（Provisioning）包括DHCP和网络引导，不断扫描网络中新接入的计算机​​ 通过Device Manager提供的信息来决定需要运行的操作系统及二进制程序 应用部署 定义不同机器类型，存储不同配置文件和应用二进制文件​​ 部署新代码时，以Scale unit为单位更新/回滚各机器类型的配置​​ 自动修复服务 使用最小化的故障检测和恢复模型，以节点或交换机为单位，不处理特定进程的错误 只包括Reboot / ReImage / Replace 三种操作 Autopilot无需对错误归因，也不需要相关的错误处理逻辑 用看门狗进行故障报告​​，检测特定的属性，并上报给Device Manager Device Manager作为一个集中式程序，控制机器的自动修复，并且控制同时进行修复机器的数量 监控服务： 记录性能计数器和日志，收集服务形成分布式集合和聚合树​​ 案例研究 - IndexServing： 介绍Windows Live Search如何与Autopilot交互，保持高可用性​​ 对于需要高可用性和低延迟的面向客户服务的应用程序，需要在基础的 Autopilot 组件之上增加定制的容错层 使用Load balancer和定制的监控服务来探测失效的或者慢速的节点，并且将结论上报到Autopilot 经验与教训： 对于关键的配置文件，进行checksum检查是必须的 避免人工失误（例如部署因Debug而临时修改的配置）或者其它意外问题 网络是不可靠的 TCP/IP的checksum非常弱，所以需要应用层面的额外检查 网络硬件经常翻转数据流中的bit位，导致大量的重试或者未被网络层检测到的数据错误 一些节点偶尔会运行的异常慢，但是并不会停止工作。这种问题与“失败停止错误”一样需要被及时检测到 节流与负荷削减对于自动化系统非常重要 失效检测模块需要有效的区分节点失效与节点过载的区别 简单的移除节点可能会导致级联式的失效，进而使整个系统失效 论文</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/tl-dr-autopilot-automatic-data-center-management/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2023-12-27 Title: [tl;dr] 论文阅读：Borg - Large-scale cluster management at Google Tags: Borg, Distributed System, Kubernetes, Google Slug: tl-dr-borg
系统概览 Borg是谷歌开发的一种高效的集群管理系统，旨在优化资源利用率和提高系统的可靠性及可用性 隐藏资源管理细节与故障处理，允许用户专注于应用程序的开发 保证非常高的可靠性和可用性，以支持用户应用程序的高可靠性和高可用性 支持运行来自众多应用的数十万个作业，并高效运行于数以万计的机器上 用户视角 用户通过定义job和task与Borg进行交互 一个job由运行相同程序的一个或多个task组成 每一个job运行于一个Borg cell（单元）之中，cell是一组机器的集合，是Borg管理的基本单元 Borg的工作负载 长期运行的时延敏感型服务 批处理作业 运行在实体机上，避免VM的虚拟化开销 Allocs 预留给一项或多项任务的一组资源 Alloc可以将不同 jobs 的 tasks 聚集到同一台机器上 如果一个 alloc 必须重新分配到另外一台主机，属于它的 task(s) 也会同它一起重新被调度 一旦创建一个 alloc 集合，就可以提交一个或多个 jobs 运行其中 命名服务和监控 Borg包含一个稳定的 Borg命名服务 (BNS)，包括 cell 名，job 名和 task id Borg将 task 的主机名和端口写入 Chubby，用于 RPC 系统查找 task endpoint Borg还会将 job size与其运行状态写入Chubby，便于load balancer平衡流量 Borg的架构 Borgmaster 主管理进程 逻辑上的“单点”，有5个在线备份，使用Paxos选举master 状态存储在内存中，并且备份在高可靠性的Paxos存储中 调度进程 可行性检查 用于找到满足任务约束、具备足够可用资源的一组机器 打分（scoring） 在“可行机器”中根据用户偏好，为机器打分 打分策略 worst fit（E-PVN的变种）会将任务分散到不同的机器上 有余量应对流量的尖峰 会导致资源的碎片化，阻碍大型task的部署 best fit，会尽量“紧凑”的使用机器，以减少资源碎片 便于大型task的部署 错误的资源估计会被“惩罚”，尤其影响突发的负载 影响利于富裕计算资源的batch jobs 混合模型，尽量减少“受困资源”，即因为其它资源被完全占用而无法分配出去的资源 优化 启动时间优化 中位数启动时间为25s，80%用于安装相关依赖 将相关task优先分配到拥有相关依赖的机器上 使用 tree-like 或 torrent-like 机制，并发的分发相关依赖 计算开销优化 使得Borg能管理更多的机器 打分缓存：将可行性检查和打分结果缓存 等价类：同一 job 中的 task 通常具有类似的约束，因此可以将多个任务视为一个等价类 松弛随机化：计算所有机器的可行性和得分代价太高，可以随机取样一批机器，然后选择其中一个“足够好”的机器 Borglet Borglet 是运行在每台机器上的本地代理，管理本地的任务和资源 Borgmaster 会周期性地向每一个Borglet拉取当前状态，易于控制通信速度，避免“恢复风暴” 为了性能可扩展性，每个Borgmaster副本会运行无状态的 link shard 去处理与部分Borglet通信 当 Borgmaster 重新选举时，link shard 会重新划分分区 link shard 会聚合和压缩信息，仅仅向被Borgmaster报告状态的更新，以此减少更新负载 如果 Borglet 多轮没有响应资源查询，则会被标记为down。运行其上的任务会被重新调度到其他机器。如果恢复通信，则 Borgmaster 会通知 Borglet 杀死已经重新调度的任务，以此保证任务的唯一性 Borglet与Borgmaster失去联系时，仍会继续处理相关任务。以应对 Borgmaster 的暂时失效 可靠性 自动重新调度器被驱逐的任务 将任务分散到不同的失败域中 限制一个作业中同时失败任务的个数和中断率 使用声明式的期望状态表示和幂等的变更操作，以便无害地重新提交请求 对于机器级别的失效，限制其重新调度的速率，因为难以区分大规模机器故障和网络分区 避免重试引发错误的&lt;任务-机器>匹配对 关键数据持久化，写入磁盘 资源利用和效率 评估方法 cell compaction：通过移除机器来找出给定工作负载能适应的最小的单元大小，然后反复从头开始重新打包工作负载，以确保不会因错误的配置而陷入困境 “单元共享”：在同一台机器上运行生产任务和非生产任务，以优化资源使用 实验表明，共享资源会影响实际的CPU计算性能 但是在节约成本的巨大优势上面，CPU性能的退化是可以容忍的 “大型单元”：允许超大型计算任务，减少任务的碎片化 细粒度资源请求 以千分之一的CPU核，和内存、磁盘的字节数为资源请求的最小单元 相比预设资源分配（套餐），可以避免额外的资源开销 资源回收 对于可以容忍低质量资源的工作（例如批处理作业），Borg会评估任务将使用的资源，并回收空闲资源 最初的预留值与其资源请求一致，然后300秒之后，会慢慢降低到实际使用率外加一个安全边缘 如果利用率超过资源预留值，预留值会快速增长。 隔离与安全性： 安全隔离 使用Linux chroot jail在共享同一台机器的任务之间确保安全性 性能隔离 基于cgroup的资源容器，允许详细的资源核算并执行限制，防止任务相互干扰，确保稳定和可预测的性能 使用appclass，尽可能保证延迟敏感服务的资源使用 区分可压缩资源 和 不可压缩资源 可压缩资源（compressiable） - CPU%和Disk IO，可以暂时限流 不可压缩资源（non-compressible） - 内存、磁盘占用，需要清除优先级低的线程 内核的CPU调度器，允许根据每个资源容器的负载状况来动态决定是否要驱逐低优先级任务，同时避免多个高优先级任务在一个cpu上争抢 仍在尝试cpu调度时更好的考虑线程亲和、NUMA亲和等策略 经验教训： 负面经验 Job作为Task的唯一分组机制的局限性 缺乏将整个多Job服务作为单一实体进行管理，或引用服务相关Job（如Canary与Prod滚动更新）的方式 用户会在Job名称中编入拓扑，并构建外部管理工具来解析这些名称，这导致了滚动更新和作业调整大小等问题的不灵活语义 Kubernetes通过使用标签组织其调度单元（Pods），提供了更多灵活性 单个IP地址带来的复杂性 同一台机器上的所有任务共享该机器的单个IP地址和端口空间 导致端口也成为一种资源，在调度时候需要被考虑 Kubernetes采用了更友好的方法，每个Pod和服务都获取自己的IP地址，从而简化了这些复杂性。 偏向于高级用户 Borg提供了一整套面向“高级用户”的功能，允许他们细致调整程序运行方式 这种API的丰富性使得对于“普通”用户更加困难，并限制了其演变 Google构建了自动化工具，对于允许“失败”的应用程序，通过实验来探测适当配置 积极经验 Allocs是有用的 Kubernetes中的Alloc等效物是Pod，它是一个资源包，用于一个或多个容器，总是被调度到同一台机器上并可以共享资源 集群管理不仅是任务管理 尽管Borg的主要角色是管理任务和机器的生命周期，但运行在Borg上的应用程序从许多其他集群服务中受益，包括命名和负载均衡 Kubernetes使用服务抽象支持命名和负载均衡，服务有一个名称和一组由标签选择器定义的动态Pods。 自省至关重要 尽管Borg几乎总是“运行良好”，但当出现问题时，找到根本原因可能具有挑战性 Borg的重要设计决策之一是向所有用户展示调试信息 Kubernetes旨在复制Borg的许多内省技术，例如，它配备了cAdvisor等工具进行资源监控和基于Elasticsearch/Kibana和Fluentd的日志聚合 主控节点是分布式系统的核心 Borgmaster最初被设计为一个单体系统，但随着时间的推移，它变得更像是一个内核，位于协作管理用户作业的一系列服务的中心 Kubernetes架构更进一步，它有一个核心的API服务器，仅负责处理请求和操纵底层状态对象，集群管理逻辑被构建为小型可组合的微服务，这些服务是这个API服务器的客户端​​ 论文</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/tl-dr-borg/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2023-12-08 Title: [tl;dr] 论文阅读：Rarest First and Choke Algorithms Are Enough Tags: BitTorrent, Distributed System Slug: tl-dr-Rarest-First-and-Choke-Algorithms-Are-Enough
基本概念 Peer：BitTorrent P2P下载的参与者 Leecher：“吸血者”，仍在下载过程中的peer Seeder：做种者，下载完成后还在继续做种的peer Piece：Piece是文件的数据单元。当文件被分享时，它被分割成多个大小相等的片段，称为"pieces"。这些pieces是peer间传输的基本单位 “最稀有优先算法”（Rarest First Algorithm） “最稀有优先算法”（Rarest First Algorithm）是BitTorrent协议中的一个关键策略，用于决定哪些数据块（piece）首先被下载和分享。这个算法的核心目标是优化整个网络中数据的分布，确保更快的下载速度和更高的效率。 基本原理 数据块的稀有度 在BitTorrent网络中，文件被分割成许多小的数据块。 “最稀有优先”算法的目的是优先下载那些网络中数量最少的数据块。 选择下载的块： 当一个peer加入Torrent网络，并开始下载文件时，它首先会从所有连接的peer那里获取有关哪些数据块是稀有的信息。 然后，它优先请求下载那些最稀有的数据块。 动态调整： 随着下载的进行，每个peer会不断更新和重新评估网络中每个数据块的稀有度，并相应地调整其下载优先级。 算法的重要性 提高效率：通过优先下载最稀有的块，这个算法帮助加快了文件的整体下载速度。一旦最稀有的块被更多peer获取，它们就更容易被进一步分享和分发。 防止瓶颈：如果没有这个算法，某些数据块可能会变得很难获得，导致下载过程在接近完成时放慢，这被称为“最后一块问题”（Last Piece Problem）。 促进平等分享：这种方法鼓励peer分享它们拥有的稀有块，从而提高了整个网络中的合作和资源共享。 实际应用 在BitTorrent网络中，这个算法对于确保高效的数据分发至关重要。它不仅提高了单个用户的下载速度，而且还提高了整个网络的效率，确保了资源在用户之间的均衡分配。通过这种方式，BitTorrent网络能够有效地避免瓶颈和提高数据的可用性，即使在面对大量用户的情况下也是如此。 结论 最稀有优先算法是BitTorrent网络高效运行的关键组成部分。它通过智能地选择下载和分享网络中最稀有的数据块，提高了资源的整体分布和可用性，确保了快速、平衡的文件共享。 “窒息算法”（Choking Algorithm） “窒息算法”（Choking Algorithm）是BitTorrent协议中的一个关键组成部分，用于管理多个peer之间的数据传输。这个算法帮助优化带宽的使用，确保网络中的资源被高效合理地分配。其核心目的是促进peer间的合作和数据的快速分发。 窒息算法的基本原理 选择和窒息（Choking and Unchoking） 在BitTorrent网络中，每个peer同时维护着一组“窒息”（choked）和“未窒息”（unchoked）的peer名单。 被“窒息”的peer无法从窒息方接收文件数据，而“未窒息”的peer可以进行数据交换。 这种状态是动态的，peer根据算法定期更新它们的窒息/未窒息peer名单。 利益驱动的决策 算法核心是“利益驱动”（tit-for-tat）策略，即peer更倾向于向那些能给它提供数据的peer提供数据。 这种方法鼓励peer分享数据，因为分享越多，获得数据的机会也越大。 优化器： 除了基于交换数据的量来决定窒息状态外，大多数BitTorrent客户端还实现了一个“优化器”（Optimizer），用于探索新的peer。 通常，这是通过定期“未窒息”一个随机选择的peer来实现的，即使它在过去的数据交换中表现不佳或没有数据交换。 窒息周期： peer定期评估其连接，并根据从其他peer接收到的数据速率来更新其窒息/未窒息名单 窒息算法的重要性 合作促进：通过奖励那些分享资源的peer，窒息算法鼓励合作，提高了网络中的资源共享效率。 防止自私行为：算法减少了自私peer（只下载不上传的）的优势，因为这些peer不太可能被其他peer“未窒息”。 网络拥塞控制：它帮助控制网络拥塞，通过限制peer的连接数量和数据传输，优化带宽使用。 结论 窒息算法是BitTorrent协议高效性的关键，它通过一种简单但有效的方式来鼓励数据共享和合作，保证了整个网络的健康和高效运行。通过这种动态的窒息/未窒息机制，BitTorrent网络能够有效地管理带宽和连接，确保资源在网络中的快速且公平的分配。 为什么说“已经足够了” 因为这是一门实验科学
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/tl-dr-rarest-first-and-choke-algorithms-are-enough/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-11-17 00:25:42 Title: 类型-长度-值（TLV）协议 Tags: TLV, protocol, network, protobuf, flatbuffer Slug: tlv-protocol
在数据通信协议中，可选的信息或字段通常使用type-length-value（a.k.a TLV）元素来进行编码。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/tlv-protocol/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2016-12-10 11:34:38 Title: Twisted Defer and DeferredQueue Tags: twisted, defer, async Slug: twisted-defer-and-deferredqueue
写在最前面 这篇文章本来是想用英文写的，但是最近英文水平下降的和狗一样。还是怂一波吧。
写在前面 最近在用Twisted库写一个诡异的项目，具体内容暂且不在这里讨论。在写的过程中，被Twisted里面的一个重要概念 —— defer，折腾的不行。最终通过阅读twisted的部分源码，以及与代码做斗争的丰富经验，最终算是解决了问题。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/twisted-defer-and-deferred-queue/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2015-07-26 22:48:33 Title: Using Set Cover to Optimize a Large-Scale Low Latency Distributed Graph Tags: System Design, Linkedin, Social Network Slug: using-set-cover-algorithm-to-optimize-a-large-scale-low-latency-distributed-graph
Background Linkedin (or other social networks, such as Facebook and G+) use the “social graph information” to show the social relationship between you and other members.
Such as, “You and Mr.Obama share 10 mutual friends” or “You have 1,000 second-degree connections”.
This feature is very common for a social network. But where does it come from?
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/using-set-cover-algorithm-to-optimize-a-large-scale-low-latency-distributed-graph/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://wizmann.top/posts/page/4/>«&nbsp;&nbsp;
</a><a class=next href=https://wizmann.top/posts/page/6/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>