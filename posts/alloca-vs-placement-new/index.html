<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Date: 2014-04-07 21:08:59
Title: &ldquo;alloca&rdquo; vs &ldquo;placement new&rdquo;
Tags: cpp, memory, stack, heap, allocate, alloca, c++
Slug: alloca-vs-placement-new
WHAT?!
For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this."><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/alloca-vs-placement-new/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/alloca-vs-placement-new/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/alloca-vs-placement-new/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:description" content="Date: 2014-04-07 21:08:59 Title: “alloca” vs “placement new” Tags: cpp, memory, stack, heap, allocate, alloca, c++ Slug: alloca-vs-placement-new
WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this."><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Date: 2014-04-07 21:08:59
Title: &ldquo;alloca&rdquo; vs &ldquo;placement new&rdquo;
Tags: cpp, memory, stack, heap, allocate, alloca, c++
Slug: alloca-vs-placement-new
WHAT?!
For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://wizmann.top/posts/alloca-vs-placement-new/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Date: 2014-04-07 21:08:59 Title: \u0026ldquo;alloca\u0026rdquo; vs \u0026ldquo;placement new\u0026rdquo; Tags: cpp, memory, stack, heap, allocate, alloca, c++ Slug: alloca-vs-placement-new\nWHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.\nHowever, access memory on heap is not as effective as the memory on stack, because the heap is \u0026ldquo;free-floating region of memory\u0026rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.\n","keywords":[],"articleBody":"Date: 2014-04-07 21:08:59 Title: “alloca” vs “placement new” Tags: cpp, memory, stack, heap, allocate, alloca, c++ Slug: alloca-vs-placement-new\nWHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.\nHowever, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.\nsub esp, 0x10; =\u003e allocate add esp, 0x10; =\u003e deallocate alloca The alloca() function allocates memory from the stack.\nint *p = (int*)alloca(sizeof(int) * size); It’s quite the same as the malloc way. But we shouldn’t free the memory allocated on the stack; these memory will be automatically deallocated when you leave the function(not the code block).\nplacement new The placement new is one of the overloads of the new functions; this new syntax can do something as the alloca() function.\nchar buffer[1024]; int *p = new(buffer) int[64]; The placement new can be also used in some other scenarios but won’t be mentioned here.\nvariable-length array C90 and C++ both support the variable-length array which will be allocated on stack, and it will be deallocted whhen you leave the clode block, such as “if”, “while”, etc.\nThis is much simplified, but be ware if you use both variable-length array and alloca() in the same function, the deallocation of the array will also free anything more recenly allocated by alloca.\nDefects Stack has its limitation. If the allocation on stack causes stack overflow error, then the behavior of the program is undefined.\nFurther, the variable-length array and alloca() are not included in ANSI-C standard and therefore could limit portability.\nThe Google C++ style guide encourage developers to use scoped_ptr or scopted_array instead of variable-length array and alloca().\nSome experiment // compile with: g++ -std=c++0x -O2 -Wall -g -o \"foo.cc\" \"foo\" #include #include #include #include #include using namespace std; #define print(x) cout \u003c\u003c x \u003c\u003c endl #define input(x) cin \u003e\u003e x #if defined(__i386__) static __inline__ unsigned long long rdtsc(void) { unsigned long long int x; __asm__ volatile (\".byte 0x0f, 0x31\" : \"=A\" (x)); return x; } #elif defined(__x86_64__) static __inline__ unsigned long long rdtsc(void) { unsigned hi, lo; __asm__ __volatile__ (\"rdtsc\" : \"=a\"(lo), \"=d\"(hi)); return ( (unsigned long long)lo)|( ((unsigned long long)hi)\u003c\u003c32 ); } #endif //#define MEMORY_ON_HEAP //#define MEMORY_ON_STACK const int SIZE = 102400; int *array[SIZE] = {NULL}; int main() { unsigned long long start = rdtsc(); #ifdef MEMORY_ON_HEAP // RDSTC: 20586280 for (int i = 0; i \u003c SIZE; i++) { array[i] = (int*)malloc(sizeof(int)); *array[i] = i; } #endif #ifdef MEMORY_ON_STACK // RDSTC: 3660502 for (int i = 0; i \u003c SIZE; i++) { array[i] = (int*)alloca(sizeof(int)); *array[i] = i; } #endif unsigned long long end = rdtsc(); print(end - start); return 0; } You can use info register esp in gdb to inspect the stack pointer before and after you call the allocation function or declare a variable-length array.\n","wordCount":"547","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/alloca-vs-placement-new/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>wizmann</div></header><div class=post-content><p>Date: 2014-04-07 21:08:59
Title: &ldquo;alloca&rdquo; vs &ldquo;placement new&rdquo;
Tags: cpp, memory, stack, heap, allocate, alloca, c++
Slug: alloca-vs-placement-new</p><h2 id=what>WHAT?!<a hidden class=anchor aria-hidden=true href=#what>#</a></h2><p>For most time, we use <code>malloc</code> or <code>new</code> for memory allocation, which will get it on <em>heap</em>.</p><p>However, access memory on <em>heap</em> is not as effective as the memory on <em>stack</em>, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on <em>stack</em> is managed by CPU automacitally and tightly. As a result, the further of the <em>stack</em> compared to <em>heap</em> is that we can have a faster read/write speed due to the fact that <em>stack</em> memory is more likely to optimized by <strong>CPU cache</strong>, in addition, it only uses a single instruction to allocate or deallocate <em>stack</em> memory. Just like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sub esp, <span style=color:#ae81ff>0x10</span>; <span style=color:#f92672>=&gt;</span> allocate
</span></span><span style=display:flex><span>add esp, <span style=color:#ae81ff>0x10</span>; <span style=color:#f92672>=&gt;</span> deallocate
</span></span></code></pre></div><h2 id=alloca>alloca<a hidden class=anchor aria-hidden=true href=#alloca>#</a></h2><p>The <code>alloca()</code> function allocates memory from the <em>stack</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)alloca(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span> size);
</span></span></code></pre></div><p>It&rsquo;s quite the same as the <code>malloc</code> way. But we shouldn&rsquo;t free the memory allocated on the <em>stack</em>; these memory will be automatically deallocated when you leave the function(<strong>not the code block</strong>).</p><h2 id=placement-new>placement new<a hidden class=anchor aria-hidden=true href=#placement-new>#</a></h2><p>The placement new is one of the overloads of the <code>new</code> functions; this new syntax can do something as the <code>alloca()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span>(buffer) <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>64</span>];
</span></span></code></pre></div><p>The placement new can be also used in some other scenarios but won&rsquo;t be mentioned here.</p><h2 id=variable-length-array>variable-length array<a hidden class=anchor aria-hidden=true href=#variable-length-array>#</a></h2><p>C90 and C++ both support the variable-length array which will be allocated on <em>stack</em>, and it will be deallocted whhen you leave the <strong>clode block</strong>, such as &ldquo;if&rdquo;, &ldquo;while&rdquo;, etc.</p><p>This is much simplified, but be ware if you use both variable-length array and <code>alloca()</code> in the same function, the deallocation of the array will also free anything more recenly allocated by alloca.</p><h2 id=defects>Defects<a hidden class=anchor aria-hidden=true href=#defects>#</a></h2><p><em>Stack</em> has its limitation. If the allocation on <em>stack</em> causes <strong>stack overflow</strong> error, then the behavior of the program is undefined.</p><p>Further, the variable-length array and <code>alloca()</code> are not included in <em>ANSI-C</em> standard and therefore could limit portability.</p><p>The Google C++ style guide encourage developers to use <code>scoped_ptr</code> or <code>scopted_array</code> instead of variable-length array and <code>alloca()</code>.</p><h2 id=some-experiment>Some experiment<a hidden class=anchor aria-hidden=true href=#some-experiment>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// compile with: g++ -std=c++0x -O2 -Wall -g -o &#34;foo.cc&#34; &#34;foo&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(__i386__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> __inline__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>rdtsc</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    __asm__ <span style=color:#66d9ef>volatile</span> (<span style=color:#e6db74>&#34;.byte 0x0f, 0x31&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=A&#34;</span> (x));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#elif defined(__x86_64__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> __inline__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>rdtsc</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> hi, lo;
</span></span><span style=display:flex><span>    __asm__ __volatile__ (<span style=color:#e6db74>&#34;rdtsc&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=a&#34;</span>(lo), <span style=color:#e6db74>&#34;=d&#34;</span>(hi));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)lo)<span style=color:#f92672>|</span>( ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)hi)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//#define MEMORY_ON_HEAP
</span></span></span><span style=display:flex><span><span style=color:#75715e>//#define MEMORY_ON_STACK
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>102400</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>array[SIZE] <span style=color:#f92672>=</span> {NULL};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> rdtsc();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>#ifdef MEMORY_ON_HEAP </span><span style=color:#75715e>// RDSTC: 20586280
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        array[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>array[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>#ifdef MEMORY_ON_STACK </span><span style=color:#75715e>// RDSTC: 3660502
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        array[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)alloca(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>array[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> rdtsc();
</span></span><span style=display:flex><span>    print(end <span style=color:#f92672>-</span> start);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can use <code>info register esp</code> in gdb to inspect the <em>stack</em> pointer before and after you call the allocation function or declare a variable-length array.</p></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/a2b/><span class=title>«</span><br><span></span>
</a><a class=next href=https://wizmann.top/posts/arduino-foot-pedal-for-fn-layer/><span class=title>»</span><br><span></span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>