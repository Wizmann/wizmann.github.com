<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>alloca vs placement new</title>
<meta name=description content="WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.
"><link rel=canonical href=https://wizmann.top/posts/alloca-vs-placement-new/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/alloca-vs-placement-new/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/alloca-vs-placement-new/><meta property="og:title" content="alloca vs placement new"><meta property="og:description" content="WHAT?!
For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this."><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/alloca-vs-placement-new/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-04-07T21:08:59+00:00"><meta property="article:modified_time" content="2014-04-07T21:08:59+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="alloca vs placement new"><meta name=twitter:description content="WHAT?!
For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this."><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"alloca vs placement new","datePublished":"2014-04-07T21:08:59+00:00","dateModified":"2014-04-07T21:08:59+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":529,"description":"WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.\nHowever, access memory on heap is not as effective as the memory on stack, because the heap is \u0026ldquo;free-floating region of memory\u0026rdquo;. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h2 id=what>WHAT?!</h2><p>For most time, we use <code>malloc</code> or <code>new</code> for memory allocation, which will get it on <em>heap</em>.</p><p>However, access memory on <em>heap</em> is not as effective as the memory on <em>stack</em>, because the heap is &ldquo;free-floating region of memory&rdquo;. To the contrary, memory on <em>stack</em> is managed by CPU automacitally and tightly. As a result, the further of the <em>stack</em> compared to <em>heap</em> is that we can have a faster read/write speed due to the fact that <em>stack</em> memory is more likely to optimized by <strong>CPU cache</strong>, in addition, it only uses a single instruction to allocate or deallocate <em>stack</em> memory. Just like this.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>sub esp, <span style=color:#ae81ff>0x10</span>; <span style=color:#f92672>=&gt;</span> allocate
</span></span><span style=display:flex><span>add esp, <span style=color:#ae81ff>0x10</span>; <span style=color:#f92672>=&gt;</span> deallocate
</span></span></code></pre></div><h2 id=alloca>alloca</h2><p>The <code>alloca()</code> function allocates memory from the <em>stack</em>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)alloca(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>) <span style=color:#f92672>*</span> size);
</span></span></code></pre></div><p>It&rsquo;s quite the same as the <code>malloc</code> way. But we shouldn&rsquo;t free the memory allocated on the <em>stack</em>; these memory will be automatically deallocated when you leave the function(<strong>not the code block</strong>).</p><h2 id=placement-new>placement new</h2><p>The placement new is one of the overloads of the <code>new</code> functions; this new syntax can do something as the <code>alloca()</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>1024</span>];
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span>(buffer) <span style=color:#66d9ef>int</span>[<span style=color:#ae81ff>64</span>];
</span></span></code></pre></div><p>The placement new can be also used in some other scenarios but won&rsquo;t be mentioned here.</p><h2 id=variable-length-array>variable-length array</h2><p>C90 and C++ both support the variable-length array which will be allocated on <em>stack</em>, and it will be deallocted whhen you leave the <strong>clode block</strong>, such as &ldquo;if&rdquo;, &ldquo;while&rdquo;, etc.</p><p>This is much simplified, but be ware if you use both variable-length array and <code>alloca()</code> in the same function, the deallocation of the array will also free anything more recenly allocated by alloca.</p><h2 id=defects>Defects</h2><p><em>Stack</em> has its limitation. If the allocation on <em>stack</em> causes <strong>stack overflow</strong> error, then the behavior of the program is undefined.</p><p>Further, the variable-length array and <code>alloca()</code> are not included in <em>ANSI-C</em> standard and therefore could limit portability.</p><p>The Google C++ style guide encourage developers to use <code>scoped_ptr</code> or <code>scopted_array</code> instead of variable-length array and <code>alloca()</code>.</p><h2 id=some-experiment>Some experiment</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// compile with: g++ -std=c++0x -O2 -Wall -g -o &#34;foo.cc&#34; &#34;foo&#34;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;algorithm&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#define print(x) cout &lt;&lt; x &lt;&lt; endl
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define input(x) cin &gt;&gt; x
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if defined(__i386__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> __inline__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>rdtsc</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>int</span> x;
</span></span><span style=display:flex><span>    __asm__ <span style=color:#66d9ef>volatile</span> (<span style=color:#e6db74>&#34;.byte 0x0f, 0x31&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=A&#34;</span> (x));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> x;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#elif defined(__x86_64__)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>static</span> __inline__ <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> <span style=color:#a6e22e>rdtsc</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> hi, lo;
</span></span><span style=display:flex><span>    __asm__ __volatile__ (<span style=color:#e6db74>&#34;rdtsc&#34;</span> <span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;=a&#34;</span>(lo), <span style=color:#e6db74>&#34;=d&#34;</span>(hi));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ( (<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)lo)<span style=color:#f92672>|</span>( ((<span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span>)hi)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>32</span> );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//#define MEMORY_ON_HEAP
</span></span></span><span style=display:flex><span><span style=color:#75715e>//#define MEMORY_ON_STACK
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> SIZE <span style=color:#f92672>=</span> <span style=color:#ae81ff>102400</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#f92672>*</span>array[SIZE] <span style=color:#f92672>=</span> {NULL};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> rdtsc();
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>#ifdef MEMORY_ON_HEAP </span><span style=color:#75715e>// RDSTC: 20586280
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        array[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)malloc(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>array[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>#ifdef MEMORY_ON_STACK </span><span style=color:#75715e>// RDSTC: 3660502
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> SIZE; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        array[i] <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span><span style=color:#f92672>*</span>)alloca(<span style=color:#66d9ef>sizeof</span>(<span style=color:#66d9ef>int</span>));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>array[i] <span style=color:#f92672>=</span> i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>#endif
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> end <span style=color:#f92672>=</span> rdtsc();
</span></span><span style=display:flex><span>    print(end <span style=color:#f92672>-</span> start);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>You can use <code>info register esp</code> in gdb to inspect the <em>stack</em> pointer before and after you call the allocation function or declare a variable-length array.</p></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>