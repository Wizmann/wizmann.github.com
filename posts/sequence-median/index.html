<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Sequence Median | Maerlyn's Rainbow</title>
<meta name=keywords content="quick sort,median,partition,priority queue"><meta name=description content="Description
Given a sequence of integer numbers, try to find the median of the sequence.
Extending

Make sure your code can get the right answer in any conditions
Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items.
If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm?
If it&rsquo;s not a sequence, but a data stream. How can we find the median?

Solution
Finding the median is quite similar to finding the kth element."><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/sequence-median/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/sequence-median/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/posts/sequence-median/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Sequence Median"><meta property="og:description" content="Description Given a sequence of integer numbers, try to find the median of the sequence.
Extending Make sure your code can get the right answer in any conditions Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items. If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm? If it’s not a sequence, but a data stream. How can we find the median? Solution Finding the median is quite similar to finding the kth element."><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-12-14T16:51:50+00:00"><meta property="article:modified_time" content="2014-12-14T16:51:50+00:00"><meta property="article:tag" content="Quick Sort"><meta property="article:tag" content="Median"><meta property="article:tag" content="Partition"><meta property="article:tag" content="Priority Queue"><meta name=twitter:card content="summary"><meta name=twitter:title content="Sequence Median"><meta name=twitter:description content="Description
Given a sequence of integer numbers, try to find the median of the sequence.
Extending

Make sure your code can get the right answer in any conditions
Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items.
If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm?
If it&rsquo;s not a sequence, but a data stream. How can we find the median?

Solution
Finding the median is quite similar to finding the kth element."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"Sequence Median","item":"https://wizmann.top/posts/sequence-median/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Sequence Median","name":"Sequence Median","description":"Description Given a sequence of integer numbers, try to find the median of the sequence.\nExtending Make sure your code can get the right answer in any conditions Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items. If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm? If it\u0026rsquo;s not a sequence, but a data stream. How can we find the median? Solution Finding the median is quite similar to finding the kth element.\n","keywords":["quick sort","median","partition","priority queue"],"articleBody":"Description Given a sequence of integer numbers, try to find the median of the sequence.\nExtending Make sure your code can get the right answer in any conditions Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items. If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm? If it’s not a sequence, but a data stream. How can we find the median? Solution Finding the median is quite similar to finding the kth element.\nThe basic solution to find the kth element is to sort the sequence first, and then find the kth. It’ll get the right answer, of course, but the time complexity is O(n * logn), which is not the optimized one.\nThere is a vintage algorithm to get the kth_element.\nint partition(int array[], int st, int end) { int pivot = array[st]; int l = st, r = end - 1; while (l \u003c= r) { while (l \u003c= r \u0026\u0026 array[l] \u003c= pivot) { l++; } while (l \u003c= r \u0026\u0026 array[r] \u003e pivot) { r--; } if (l \u003c= r) { swap(array[l++], array[r--]); } } swap(array[st], array[r]); return r; } int kth_element(int array[], int n, int k) { return kth_element(array, 0, n, k); } int kth_element(int array[], int st, int end, int k) { int pivot_idx = partition(array, st, end); if (pivot_idx - st + 1 == k) { return array[pivot_idx]; } if (pivot_idx - st \u003e= k) { return kth_element(array, st, pivot_idx, k); } else { return kth_element(array, pivot_idx + 1, end, k - (pivot_idx - st) - 1); } } double find_median(int array[], int n) { if (n \u0026 1) { return 1.0 * kth_element(array, n, n / 2 + 1); } else { int a = kth_element(array, n, n / 2 - 1); int b = kth_element(array, n, n / 2); return 0.5 * (a + b); } The time complexity of the algorithm is O(N). It works well in most conditions. But there is a potential error in the code, can you find it?\nreturn 0.5 * (a + b); If a + b is greater than INT_MAX, it will overflow, and make a mess to your code. The right way is：\nreturn 0.5 * a + 0.5 * b; There is another problem in the code. If the sequence is already ordered, the algorithm will take O(N^2) time, and can’t work effectively as what we design. It is because the pivot is the very first element of the sequence (or the sub-sequence), if the sequence is ordered, we will partition the sequence into this:\nn i l p i v o t [ e l e m e n t s ] The solution is to use the random pivot. And we will modify the code here.\nint partition(int array[], int st, int end) { if (st == end) { return st; } int pivot_idx = st + random() % (end - st); int pivot = array[pivot_idx]; swap(array[st], array[pivot_idx]); int l = st, r = end - 1; while (l \u003c= r) { while (l \u003c= r \u0026\u0026 array[l] \u003c= pivot) { l++; } while (l \u003c= r \u0026\u0026 array[r] \u003e pivot) { r--; } if (l \u003c= r) { swap(array[l++], array[r--]); } } swap(array[st], array[r]); return r; } This code will perform well for the ordered / nearly ordered data. But there is another “however”, what if there are few unique elements in the sequence?\nFor example, the sequence [1, 1, 1, 1, 1, 1, 1]. If we deal this sequence by the previous algorithms, it also takes O(N) time, because we can just separate the sequence into this:\n[ e l e m e n t s ] + p i v o t + n i l This scenario is similar as the previous one. So we have to come up a new way to cope with it.\nint partition(int array[], int st, int end) { if (end - st \u003c= 1) { return st; } int pivot_idx = st + rand() % (end - st); swap(array[st], array[pivot_idx]); int pivot = array[st]; int l = st, r = end - 1; int flag = 0; while (l \u003c= r) { // \u003c- rewrite zone while (l \u003c= r \u0026\u0026 array[l] \u003c= pivot) { if (array[l] == pivot \u0026\u0026 flag == 0) { flag ^= 1; } else if (array[l] == pivot) { break; } l++; } while (l \u003c= r \u0026\u0026 array[r] \u003e= pivot) { if (array[r] == pivot \u0026\u0026 flag == 1) { flag ^= 1; } else if (array[r] == pivot) { break; } r--; } // \u003c- end of rewrite zone if (l \u003c= r) { swap(array[l++], array[r--]); } } swap(array[st], array[r]); return r; } This code could put the same number into left part and right part by half.\nWith all these optimization, you can get an Accepted in the problem POJ-2623. But be ware, the function to initizalize of random number, srand(time(NULL)), is disallowed when using the G++ compiler, please choose C++ instead.\nThere’s always something next, if we don’t have enough memory to storage all the data in the sequence. We will use a heap to find the kth_element, and that will save half of the memory space. But the time complexity is O(n * logn) here.\n// This is a bad code :) int main() { int n; long long x; input(n); int k = n / 2 + 1; priority_queue\u003clong long\u003e pq; for (int i = 0; i \u003c n; i++) { scanf(\"%lld\", \u0026x); pq.push(x); if ((int)pq.size() \u003e k) { pq.pop(); } } if (n \u0026 1) { printf(\"%.1f\\n\", 1. * pq.top()); } else { long long a = pq.top(); pq.pop(); long long b = pq.top(); printf(\"%.1f\\n\", double(a + b) / 2.); } return 0; } Okay, there is the last problem: what if the sequence is a stream that you have to find the median whenver a new number comes in? The solution is using two heaps. The max heap storages the numbers which less than the median, and the min heap storages the numbers which greater than the median.\ntemplate\u003ctypename T\u003e class MaxHeap: public priority_queue\u003cT\u003e {}; template\u003ctypename T\u003e class MinHeap: public priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e \u003e {}; class MedianStream { public: void add(int u) { if (_max_heap.empty() || u \u003c= _max_heap.top()) { _max_heap.push(u); } else { _min_heap.push(u); } do_adjust(); _size++; } double get_median() { if (_size \u0026 1) { return 1.0 * _max_heap.top(); } else { int a = _max_heap.top(); int b = _min_heap.top(); return 0.5 * a + 0.5 * b; } } private: void do_adjust() { while (_max_heap.size() \u003e _min_heap.size() + 1) { _min_heap.push(_max_heap.top()); _max_heap.pop(); } while (_min_heap.size() \u003e _max_heap.size()) { _max_heap.push(_min_heap.top()); _min_heap.pop(); } } private: size_t _size; MaxHeap\u003cint\u003e _max_heap; MinHeap\u003cint\u003e _min_heap; }; ","wordCount":"1145","inLanguage":"zh-cn","datePublished":"2014-12-14T16:51:50Z","dateModified":"2014-12-14T16:51:50Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/sequence-median/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Sequence Median</h1><div class=post-meta><span title='2014-12-14 16:51:50 +0000 UTC'>December 14, 2014</span>&nbsp;·&nbsp;wizmann</div></header><div class=post-content><h2 id=description>Description<a hidden class=anchor aria-hidden=true href=#description>#</a></h2><p>Given a sequence of integer numbers, try to find the median of the sequence.</p><h3 id=extending>Extending<a hidden class=anchor aria-hidden=true href=#extending>#</a></h3><ul><li>Make sure your code can get the right answer in any conditions</li><li>Make sure your code work effectively on some special kinds of sequence. For example, ordered sequence or a nearly ordered one, a sequence with few unique items.</li><li>If the memory is not large enough for all the elements in the sequence, how can we implement this algorithm?</li><li>If it&rsquo;s not a sequence, but a data stream. How can we find the median?</li></ul><h2 id=solution>Solution<a hidden class=anchor aria-hidden=true href=#solution>#</a></h2><p>Finding the median is quite similar to finding the kth element.</p><p>The basic solution to find the kth element is to sort the sequence first, and then find the kth. It&rsquo;ll get the right answer, of course, but the time complexity is O(n * logn), which is not the optimized one.</p><p>There is a vintage algorithm to get the kth_element.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> st, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> array[st];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> st, r <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[l] <span style=color:#f92672>&lt;=</span> pivot) {
</span></span><span style=display:flex><span>            l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[r] <span style=color:#f92672>&gt;</span> pivot) {
</span></span><span style=display:flex><span>            r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>            swap(array[l<span style=color:#f92672>++</span>], array[r<span style=color:#f92672>--</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    swap(array[st], array[r]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>kth_element</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> n, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> kth_element(array, <span style=color:#ae81ff>0</span>, n, k);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>kth_element</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> st, <span style=color:#66d9ef>int</span> end, <span style=color:#66d9ef>int</span> k) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot_idx <span style=color:#f92672>=</span> partition(array, st, end);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pivot_idx <span style=color:#f92672>-</span> st <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>==</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> array[pivot_idx];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (pivot_idx <span style=color:#f92672>-</span> st <span style=color:#f92672>&gt;=</span> k) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> kth_element(array, st, pivot_idx, k);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> kth_element(array, pivot_idx <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, end, k <span style=color:#f92672>-</span> (pivot_idx <span style=color:#f92672>-</span> st) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>double</span> <span style=color:#a6e22e>find_median</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> n) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>*</span> kth_element(array, n, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> kth_element(array, n, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> kth_element(array, n, n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (a <span style=color:#f92672>+</span> b);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>The time complexity of the algorithm is O(N). It works well in most conditions. But there is a potential error in the code, can you find it?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> (a <span style=color:#f92672>+</span> b);
</span></span></code></pre></div><p>If <code>a + b</code> is greater than INT_MAX, it will overflow, and make a mess to your code. The right way is：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> b;
</span></span></code></pre></div><p>There is another problem in the code. If the sequence is already ordered, the algorithm will take O(N^2) time, and can&rsquo;t work effectively as what we design. It is because the pivot is the very first element of the sequence (or the sub-sequence), if the sequence is ordered, we will partition the sequence into this:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 216 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">[</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">]</text></g></svg></div><p>The solution is to use the random pivot. And we will modify the code here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> st, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (st <span style=color:#f92672>==</span> end) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> st;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot_idx <span style=color:#f92672>=</span> st <span style=color:#f92672>+</span> random() <span style=color:#f92672>%</span> (end <span style=color:#f92672>-</span> st);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> array[pivot_idx];
</span></span><span style=display:flex><span>    swap(array[st], array[pivot_idx]);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> st, r <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[l] <span style=color:#f92672>&lt;=</span> pivot) {
</span></span><span style=display:flex><span>            l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[r] <span style=color:#f92672>&gt;</span> pivot) {
</span></span><span style=display:flex><span>            r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>            swap(array[l<span style=color:#f92672>++</span>], array[r<span style=color:#f92672>--</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    swap(array[st], array[r]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code will perform well for the ordered / nearly ordered data. But there is another &ldquo;however&rdquo;, what if there are few unique elements in the sequence?</p><p>For example, the sequence <code>[1, 1, 1, 1, 1, 1, 1]</code>. If we deal this sequence by the previous algorithms, it also takes O(N) time, because we can just separate the sequence into this:</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 200 25"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">[</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">m</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">]</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">v</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">l</text></g></svg></div><p>This scenario is similar as the previous one. So we have to come up a new way to cope with it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>int</span> array[], <span style=color:#66d9ef>int</span> st, <span style=color:#66d9ef>int</span> end) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (end <span style=color:#f92672>-</span> st <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> st;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot_idx <span style=color:#f92672>=</span> st <span style=color:#f92672>+</span> rand() <span style=color:#f92672>%</span> (end <span style=color:#f92672>-</span> st);
</span></span><span style=display:flex><span>    swap(array[st], array[pivot_idx]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> pivot <span style=color:#f92672>=</span> array[st];
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> l <span style=color:#f92672>=</span> st, r <span style=color:#f92672>=</span> end <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> flag <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// &lt;- rewrite zone
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[l] <span style=color:#f92672>&lt;=</span> pivot) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (array[l] <span style=color:#f92672>==</span> pivot <span style=color:#f92672>&amp;&amp;</span> flag <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>^=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (array[l] <span style=color:#f92672>==</span> pivot) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            l<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (l <span style=color:#f92672>&lt;=</span> r <span style=color:#f92672>&amp;&amp;</span> array[r] <span style=color:#f92672>&gt;=</span> pivot) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (array[r] <span style=color:#f92672>==</span> pivot <span style=color:#f92672>&amp;&amp;</span> flag <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>                flag <span style=color:#f92672>^=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>            } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (array[r] <span style=color:#f92672>==</span> pivot) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            r<span style=color:#f92672>--</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#75715e>// &lt;- end of rewrite zone
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> (l <span style=color:#f92672>&lt;=</span> r) {
</span></span><span style=display:flex><span>            swap(array[l<span style=color:#f92672>++</span>], array[r<span style=color:#f92672>--</span>]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    swap(array[st], array[r]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> r;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This code could put the same number into left part and right part by half.</p><p>With all these optimization, you can get an <strong>Accepted</strong> in the problem <a href="http://poj.org/problem?id=2623">POJ-2623</a>. But be ware, the function to initizalize of random number, <code>srand(time(NULL))</code>, is disallowed when using the G++ compiler, please choose C++ instead.</p><p>There&rsquo;s always something next, if we don&rsquo;t have enough memory to storage all the data in the sequence. We will use a heap to find the kth_element, and that will save half of the memory space. But the time complexity is O(n * logn) here.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// This is a bad code :)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> n;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> x;
</span></span><span style=display:flex><span>    input(n);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> k <span style=color:#f92672>=</span> n <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>    priority_queue<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span><span style=color:#f92672>&gt;</span> pq;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> n; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        scanf(<span style=color:#e6db74>&#34;%lld&#34;</span>, <span style=color:#f92672>&amp;</span>x);
</span></span><span style=display:flex><span>        pq.push(x);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ((<span style=color:#66d9ef>int</span>)pq.size() <span style=color:#f92672>&gt;</span> k) {
</span></span><span style=display:flex><span>            pq.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%.1f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>1.</span> <span style=color:#f92672>*</span> pq.top());
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> a <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>        pq.pop();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>long</span> <span style=color:#66d9ef>long</span> b <span style=color:#f92672>=</span> pq.top();
</span></span><span style=display:flex><span>        printf(<span style=color:#e6db74>&#34;%.1f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#66d9ef>double</span>(a <span style=color:#f92672>+</span> b) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2.</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Okay, there is the last problem: what if the sequence is a stream that you have to find the median whenver a new number comes in? The solution is using two heaps. The max heap storages the numbers which less than the median, and the min heap storages the numbers which greater than the median.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MaxHeap</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> priority_queue<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>template</span><span style=color:#f92672>&lt;</span><span style=color:#66d9ef>typename</span> T<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MinHeap</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> priority_queue<span style=color:#f92672>&lt;</span>T, vector<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span>, greater<span style=color:#f92672>&lt;</span>T<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>MedianStream</span> {
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> add(<span style=color:#66d9ef>int</span> u) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_max_heap.empty() <span style=color:#f92672>||</span> u <span style=color:#f92672>&lt;=</span> _max_heap.top()) {
</span></span><span style=display:flex><span>            _max_heap.push(u);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            _min_heap.push(u);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        do_adjust();
</span></span><span style=display:flex><span>        _size<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>double</span> <span style=color:#a6e22e>get_median</span>() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (_size <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1.0</span> <span style=color:#f92672>*</span> _max_heap.top();
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> _max_heap.top();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> b <span style=color:#f92672>=</span> _min_heap.top();
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> a <span style=color:#f92672>+</span> <span style=color:#ae81ff>0.5</span> <span style=color:#f92672>*</span> b;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>void</span> do_adjust() {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (_max_heap.size() <span style=color:#f92672>&gt;</span> _min_heap.size() <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) {
</span></span><span style=display:flex><span>            _min_heap.push(_max_heap.top());
</span></span><span style=display:flex><span>            _max_heap.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>while</span> (_min_heap.size() <span style=color:#f92672>&gt;</span> _max_heap.size()) {
</span></span><span style=display:flex><span>            _max_heap.push(_min_heap.top());
</span></span><span style=display:flex><span>            _min_heap.pop();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    size_t _size;
</span></span><span style=display:flex><span>    MaxHeap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _max_heap;
</span></span><span style=display:flex><span>    MinHeap<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>int</span><span style=color:#f92672>&gt;</span> _min_heap;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://wizmann.top/tags/quick-sort/>Quick Sort</a></li><li><a href=https://wizmann.top/tags/median/>Median</a></li><li><a href=https://wizmann.top/tags/partition/>Partition</a></li><li><a href=https://wizmann.top/tags/priority-queue/>Priority Queue</a></li></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/cf-288-div-2/><span class=title>«</span><br><span>Codeforces Round #288 (Div. 2)</span>
</a><a class=next href=https://wizmann.top/posts/tlv-protocol/><span class=title>»</span><br><span>类型-长度-值（TLV）协议</span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>