<!doctype html><html><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body><header class=header-wrapper><div class=header><a class=site-title href=https://wizmann.top/>Maerlyn's Rainbow</a><nav class=menu></nav></div></header><main class=main-wrapper><div class=main><section class=single><h1 class=title>自定义你的stream buffer - phxrpc阅读笔记(1)</h1><div class=tip><time datetime="2016-09-28 22:35:55 +0000 UTC">2016/09/28</time>
<span class=split>·</span>
<span>6347 words </span><span class=split>·</span>
<span>13 minutes to read</span></div><div class=taxonomies><div>Tags:
<a href=/tags/system-design>System Design</a>
<a href=/tags/rpc>RPC</a>
<a href=/tags/streambuf>streambuf</a>
<a href=/tags/c++>C++</a>
<a href=/tags/phxrpc>phxrpc</a></div></div><hr><div class=content><h2 id=写在前面>写在前面 <a href=#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2 class=anchor>🔗</a></h2><p><a href=https://github.com/tencent-wechat/phxrpc>phxrpc</a>是微信团队开源的一个轻量级RPC框架。</p><p>我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。</p><p>就是这样。</p><h2 id=自定义stream-buffer>自定义stream buffer <a href=#%e8%87%aa%e5%ae%9a%e4%b9%89stream-buffer class=anchor>🔗</a></h2><p><code>network/socket_stream_base.[h|cpp]</code>中的<code>class BaseTcpStreamBuf</code>继承了<code>std::streambuf</code>，自定义了一个流缓冲区，用于接收/发送TCP数据包。</p><p>这个用法比较新颖（或者是我见识少），网上的资料也不多。这里翻译一篇<a href=http://www.mr-edd.co.uk/blog/beginners_guide_streambuf>介绍文章</a>，学习一下新姿势。</p><h2 id=a-beginners-guide-to-writing-a-custom-stream-buffer>A beginner&rsquo;s guide to writing a custom stream buffer <a href=#a-beginners-guide-to-writing-a-custom-stream-buffer class=anchor>🔗</a></h2><p>流(streams)是STL中提供的一个重要的抽象概念。著名的“Hello world”程序，便是使用了std::cout将字符串写入标准输出流(stdout)。</p><p>流当然可以做比cin/cout更有意思的事。这篇文章我们会研究如何扩展C++流，来实现自定义的流缓冲区(stream buffer)。p.s. 建议本文的读者至少要有基础的C++知识。</p><p>C++标准库为磁盘文件操作提供了基础的接口，如<code>std::fstream</code>，<code>std::ifstream</code>和<code>std::ofstream</code>。我们还有<code>stringstream</code>，可以像流一样操作字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, world!</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;</span>;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>123</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>string s <span style=color:#f92672>=</span> oss.str();
</span></span></code></pre></div><p>相似的，我们可以从<code>std::istringstream</code>中使用<code>>></code>操作符读取数据。</p><p>Boost库中的<code>lexical_cast</code>正是使用了这种机制，让用户可以使用统一的方式将一个对象(object)转换为字符串表示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> boost<span style=color:#f92672>::</span>lexical_cast;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>string s <span style=color:#f92672>=</span> lexical_cast<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(x);
</span></span><span style=display:flex><span>assert(s <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;5&#34;</span>);
</span></span></code></pre></div><p>流缓冲区有着很强的灵活性，可以满足不同的“缓冲并传输字符（串）”需求，比如文件操作、字符串操作、命令行(Console)操作等。我们可以从网络、闪存(Flash memory)等不同设备，使用同样的接口获取流式字符串。“流缓冲区”与“流”是正交的，所以我们可以自由的交换、更改(swap and change)流所使用的缓冲区，或者将其重定向到其它地方。我认为C++中的流，正是“策略模式”(strategy design pattern)的一个良好范例。</p><p>比如，我们可以重定向标准日志流<code>std::clog</code>到一个字符串流：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iomanip&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Make clog use the buffer from oss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>streambuf <span style=color:#f92672>*</span>former_buff <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>clog.rdbuf(oss.rdbuf());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>clog <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This will appear in oss!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>flush;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> oss.str() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Give clog back its previous buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>clog.rdbuf(former_buff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，自定义一个流缓冲区却是有一点tricky，或者说有一点吓人，尤其是当你第一次尝试的时候。所以本文意在提供一些流缓冲的实现范例。</p><p>首先我们来看一下流缓冲区的一些基本概念。所有的流缓冲区继承自<code>std::streambuf</code>，并且需要覆盖一些虚函数来实现自定义功能。<code>std::streambuf</code>是“顺序读取设备”的一个抽象，即我们可以从中顺序的读取字符序列。在特定的场景下，我们可以重填(re-fill)、冲洗(flush)以及清空(empty)一个缓冲区。</p><p>当我们向一个<code>ostream</code>中插入数据时，数据将会被写入缓冲区中的一个数组。当数组上溢(overflow)时，数组中的数据将会被冲洗(flush)到目标接受者，之后这个数组的状态将会重置，以便存储后续的字符。</p><p>当我们从一个<code>istream</code>中获取数据时，数据从缓冲区的数组中读出。当数组下溢时(underflow)，没有数据可读，我们会从数据源重新拉取信息来填充缓冲区，之后这个数组的状态也将被重置。</p><p>我们使用6个指针，来维护缓冲区的内部状态。输入和输出缓冲各使用3个指针。</p><h3 id=维护输出缓冲区的状态>维护输出缓冲区的状态 <a href=#%e7%bb%b4%e6%8a%a4%e8%be%93%e5%87%ba%e7%bc%93%e5%86%b2%e5%8c%ba%e7%9a%84%e7%8a%b6%e6%80%81 class=anchor>🔗</a></h3><ul><li><p>put base pointer<br>输出基指针，用来指定缓冲区内部数组的第一个元素。可以使用<code>std::streambuf::pbase()</code>来获取</p></li><li><p>put pointer<br>输出指针，用来指向内部数组下一个写入的地址。可以使用<code>std::streambuf::pptr()</code>来获取</p></li><li><p>end put pointer<br>输出哨兵指针，指向内部数组最后一个再后面一个(one-past-the-last-element)的地址（译注：类似<code>std::vector::end()</code>）。可以使用<code>std::streambuf:epptr()</code>来获取</p></li></ul><p><img src=http://i1.piimg.com/567571/630a89fe635e1635.png alt></p><p>一般来说，基指针和哨兵指针不会改变，在使用时，以输出指针维护内部状态。</p><h3 id=维护输入缓冲区的状态>维护输入缓冲区的状态 <a href=#%e7%bb%b4%e6%8a%a4%e8%be%93%e5%85%a5%e7%bc%93%e5%86%b2%e5%8c%ba%e7%9a%84%e7%8a%b6%e6%80%81 class=anchor>🔗</a></h3><p>输入缓冲区和状态维护和输出缓冲区类似，我们有：</p><ul><li>end back pointer<br>输入基指针，指向缓冲区数组内的最后一个字符。可以使用<code>std::streambuf::eback()</code>来获取</li><li>get pointer<br>输入指针，指向缓冲区下一个读取的字符地址。可以使用<code>std::streambuf::gptr()</code>来获取</li><li>end get pointer<br>输入哨兵指针，批号向内部数组最后一个再后面一个(one-past-the-last-element)的地址。可以使用<code>std::streambuf::egptr()</code>来获取</li></ul><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-9-27/33500590.jpg alt></p><p>同样，基指针和哨兵指针在流缓冲区的生命周期中也不会改变。</p><p>由于输入缓冲区要支持<code>putback()</code>操作，即将读出的字符重新放回缓冲区，所以输入缓冲区比输出缓冲区更复杂一点。通常来说，<code>putback()</code>操作支持放回一个字符即可。</p><p>一个<code>std::streambuf</code>可以同时支持输入输出两种操作，所以我们不需要我分别实现<code>std::istreambuf</code>和<code>std::ostreambuf</code>。<code>std::fstream</code>是一个良好的例子。但是，实现一个全功能的缓冲区相对更复杂一些，所以我就不趟浑水啦~ ：）</p><p>同时，流缓冲区也可以支持宽字符(wide character)。<code>std::streambuf</code>是<code>std::basic_streambuf&lt;char></code>的别名，如果你需要宽字符流缓冲区，可以使用<code>std::basic_streambuf&lt;wchar_t></code>。</p><h3 id=例1文件缓冲区--与c代码集成>例1：文件缓冲区 —— 与C代码集成 <a href=#%e4%be%8b1%e6%96%87%e4%bb%b6%e7%bc%93%e5%86%b2%e5%8c%ba--%e4%b8%8ec%e4%bb%a3%e7%a0%81%e9%9b%86%e6%88%90 class=anchor>🔗</a></h3><p>假设我们需要调用一个历史悠久的库，一个文件操作函数会返回给一个<code>FILE*</code>指针，但是我们想用C++的流接口来读写数据。我们先从读文件开始，用<code>std::istream</code>包装<code>FILE*</code>的读操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FILE_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>, std<span style=color:#f92672>::</span>size_t put_back <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// overrides base class underflow()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        int_type underflow();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        FILE_buffer(<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        FILE_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        FILE <span style=color:#f92672>*</span>fptr_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>size_t put_back_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>由于功能简单，我们只需要实现构造函数以及<code>underflow</code>接口就可以实现我们的功能。</p><p>构造函数指定了读取文件的<code>FILE*</code>指针，以及内部缓冲数组的大小。数组大小由两个参数决定：</p><ul><li>put-back area size</li><li>buffer size</li></ul><p>我们使用<code>std::vector&lt;char></code>做为缓冲区域。<code>put_back_</code>变量用于存储"put-back"区域的大小。</p><p>以下是构造函数的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>size_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FILE_buffer<span style=color:#f92672>::</span>FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, size_t buff_sz, size_t put_back) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    fptr_(fptr),
</span></span><span style=display:flex><span>    put_back_(std<span style=color:#f92672>::</span>max(put_back, size_t(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>    buffer_(std<span style=color:#f92672>::</span>max(buff_sz, put_back_) <span style=color:#f92672>+</span> put_back_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front() <span style=color:#f92672>+</span> buffer_.size();
</span></span><span style=display:flex><span>    setg(end, end, end);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在初始化列表中，我们将缓冲区的常量进行赋值。之后使用<code>std::streambuf::setg()</code>来初始化输出缓冲区。</p><p><code>setg()</code>的三个参数分别代表<code>eback()</code>，<code>gptr()</code>，<code>egptr()</code>三个内部指针的值。一开始，我们将它们都指向同一个地址。表明buffer是空的，在下一次读取时，会重新填充缓冲区。</p><p><code>underflow()</code>会返回数据源中当前的字符。一般来说，会返回buffer中的下一个可用字符。然后当buffer为空时，<code>underflow()</code>应该重新填充缓冲区数组，在本例中，即从<code>FILE*</code>中读取字符。当缓冲区重填后，我们需要再次调用<code>setg()</code>更新流缓冲区的状态。</p><p>当数据源中的数据读完(depleted)后，<code>underflow()</code>会返回一个<code>traits_type::eof()</code>。这里要注意，<code>underflow()</code>的返回值是<code>int_type</code>，这个值足够装下<code>eof()</code>，同时也足够装下任何的字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streambuf<span style=color:#f92672>::</span>int_type FILE_buffer<span style=color:#f92672>::</span>underflow()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (gptr() <span style=color:#f92672>&lt;</span> egptr()) <span style=color:#75715e>// buffer not exhausted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> base;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (eback() <span style=color:#f92672>==</span> base) <span style=color:#75715e>// true when this isn&#39;t the first fill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Make arrangements for putback characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>memmove(base, egptr() <span style=color:#f92672>-</span> put_back_, put_back_);
</span></span><span style=display:flex><span>        start <span style=color:#f92672>+=</span> put_back_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// start is now the start of the buffer, proper.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Read from fptr_ in to the provided buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t n <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>fread(start, <span style=color:#ae81ff>1</span>, buffer_.size() <span style=color:#f92672>-</span> (start <span style=color:#f92672>-</span> base), fptr_);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set buffer pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    setg(base, start, start <span style=color:#f92672>+</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数的第一行，首先判断buffer是否耗尽。如果否，则返回当前字符，即<code>*gptr()</code>。如果是，则进行重填(re-fill)操作。</p><p>回想一下我们在构造函数中的实现，三个状态指针全都指向缓冲区的末尾。如果我们调用<code>underflow()</code>时，发现状态指针并非如此，则说明缓冲区已经被填充了至少一次。</p><p>现在我们考虑重填操作，我们<code>memmove</code>最后<code>put_back_</code>个字符到buffer的末尾，用做"put-back area"。（我们不用<code>memcopy</code>因为我们的buffer比较小，`memmove()的效率会更高一些）</p><blockquote><p>译注：实际上，<code>memcopy</code>与<code>memmove</code>各有所长。<code>memcopy</code>不需要判断内存overlap的情况，即如果源区间与目标区间有重叠，那么得到的结果会是错的。而<code>memmove</code>由于是移动语义，所以在移动步长较小时，可以只操作cache。所以二者各有所长，要根据具体情况判断优劣。Stackoverflow上有更详细的<a href=http://stackoverflow.com/questions/28623895/why-is-memmove-faster-than-memcpy>讨论</a></p></blockquote><p>我们处理完"put-back area"之后，就可以使用<code>fread()</code>函数来重填缓冲区了。如果读不到数据，则意味着文件已经读到了结尾（当然这是一种简化情况，但在现实中99.9%的读取失败都是因为文件结束）。</p><p>在<code>fread()</code>成功读取数据之后，我们通知streambuf更新内部的三个状态指针。之后返回buffer当前的指针。</p><p>这就是我们的流缓冲区的基本实现，希望这并不是太难。当然我们还可以添加更多的功能。特别的是我们可以在缓冲区里面进行查找。如果你想实现它的话，可以试试重写<code>std::streambuf::seekoff()</code>和<code>std::streambuf::seekpos</code>虚成员函数。</p><p>我们也可以实现写缓冲区。不过，在你们读完第三个例子之后，你们就可以轻松愉快的实现自己的版本了，不骗你。</p><h3 id=例2读取内存中的数组>例2：读取内存中的数组 <a href=#%e4%be%8b2%e8%af%bb%e5%8f%96%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e6%95%b0%e7%bb%84 class=anchor>🔗</a></h3><p>本例中，我们要使用<code>std::istream</code>包装内存中的一个只读数组，并且格式化的进行读入。这个例子和上一个例子有一点不同的是，我们并不需要一个真正的缓冲数组，从源数组一次性读取就好了。</p><p>想象中的实现是这个样式儿的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            setg(begin, begin, end);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>underflow</span>()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>  gptr() <span style=color:#f92672>==</span> egptr() <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>但是，这并没有什么卵用。因为<code>setg()</code>函数只接受非常量(non-const)指针参数。这显而易见，如果一个缓冲区不可写，我们就不能提供"put-back"功能。所以我们要动一动手脚，重新实现一下这个类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>char_array_buffer</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type underflow();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>uflow</span>();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>pbackfail</span>(int_type ch);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>streamsize showmanyc();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        char_array_buffer(<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        char_array_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> begin_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> end_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> current_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在这个版本中，我们重写了几个私有函数，这些函数都是从<code>std::streambuf</code>继承而来。</p><p>第一个构造函数需要用户指定起止指针，而第二个构造函数只需要指定起始指针，之后我们会调用<code>std::strlen()</code>来判断字符串的大小。</p><p>我们使用<code>uflow()</code>, <code>pbackfail()</code>和<code>showmanyc()</code>来维护缓冲区内部的状态，而不是调用<code>setg()</code>，因为buffer并不可写。</p><p>在这个版本中，我们要手动维护<code>eback</code>, <code>gptr</code>, <code>egptr</code>三个指针。在构造函数中，我们将对其进行赋值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;char_array_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(begin),
</span></span><span style=display:flex><span>    end_(end),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(begin_, end_));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(str),
</span></span><span style=display:flex><span>    end_(begin_ <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>strlen(str)),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>之前我们使用<code>underflow()</code>来获取当前字符，但这次我们需要使用<code>uflow()</code>。因为<code>uflow()</code>需要同时执行两步操作，一是获取当前字符，二是让<code>gptr()</code>前进一步。但是又因为缓冲区由我们手动管理，<code>std::streambuf</code>并不能正确的执行管理操作。所以我们需要重写<code>uflow()</code>而不是<code>underflow()</code>。</p><div class=mermaid>char_array_buffer::int_type char_array_buffer::uflow()
{
if (current_ == end_)
return traits_type::eof();
return traits_type::to_int_type(*current_++);
}</div><p>下一步我们还要实现<code>pbackfail()</code>。当我们调用<code>std::istream::unget()</code>或<code>std::istream::putback(ch)</code>时，我们会把已经读出的数据写回数组中。但是由于数组是只读的，所以我们只能模拟这种操作。</p><p>在默认的实现中<code>pbackfail()</code>只会返回<code>traits_type::eof()</code>，而在我们的版本中，如果写回成功，将会返回写回的字符，不成功返回eof。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>int_type char_array_buffer<span style=color:#f92672>::</span>pbackfail(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (current_ <span style=color:#f92672>==</span> begin_ <span style=color:#f92672>||</span> (ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> current_[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*--</span>current_);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>FILE_buffer</code>中，我们也可以考虑重写<code>pbackfail()</code>，来提供反向查找以及（用前面的数据）重填buffer的功能。</p><p>最后一个重写的函数是<code>showmanyc()</code>，这个函数被<code>std::streambuf::in_avail()</code>调用，以判断当前有多少个字符可以返回。由于我们接管了状态指针，所以这个函数也要我们自己来实现啊。（译者：为什么要给自己找麻烦。。。）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streamsize char_array_buffer<span style=color:#f92672>::</span>showmanyc()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(current_, end_));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> end_ <span style=color:#f92672>-</span> current_;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由此可见，本例中的buffer比前面的要复杂一点点。这是因为我们接管了状态维护的工作。这使得我们更好的理解了<code>std::streambuf</code>内部是如何工作的。</p><h3 id=例3句首变大写的缓冲区>例3：句首变大写的缓冲区 <a href=#%e4%be%8b3%e5%8f%a5%e9%a6%96%e5%8f%98%e5%a4%a7%e5%86%99%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba class=anchor>🔗</a></h3><p>本例中我们将要实现一个将句首字符变大写的buffer。当然我们只考虑最基本的情况，移植到不同的区域和语言，其实是很琐碎的事情。（译者：文字编码坑的亲妈都不认了）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iosfwd&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>caps_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> do_caps_and_flush();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type overflow(int_type ch);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        caps_buffer(<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        caps_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> cap_next_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这里我们需要重写<code>overflow()</code>和<code>sync()</code>函数。<code>overflow()</code>在输入缓冲区满的时候被调用，并且在成功时返回任意非eof的值。</p><p><code>sync()</code>的作用是把当前的buffer写入目标，即使当前buffer并未填满。<code>std::flush()</code>会调用<code>sync()</code>函数，当失败时返回-1。</p><p>我们编写一个辅助函数<code>do_caps_and_flush()</code>，用来将小写变大写，并写入<code>sink_</code>输出流。我们再声明一个哨兵变量<code>cap_next_</code>来标识下一个字符是否需要小写变大写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;caps_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cctype&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    cap_next_(true),
</span></span><span style=display:flex><span>    sink_(sink),
</span></span><span style=display:flex><span>    buffer_(buff_sz <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sink_.clear();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    setp(base, base <span style=color:#f92672>+</span> buffer_.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// -1 to make overflow() easier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>buffer_</code>的最小可能大小是1，同时我们也只需要维护两个指针，因为这里不需要像输入缓冲区一样的维护"put-back area"。</p><p>我们把<code>buffer_</code>的大小设成<code>buff_sz + 1</code>，这样是为了<code>overflow()</code>被调用时，我们有一个额外的空间存储当前的字符。最后将缓冲区数组和最后一个字符一起刷新到<code>ostream</code>中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>int_type caps_buffer<span style=color:#f92672>::</span>overflow(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sink_ <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(pptr(), epptr()));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>pptr() <span style=color:#f92672>=</span> ch;
</span></span><span style=display:flex><span>        pbump(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (do_caps_and_flush())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ch;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一步是把ch写入<code>buffer_</code>，并且使用<code>pbump(1)</code>将<code>pptr()</code>向前移一位。之后调用<code>do_caps_and_flush()</code>做一些脏活，之后返回一个字符声明调用成功。</p><p><code>sync()</code>的实现也非常简单:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> caps_buffer<span style=color:#f92672>::</span>sync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>do_caps_and_flush</span>() <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们再看一看<code>do_caps_and_flush()</code>函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> caps_buffer<span style=color:#f92672>::</span>do_caps_and_flush()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> pbase(), <span style=color:#f92672>*</span>e <span style=color:#f92672>=</span> pptr(); p <span style=color:#f92672>!=</span> e; <span style=color:#f92672>++</span>p)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>p <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (std<span style=color:#f92672>::</span>isalpha(<span style=color:#f92672>*</span>p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cap_next_)
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>toupper(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ptrdiff_t n <span style=color:#f92672>=</span> pptr() <span style=color:#f92672>-</span> pbase();
</span></span><span style=display:flex><span>    pbump(<span style=color:#f92672>-</span>n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sink_.write(pbase(), n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于本例来说，内部的缓冲区并非必要，我们可以一个字符一个字符把数据发到<code>sink</code>中。但是我的观点是一个内部buffer仍有其用处。</p><h3 id=介绍-boost-iostreams-库>介绍 Boost IOStreams 库 <a href=#%e4%bb%8b%e7%bb%8d-boost-iostreams-%e5%ba%93 class=anchor>🔗</a></h3><p>如果你是流缓冲区的新手，希望你已经对它有一点点了解了。本文中的例子都非常基础，但是你可以用它们做更多有意思的事情。但是当我实现更复杂的流缓冲区时，问题的复杂度却上升的很快。这时我发现了<code>Boost IOStreams</code>库，它为更复杂的缓冲区和流提供了必要的框架支持。</p><p>它允许你解耦数据源，数据输出，过滤器以及其它一些概念。在我们的最后一个例子中，我们硬编码数据输出到<code>std::ostream</code>中。如果我们要输出到一个没有流接口的类呢？<code>Boost IOStreams</code>库提供了更多的灵活性，将一坨紧耦合的代码分解成独立的抽象概念。</p><h3 id=扩展阅读>扩展阅读 <a href=#%e6%89%a9%e5%b1%95%e9%98%85%e8%af%bb class=anchor>🔗</a></h3><ul><li>The C++ Standard Library by Nicolai M. Josuttis</li><li>The C++ Standard, BS ISO/IEC 14882:2003 (Second Edition)</li><li><a href=http://www.dinkumware.com/manuals/>Dinkum Compleat Reference online</a></li></ul></div></section></div><div class=side><div class=side-recent><h2 class=side-title><a href=/posts/>Recent Posts</a></h2><hr><ul><li><a href=/posts/why-not-start-with-ddia-part-1/>为什么我不建议你阅读《数据密集型应用系统设计》（之一）</a></li><li><a href=/posts/vertical-axis-wind-turbine-3d-model/>风力涡轮机 3D 模型 / Vertical Axis Wind Turbine (VAWT) 3D Model</a></li><li><a href=/posts/press-pad-3d-model/>3D打印解压玩具 / 3D Printed Fidget Toy</a></li><li><a href=/posts/lava-store/>论文阅读：LavaStore - 高性能、本地存储引擎的演进</a></li><li><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a></li></ul></div><div class=side-categories><h2>Categories</h2><hr><ul></ul></div><div class=side-tags><h2>Tags</h2><hr><ul><li><a href=/tags/.net>.net (1)</a></li><li><a href=/tags/3d-printing>3d printing (2)</a></li><li><a href=/tags/a2b>a2b (1)</a></li><li><a href=/tags/ahk>ahk (1)</a></li><li><a href=/tags/algorithm>algorithm (26)</a></li><li><a href=/tags/alloca>alloca (1)</a></li><li><a href=/tags/allocate>allocate (1)</a></li><li><a href=/tags/arduino>arduino (1)</a></li><li><a href=/tags/asm>asm (1)</a></li><li><a href=/tags/async>async (2)</a></li><li><a href=/tags/atcoder>atcoder (1)</a></li><li><a href=/tags/autohotkey>autohotkey (1)</a></li><li><a href=/tags/autopilot>autopilot (1)</a></li><li><a href=/tags/azure>azure (2)</a></li><li><a href=/tags/b-tree>b-tree (1)</a></li><li><a href=/tags/basic-paxos>basic paxos (2)</a></li><li><a href=/tags/bbr>bbr (1)</a></li><li><a href=/tags/binary-indexed-tree>binary indexed tree (1)</a></li><li><a href=/tags/binary-tree>binary tree (1)</a></li><li><a href=/tags/bittorrent>bittorrent (1)</a></li><li><a href=/tags/borg>borg (1)</a></li><li><a href=/tags/bw-tree>bw-tree (1)</a></li><li><a href=/tags/c>c# (1)</a></li><li><a href=/tags/c++>c++ (6)</a></li><li><a href=/tags/cache>cache (1)</a></li><li><a href=/tags/cachegrind>cachegrind (1)</a></li><li><a href=/tags/cap>cap (1)</a></li><li><a href=/tags/career>career (1)</a></li><li><a href=/tags/cas>cas (3)</a></li><li><a href=/tags/ceph>ceph (1)</a></li><li><a href=/tags/chrome-extension>chrome-extension (2)</a></li><li><a href=/tags/cmpxchg>cmpxchg (2)</a></li><li><a href=/tags/cocurrency>cocurrency (1)</a></li><li><a href=/tags/code-golf>code golf (1)</a></li><li><a href=/tags/codeforces>codeforces (14)</a></li><li><a href=/tags/compare-ans-swap>compare-ans-swap (1)</a></li><li><a href=/tags/computational-geometry>computational geometry (1)</a></li><li><a href=/tags/consistency>consistency (1)</a></li><li><a href=/tags/cpp>cpp (9)</a></li><li><a href=/tags/cpu>cpu (1)</a></li><li><a href=/tags/cse351>cse351 (2)</a></li><li><a href=/tags/csharp>csharp (1)</a></li><li><a href=/tags/css>css (1)</a></li><li><a href=/tags/data-center>data center (1)</a></li><li><a href=/tags/data-center-management>data center management (1)</a></li><li><a href=/tags/defer>defer (1)</a></li><li><a href=/tags/distributed-system>distributed system (4)</a></li><li><a href=/tags/epoll>epoll (1)</a></li><li><a href=/tags/ergodone>ergodone (1)</a></li><li><a href=/tags/fifo>fifo (1)</a></li><li><a href=/tags/flatbuffer>flatbuffer (2)</a></li><li><a href=/tags/fn-layer>fn-layer (1)</a></li><li><a href=/tags/front-end-development>front-end development (1)</a></li><li><a href=/tags/functional-programming>functional programming (1)</a></li><li><a href=/tags/game>game (1)</a></li><li><a href=/tags/gcj>gcj (1)</a></li><li><a href=/tags/geohash>geohash (1)</a></li><li><a href=/tags/geometric>geometric (1)</a></li><li><a href=/tags/geometry>geometry (1)</a></li><li><a href=/tags/get-things-done>get things done (1)</a></li><li><a href=/tags/google>google (3)</a></li><li><a href=/tags/graph>graph (1)</a></li><li><a href=/tags/head-first>head-first (1)</a></li><li><a href=/tags/heap>heap (1)</a></li><li><a href=/tags/herd7>herd7 (1)</a></li><li><a href=/tags/induction>induction (2)</a></li><li><a href=/tags/interview>interview (5)</a></li><li><a href=/tags/keyboard>keyboard (2)</a></li><li><a href=/tags/kubernetes>kubernetes (1)</a></li><li><a href=/tags/lavastore>lavastore (1)</a></li><li><a href=/tags/leetcode>leetcode (4)</a></li><li><a href=/tags/leveldb>leveldb (1)</a></li><li><a href=/tags/linkedin>linkedin (1)</a></li><li><a href=/tags/linux>linux (1)</a></li><li><a href=/tags/litmus>litmus (1)</a></li><li><a href=/tags/lock-less>lock-less (1)</a></li><li><a href=/tags/lsm-tree>lsm-tree (1)</a></li><li><a href=/tags/markdown>markdown (1)</a></li><li><a href=/tags/median>median (1)</a></li><li><a href=/tags/memory>memory (1)</a></li><li><a href=/tags/memory-barrier>memory-barrier (3)</a></li><li><a href=/tags/mesi>mesi (1)</a></li><li><a href=/tags/message-queue>message queue (1)</a></li><li><a href=/tags/metadata>metadata (1)</a></li><li><a href=/tags/metaprogramming>metaprogramming (1)</a></li><li><a href=/tags/microsoft>microsoft (2)</a></li><li><a href=/tags/misaka>misaka (1)</a></li><li><a href=/tags/modern-c++>modern c++ (1)</a></li><li><a href=/tags/modern-cpp>modern cpp (4)</a></li><li><a href=/tags/mosca>mosca (1)</a></li><li><a href=/tags/mq>mq (1)</a></li><li><a href=/tags/multi-paxos>multi paxos (1)</a></li><li><a href=/tags/multi-thread>multi-thread (3)</a></li><li><a href=/tags/multiprocess>multiprocess (1)</a></li><li><a href=/tags/multithread>multithread (3)</a></li><li><a href=/tags/network>network (1)</a></li><li><a href=/tags/networking>networking (4)</a></li><li><a href=/tags/non-blocking>non-blocking (1)</a></li><li><a href=/tags/normal-distribution>normal-distribution (1)</a></li><li><a href=/tags/ocaml>ocaml (1)</a></li><li><a href=/tags/ot>ot (1)</a></li><li><a href=/tags/parallel>parallel (1)</a></li><li><a href=/tags/partition>partition (1)</a></li><li><a href=/tags/paxos>paxos (2)</a></li><li><a href=/tags/pecifica>pecifica (1)</a></li><li><a href=/tags/pelican>pelican (1)</a></li><li><a href=/tags/phxrpc>phxrpc (8)</a></li><li><a href=/tags/pl>pl (1)</a></li><li><a href=/tags/poi>poi (1)</a></li><li><a href=/tags/poll>poll (1)</a></li><li><a href=/tags/powershell>powershell (1)</a></li><li><a href=/tags/priority-queue>priority queue (1)</a></li><li><a href=/tags/priority_queue>priority_queue (1)</a></li><li><a href=/tags/profile>profile (1)</a></li><li><a href=/tags/programming-interview>programming interview (1)</a></li><li><a href=/tags/promela>promela (2)</a></li><li><a href=/tags/protobuf>protobuf (1)</a></li><li><a href=/tags/protocol>protocol (4)</a></li><li><a href=/tags/python>python (3)</a></li><li><a href=/tags/quartile>quartile (1)</a></li><li><a href=/tags/queue>queue (2)</a></li><li><a href=/tags/quick-sort>quick sort (1)</a></li><li><a href=/tags/quora>quora (1)</a></li><li><a href=/tags/racket>racket (1)</a></li><li><a href=/tags/raft>raft (2)</a></li><li><a href=/tags/rocksdb>rocksdb (2)</a></li><li><a href=/tags/rpc>rpc (4)</a></li><li><a href=/tags/social-network>social network (1)</a></li><li><a href=/tags/socket>socket (1)</a></li><li><a href=/tags/solution>solution (2)</a></li><li><a href=/tags/sort>sort (1)</a></li><li><a href=/tags/spin>spin (4)</a></li><li><a href=/tags/spin/promela>spin/promela (2)</a></li><li><a href=/tags/stack>stack (2)</a></li><li><a href=/tags/stdfunction>std::function (1)</a></li><li><a href=/tags/stl>stl (1)</a></li><li><a href=/tags/storage>storage (3)</a></li><li><a href=/tags/storage-system>storage system (2)</a></li><li><a href=/tags/streambuf>streambuf (1)</a></li><li><a href=/tags/string>string (1)</a></li><li><a href=/tags/stup>stup (3)</a></li><li><a href=/tags/stylish>stylish (1)</a></li><li><a href=/tags/system>system (1)</a></li><li><a href=/tags/system-design>system design (5)</a></li><li><a href=/tags/tcp>tcp (4)</a></li><li><a href=/tags/tcpip>tcpip (1)</a></li><li><a href=/tags/thread>thread (3)</a></li><li><a href=/tags/tlv>tlv (1)</a></li><li><a href=/tags/twisted>twisted (1)</a></li><li><a href=/tags/ucontext>ucontext (2)</a></li><li><a href=/tags/udp>udp (3)</a></li><li><a href=/tags/useless>useless (1)</a></li><li><a href=/tags/userscript>userscript (1)</a></li><li><a href=/tags/valgrind>valgrind (1)</a></li><li><a href=/tags/wait-free>wait-free (1)</a></li><li><a href=/tags/was>was (1)</a></li><li><a href=/tags/wisckey>wisckey (1)</a></li><li><a href=/tags/workflowy>workflowy (1)</a></li><li><a href=/tags/wsl>wsl (1)</a></li><li><a href=/tags/yunfile>yunfile (1)</a></li><li><a href=/tags/zeromq>zeromq (1)</a></li><li><a href=/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B>并发编程 (1)</a></li><li><a href=/tags/%E7%B3%99%E5%BF%AB%E7%8C%9B>糙快猛 (1)</a></li><li><a href=/tags/%E5%88%9B%E9%80%A0%E5%8A%9B>创造力 (1)</a></li><li><a href=/tags/%E8%AF%BB%E4%B9%A6>读书 (2)</a></li><li><a href=/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B>多线程 (2)</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统 (6)</a></li><li><a href=/tags/%E5%88%86%E7%B1%BB%E5%99%A8>分类器 (1)</a></li><li><a href=/tags/%E5%85%AC%E5%BC%80%E8%AF%BE>公开课 (4)</a></li><li><a href=/tags/%E8%AE%A1%E6%95%B0>计数 (1)</a></li><li><a href=/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6>计算机科学 (1)</a></li><li><a href=/tags/%E9%93%BE%E8%A1%A8>链表 (1)</a></li><li><a href=/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB>论文阅读 (1)</a></li><li><a href=/tags/%E9%9D%A2%E8%AF%95>面试 (1)</a></li><li><a href=/tags/%E5%AE%B9%E6%96%A5%E5%8E%9F%E7%90%86>容斥原理 (1)</a></li><li><a href=/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F>设计模式 (2)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81>数据编码 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库 (4)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%AF%86%E9%9B%86%E5%9E%8B%E5%BA%94%E7%94%A8%E7%B3%BB%E7%BB%9F>数据密集型应用系统 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B>数据模型 (1)</a></li><li><a href=/tags/%E6%95%B0%E6%8D%AE%E7%B3%BB%E7%BB%9F>数据系统 (1)</a></li><li><a href=/tags/%E6%80%9D%E7%BB%B4>思维 (1)</a></li><li><a href=/tags/%E7%AE%97%E6%B3%95>算法 (14)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95>索引 (1)</a></li><li><a href=/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84>索引结构 (1)</a></li><li><a href=/tags/%E9%A2%98%E8%A7%A3>题解 (11)</a></li><li><a href=/tags/%E9%97%B2%E8%81%8A>闲聊 (3)</a></li><li><a href=/tags/%E5%8D%8F%E7%A8%8B>协程 (1)</a></li><li><a href=/tags/%E5%8E%8B%E7%BC%A9>压缩 (1)</a></li><li><a href=/tags/%E4%B8%80%E8%87%B4%E6%80%A7>一致性 (3)</a></li><li><a href=/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6>主从复制 (1)</a></li><li><a href=/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2>字符串 (1)</a></li><li><a href=/tags/%E6%9C%80%E5%B0%8F%E8%A1%A8%E7%A4%BA%E6%B3%95>最小表示法 (1)</a></li></ul></div></div></main><footer class=footer><div class=footer-row><a class=footer-item href=https://wizmann.top/posts/index.xml>Feed of Posts
<i class=icofont-rss></i></a></div></footer></body></html>