<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content="Date: 2016-09-28 22:35:55
Title: 自定义你的stream buffer - phxrpc阅读笔记(1)
Tags: System Design, RPC, streambuf, C++, phxrpc
Slug: phxrpc-1
写在前面
phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。"><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/posts/phxrpc-1/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh-cn href=https://wizmann.top/posts/phxrpc-1/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/posts/phxrpc-1/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:description" content="Date: 2016-09-28 22:35:55 Title: 自定义你的stream buffer - phxrpc阅读笔记(1) Tags: System Design, RPC, streambuf, C++, phxrpc Slug: phxrpc-1
写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta name=twitter:card content="summary"><meta name=twitter:title content><meta name=twitter:description content="Date: 2016-09-28 22:35:55
Title: 自定义你的stream buffer - phxrpc阅读笔记(1)
Tags: System Design, RPC, streambuf, C++, phxrpc
Slug: phxrpc-1
写在前面
phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wizmann.top/posts/"},{"@type":"ListItem","position":2,"name":"","item":"https://wizmann.top/posts/phxrpc-1/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"","name":"","description":"Date: 2016-09-28 22:35:55 Title: 自定义你的stream buffer - phxrpc阅读笔记(1) Tags: System Design, RPC, streambuf, C++, phxrpc Slug: phxrpc-1\n写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。\n我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。\n","keywords":[],"articleBody":"Date: 2016-09-28 22:35:55 Title: 自定义你的stream buffer - phxrpc阅读笔记(1) Tags: System Design, RPC, streambuf, C++, phxrpc Slug: phxrpc-1\n写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。\n我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。\n就是这样。\n自定义stream buffer network/socket_stream_base.[h|cpp]中的class BaseTcpStreamBuf继承了std::streambuf，自定义了一个流缓冲区，用于接收/发送TCP数据包。\n这个用法比较新颖（或者是我见识少），网上的资料也不多。这里翻译一篇介绍文章，学习一下新姿势。\nA beginner’s guide to writing a custom stream buffer 流(streams)是STL中提供的一个重要的抽象概念。著名的“Hello world”程序，便是使用了std::cout将字符串写入标准输出流(stdout)。\n流当然可以做比cin/cout更有意思的事。这篇文章我们会研究如何扩展C++流，来实现自定义的流缓冲区(stream buffer)。p.s. 建议本文的读者至少要有基础的C++知识。\nC++标准库为磁盘文件操作提供了基础的接口，如std::fstream，std::ifstream和std::ofstream。我们还有stringstream，可以像流一样操作字符串。\nstd::ostringstream oss; oss \u003c\u003c \"Hello, world!\\\\n\"; oss \u003c\u003c 123 \u003c\u003c '\\\\n'; std::string s = oss.str(); 相似的，我们可以从std::istringstream中使用\u003e\u003e操作符读取数据。\nBoost库中的lexical_cast正是使用了这种机制，让用户可以使用统一的方式将一个对象(object)转换为字符串表示。\nusing boost::lexical_cast; using std::string; int x = 5; string s = lexical_cast\u003cstring\u003e(x); assert(s == \"5\"); 流缓冲区有着很强的灵活性，可以满足不同的“缓冲并传输字符（串）”需求，比如文件操作、字符串操作、命令行(Console)操作等。我们可以从网络、闪存(Flash memory)等不同设备，使用同样的接口获取流式字符串。“流缓冲区”与“流”是正交的，所以我们可以自由的交换、更改(swap and change)流所使用的缓冲区，或者将其重定向到其它地方。我认为C++中的流，正是“策略模式”(strategy design pattern)的一个良好范例。\n比如，我们可以重定向标准日志流std::clog到一个字符串流：\n#include #include #include #include int main() { std::ostringstream oss; // Make clog use the buffer from oss std::streambuf *former_buff = std::clog.rdbuf(oss.rdbuf()); std::clog \u003c\u003c \"This will appear in oss!\" \u003c\u003c std::flush; std::cout \u003c\u003c oss.str() \u003c\u003c '\\\\n'; // Give clog back its previous buffer std::clog.rdbuf(former_buff); return 0; } 不过，自定义一个流缓冲区却是有一点tricky，或者说有一点吓人，尤其是当你第一次尝试的时候。所以本文意在提供一些流缓冲的实现范例。\n首先我们来看一下流缓冲区的一些基本概念。所有的流缓冲区继承自std::streambuf，并且需要覆盖一些虚函数来实现自定义功能。std::streambuf是“顺序读取设备”的一个抽象，即我们可以从中顺序的读取字符序列。在特定的场景下，我们可以重填(re-fill)、冲洗(flush)以及清空(empty)一个缓冲区。\n当我们向一个ostream中插入数据时，数据将会被写入缓冲区中的一个数组。当数组上溢(overflow)时，数组中的数据将会被冲洗(flush)到目标接受者，之后这个数组的状态将会重置，以便存储后续的字符。\n当我们从一个istream中获取数据时，数据从缓冲区的数组中读出。当数组下溢时(underflow)，没有数据可读，我们会从数据源重新拉取信息来填充缓冲区，之后这个数组的状态也将被重置。\n我们使用6个指针，来维护缓冲区的内部状态。输入和输出缓冲各使用3个指针。\n维护输出缓冲区的状态 put base pointer 输出基指针，用来指定缓冲区内部数组的第一个元素。可以使用std::streambuf::pbase()来获取\nput pointer 输出指针，用来指向内部数组下一个写入的地址。可以使用std::streambuf::pptr()来获取\nend put pointer 输出哨兵指针，指向内部数组最后一个再后面一个(one-past-the-last-element)的地址（译注：类似std::vector::end()）。可以使用std::streambuf:epptr()来获取\n一般来说，基指针和哨兵指针不会改变，在使用时，以输出指针维护内部状态。\n维护输入缓冲区的状态 输入缓冲区和状态维护和输出缓冲区类似，我们有：\nend back pointer 输入基指针，指向缓冲区数组内的最后一个字符。可以使用std::streambuf::eback()来获取 get pointer 输入指针，指向缓冲区下一个读取的字符地址。可以使用std::streambuf::gptr()来获取 end get pointer 输入哨兵指针，批号向内部数组最后一个再后面一个(one-past-the-last-element)的地址。可以使用std::streambuf::egptr()来获取 同样，基指针和哨兵指针在流缓冲区的生命周期中也不会改变。\n由于输入缓冲区要支持putback()操作，即将读出的字符重新放回缓冲区，所以输入缓冲区比输出缓冲区更复杂一点。通常来说，putback()操作支持放回一个字符即可。\n一个std::streambuf可以同时支持输入输出两种操作，所以我们不需要我分别实现std::istreambuf和std::ostreambuf。std::fstream是一个良好的例子。但是，实现一个全功能的缓冲区相对更复杂一些，所以我就不趟浑水啦~ ：）\n同时，流缓冲区也可以支持宽字符(wide character)。std::streambuf是std::basic_streambuf的别名，如果你需要宽字符流缓冲区，可以使用std::basic_streambuf。\n例1：文件缓冲区 —— 与C代码集成 假设我们需要调用一个历史悠久的库，一个文件操作函数会返回给一个FILE*指针，但是我们想用C++的流接口来读写数据。我们先从读文件开始，用std::istream包装FILE*的读操作。\n#include #include #include #include class FILE_buffer : public std::streambuf { public: explicit FILE_buffer(FILE *fptr, std::size_t buff_sz = 256, std::size_t put_back = 8); private: // overrides base class underflow() int_type underflow(); // copy ctor and assignment not implemented; // copying not allowed FILE_buffer(const FILE_buffer \u0026); FILE_buffer \u0026operator= (const FILE_buffer \u0026); private: FILE *fptr_; const std::size_t put_back_; std::vector\u003cchar\u003e buffer_; }; 由于功能简单，我们只需要实现构造函数以及underflow接口就可以实现我们的功能。\n构造函数指定了读取文件的FILE*指针，以及内部缓冲数组的大小。数组大小由两个参数决定：\nput-back area size buffer size 我们使用std::vector做为缓冲区域。put_back_变量用于存储\"put-back\"区域的大小。\n以下是构造函数的实现：\nusing std::size_t; FILE_buffer::FILE_buffer(FILE *fptr, size_t buff_sz, size_t put_back) : fptr_(fptr), put_back_(std::max(put_back, size_t(1))), buffer_(std::max(buff_sz, put_back_) + put_back_) { char *end = \u0026buffer_.front() + buffer_.size(); setg(end, end, end); } 在初始化列表中，我们将缓冲区的常量进行赋值。之后使用std::streambuf::setg()来初始化输出缓冲区。\nsetg()的三个参数分别代表eback()，gptr()，egptr()三个内部指针的值。一开始，我们将它们都指向同一个地址。表明buffer是空的，在下一次读取时，会重新填充缓冲区。\nunderflow()会返回数据源中当前的字符。一般来说，会返回buffer中的下一个可用字符。然后当buffer为空时，underflow()应该重新填充缓冲区数组，在本例中，即从FILE*中读取字符。当缓冲区重填后，我们需要再次调用setg()更新流缓冲区的状态。\n当数据源中的数据读完(depleted)后，underflow()会返回一个traits_type::eof()。这里要注意，underflow()的返回值是int_type，这个值足够装下eof()，同时也足够装下任何的字符。\nstd::streambuf::int_type FILE_buffer::underflow() { if (gptr() \u003c egptr()) // buffer not exhausted return traits_type::to_int_type(*gptr()); char *base = \u0026buffer_.front(); char *start = base; if (eback() == base) // true when this isn't the first fill { // Make arrangements for putback characters std::memmove(base, egptr() - put_back_, put_back_); start += put_back_; } // start is now the start of the buffer, proper. // Read from fptr_ in to the provided buffer size_t n = std::fread(start, 1, buffer_.size() - (start - base), fptr_); if (n == 0) return traits_type::eof(); // Set buffer pointers setg(base, start, start + n); return traits_type::to_int_type(*gptr()); } 函数的第一行，首先判断buffer是否耗尽。如果否，则返回当前字符，即*gptr()。如果是，则进行重填(re-fill)操作。\n回想一下我们在构造函数中的实现，三个状态指针全都指向缓冲区的末尾。如果我们调用underflow()时，发现状态指针并非如此，则说明缓冲区已经被填充了至少一次。\n现在我们考虑重填操作，我们memmove最后put_back_个字符到buffer的末尾，用做\"put-back area\"。（我们不用memcopy因为我们的buffer比较小，`memmove()的效率会更高一些）\n译注：实际上，memcopy与memmove各有所长。memcopy不需要判断内存overlap的情况，即如果源区间与目标区间有重叠，那么得到的结果会是错的。而memmove由于是移动语义，所以在移动步长较小时，可以只操作cache。所以二者各有所长，要根据具体情况判断优劣。Stackoverflow上有更详细的讨论\n我们处理完\"put-back area\"之后，就可以使用fread()函数来重填缓冲区了。如果读不到数据，则意味着文件已经读到了结尾（当然这是一种简化情况，但在现实中99.9%的读取失败都是因为文件结束）。\n在fread()成功读取数据之后，我们通知streambuf更新内部的三个状态指针。之后返回buffer当前的指针。\n这就是我们的流缓冲区的基本实现，希望这并不是太难。当然我们还可以添加更多的功能。特别的是我们可以在缓冲区里面进行查找。如果你想实现它的话，可以试试重写std::streambuf::seekoff()和std::streambuf::seekpos虚成员函数。\n我们也可以实现写缓冲区。不过，在你们读完第三个例子之后，你们就可以轻松愉快的实现自己的版本了，不骗你。\n例2：读取内存中的数组 本例中，我们要使用std::istream包装内存中的一个只读数组，并且格式化的进行读入。这个例子和上一个例子有一点不同的是，我们并不需要一个真正的缓冲数组，从源数组一次性读取就好了。\n想象中的实现是这个样式儿的：\nclass char_array_buffer : public std::streambuf { public: char_array_buffer(const char *begin, const char *end) { setg(begin, begin, end); } int_type underflow() { return gptr() == egptr() ? traits_type::eof() : traits_type::to_int_type(*gptr()); } }; 但是，这并没有什么卵用。因为setg()函数只接受非常量(non-const)指针参数。这显而易见，如果一个缓冲区不可写，我们就不能提供\"put-back\"功能。所以我们要动一动手脚，重新实现一下这个类。\n#include class char_array_buffer : public std::streambuf { public: char_array_buffer(const char *begin, const char *end); explicit char_array_buffer(const char *str); private: int_type underflow(); int_type uflow(); int_type pbackfail(int_type ch); std::streamsize showmanyc(); // copy ctor and assignment not implemented; // copying not allowed char_array_buffer(const char_array_buffer \u0026); char_array_buffer \u0026operator= (const char_array_buffer \u0026); private: const char * const begin_; const char * const end_; const char * current_; }; 在这个版本中，我们重写了几个私有函数，这些函数都是从std::streambuf继承而来。\n第一个构造函数需要用户指定起止指针，而第二个构造函数只需要指定起始指针，之后我们会调用std::strlen()来判断字符串的大小。\n我们使用uflow(), pbackfail()和showmanyc()来维护缓冲区内部的状态，而不是调用setg()，因为buffer并不可写。\n在这个版本中，我们要手动维护eback, gptr, egptr三个指针。在构造函数中，我们将对其进行赋值。\n#include \"char_array_buffer.hpp\" #include #include #include char_array_buffer::char_array_buffer(const char *begin, const char *end) : begin_(begin), end_(end), current_(begin_) { assert(std::less_equal\u003cconst char *\u003e()(begin_, end_)); } char_array_buffer::char_array_buffer(const char *str) : begin_(str), end_(begin_ + std::strlen(str)), current_(begin_) { } 之前我们使用underflow()来获取当前字符，但这次我们需要使用uflow()。因为uflow()需要同时执行两步操作，一是获取当前字符，二是让gptr()前进一步。但是又因为缓冲区由我们手动管理，std::streambuf并不能正确的执行管理操作。所以我们需要重写uflow()而不是underflow()。\nc { } h a r _ i r a f e r t r ( u a c r r y u e n _ r t b r u t u e r r f n n a f t i e _ t t r r s : = a _ : = i t i t y n e s p t n _ e _ d t : t _ y : y ) p t p e o e : _ : i c e n h o t a f _ r ( t _ ) y a ; p r e r ( a * y c _ u b r u r f e f n e t r _ : + : + u ) f ; l o w ( ) 下一步我们还要实现pbackfail()。当我们调用std::istream::unget()或std::istream::putback(ch)时，我们会把已经读出的数据写回数组中。但是由于数组是只读的，所以我们只能模拟这种操作。\n在默认的实现中pbackfail()只会返回traits_type::eof()，而在我们的版本中，如果写回成功，将会返回写回的字符，不成功返回eof。\nchar_array_buffer::int_type char_array_buffer::pbackfail(int_type ch) { if (current_ == begin_ || (ch != traits_type::eof() \u0026\u0026 ch != current_[-1])) return traits_type::eof(); return traits_type::to_int_type(*--current_); } 在FILE_buffer中，我们也可以考虑重写pbackfail()，来提供反向查找以及（用前面的数据）重填buffer的功能。\n最后一个重写的函数是showmanyc()，这个函数被std::streambuf::in_avail()调用，以判断当前有多少个字符可以返回。由于我们接管了状态指针，所以这个函数也要我们自己来实现啊。（译者：为什么要给自己找麻烦。。。）\nstd::streamsize char_array_buffer::showmanyc() { assert(std::less_equal\u003cconst char *\u003e()(current_, end_)); return end_ - current_; } 由此可见，本例中的buffer比前面的要复杂一点点。这是因为我们接管了状态维护的工作。这使得我们更好的理解了std::streambuf内部是如何工作的。\n例3：句首变大写的缓冲区 本例中我们将要实现一个将句首字符变大写的buffer。当然我们只考虑最基本的情况，移植到不同的区域和语言，其实是很琐碎的事情。（译者：文字编码坑的亲妈都不认了）\n#include #include #include #include class caps_buffer : public std::streambuf { public: explicit caps_buffer(std::ostream \u0026sink, std::size_t buff_sz = 256); protected: bool do_caps_and_flush(); private: int_type overflow(int_type ch); int sync(); // copy ctor and assignment not implemented; // copying not allowed caps_buffer(const caps_buffer \u0026); caps_buffer \u0026operator= (const caps_buffer \u0026); private: bool cap_next_; std::ostream \u0026sink_; std::vector\u003cchar\u003e buffer_; }; 这里我们需要重写overflow()和sync()函数。overflow()在输入缓冲区满的时候被调用，并且在成功时返回任意非eof的值。\nsync()的作用是把当前的buffer写入目标，即使当前buffer并未填满。std::flush()会调用sync()函数，当失败时返回-1。\n我们编写一个辅助函数do_caps_and_flush()，用来将小写变大写，并写入sink_输出流。我们再声明一个哨兵变量cap_next_来标识下一个字符是否需要小写变大写。\n#include \"caps_buffer.hpp\" #include #include #include #include caps_buffer::caps_buffer(std::ostream \u0026sink, std::size_t buff_sz) : cap_next_(true), sink_(sink), buffer_(buff_sz + 1) { sink_.clear(); char *base = \u0026buffer_.front(); setp(base, base + buffer_.size() - 1); // -1 to make overflow() easier } buffer_的最小可能大小是1，同时我们也只需要维护两个指针，因为这里不需要像输入缓冲区一样的维护\"put-back area\"。\n我们把buffer_的大小设成buff_sz + 1，这样是为了overflow()被调用时，我们有一个额外的空间存储当前的字符。最后将缓冲区数组和最后一个字符一起刷新到ostream中。\ncaps_buffer::int_type caps_buffer::overflow(int_type ch) { if (sink_ \u0026\u0026 ch != traits_type::eof()) { assert(std::less_equal\u003cchar *\u003e()(pptr(), epptr())); *pptr() = ch; pbump(1); if (do_caps_and_flush()) return ch; } return traits_type::eof(); } 第一步是把ch写入buffer_，并且使用pbump(1)将pptr()向前移一位。之后调用do_caps_and_flush()做一些脏活，之后返回一个字符声明调用成功。\nsync()的实现也非常简单:\nint caps_buffer::sync() { return do_caps_and_flush() ? 0 : -1; } 我们再看一看do_caps_and_flush()函数\nbool caps_buffer::do_caps_and_flush() { for (char *p = pbase(), *e = pptr(); p != e; ++p) { if (*p == '.') cap_next_ = true; else if (std::isalpha(*p)) { if (cap_next_) *p = std::toupper(*p); cap_next_ = false; } } std::ptrdiff_t n = pptr() - pbase(); pbump(-n); return sink_.write(pbase(), n); } 对于本例来说，内部的缓冲区并非必要，我们可以一个字符一个字符把数据发到sink中。但是我的观点是一个内部buffer仍有其用处。\n介绍 Boost IOStreams 库 如果你是流缓冲区的新手，希望你已经对它有一点点了解了。本文中的例子都非常基础，但是你可以用它们做更多有意思的事情。但是当我实现更复杂的流缓冲区时，问题的复杂度却上升的很快。这时我发现了Boost IOStreams库，它为更复杂的缓冲区和流提供了必要的框架支持。\n它允许你解耦数据源，数据输出，过滤器以及其它一些概念。在我们的最后一个例子中，我们硬编码数据输出到std::ostream中。如果我们要输出到一个没有流接口的类呢？Boost IOStreams库提供了更多的灵活性，将一坨紧耦合的代码分解成独立的抽象概念。\n扩展阅读 The C++ Standard Library by Nicolai M. Josuttis The C++ Standard, BS ISO/IEC 14882:2003 (Second Edition) Dinkum Compleat Reference online ","wordCount":"6506","inLanguage":"zh-cn","datePublished":"0001-01-01T00:00:00Z","dateModified":"0001-01-01T00:00:00Z","author":{"@type":"Person","name":"wizmann"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://wizmann.top/posts/phxrpc-1/"},"publisher":{"@type":"Organization","name":"Maerlyn's Rainbow","logo":{"@type":"ImageObject","url":"https://wizmann.top/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent"></h1><div class=post-meta>wizmann</div></header><div class=post-content><p>Date: 2016-09-28 22:35:55
Title: 自定义你的stream buffer - phxrpc阅读笔记(1)
Tags: System Design, RPC, streambuf, C++, phxrpc
Slug: phxrpc-1</p><h2 id=写在前面>写在前面<a hidden class=anchor aria-hidden=true href=#写在前面>#</a></h2><p><a href=https://github.com/tencent-wechat/phxrpc>phxrpc</a>是微信团队开源的一个轻量级RPC框架。</p><p>我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。</p><p>就是这样。</p><h2 id=自定义stream-buffer>自定义stream buffer<a hidden class=anchor aria-hidden=true href=#自定义stream-buffer>#</a></h2><p><code>network/socket_stream_base.[h|cpp]</code>中的<code>class BaseTcpStreamBuf</code>继承了<code>std::streambuf</code>，自定义了一个流缓冲区，用于接收/发送TCP数据包。</p><p>这个用法比较新颖（或者是我见识少），网上的资料也不多。这里翻译一篇<a href=http://www.mr-edd.co.uk/blog/beginners_guide_streambuf>介绍文章</a>，学习一下新姿势。</p><h2 id=a-beginners-guide-to-writing-a-custom-stream-buffer>A beginner&rsquo;s guide to writing a custom stream buffer<a hidden class=anchor aria-hidden=true href=#a-beginners-guide-to-writing-a-custom-stream-buffer>#</a></h2><p>流(streams)是STL中提供的一个重要的抽象概念。著名的“Hello world”程序，便是使用了std::cout将字符串写入标准输出流(stdout)。</p><p>流当然可以做比cin/cout更有意思的事。这篇文章我们会研究如何扩展C++流，来实现自定义的流缓冲区(stream buffer)。p.s. 建议本文的读者至少要有基础的C++知识。</p><p>C++标准库为磁盘文件操作提供了基础的接口，如<code>std::fstream</code>，<code>std::ifstream</code>和<code>std::ofstream</code>。我们还有<code>stringstream</code>，可以像流一样操作字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, world!</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;</span>;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>123</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>string s <span style=color:#f92672>=</span> oss.str();
</span></span></code></pre></div><p>相似的，我们可以从<code>std::istringstream</code>中使用<code>>></code>操作符读取数据。</p><p>Boost库中的<code>lexical_cast</code>正是使用了这种机制，让用户可以使用统一的方式将一个对象(object)转换为字符串表示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> boost<span style=color:#f92672>::</span>lexical_cast;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>string s <span style=color:#f92672>=</span> lexical_cast<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(x);
</span></span><span style=display:flex><span>assert(s <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;5&#34;</span>);
</span></span></code></pre></div><p>流缓冲区有着很强的灵活性，可以满足不同的“缓冲并传输字符（串）”需求，比如文件操作、字符串操作、命令行(Console)操作等。我们可以从网络、闪存(Flash memory)等不同设备，使用同样的接口获取流式字符串。“流缓冲区”与“流”是正交的，所以我们可以自由的交换、更改(swap and change)流所使用的缓冲区，或者将其重定向到其它地方。我认为C++中的流，正是“策略模式”(strategy design pattern)的一个良好范例。</p><p>比如，我们可以重定向标准日志流<code>std::clog</code>到一个字符串流：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iomanip&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Make clog use the buffer from oss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>streambuf <span style=color:#f92672>*</span>former_buff <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>clog.rdbuf(oss.rdbuf());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>clog <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This will appear in oss!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>flush;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> oss.str() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Give clog back its previous buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>clog.rdbuf(former_buff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，自定义一个流缓冲区却是有一点tricky，或者说有一点吓人，尤其是当你第一次尝试的时候。所以本文意在提供一些流缓冲的实现范例。</p><p>首先我们来看一下流缓冲区的一些基本概念。所有的流缓冲区继承自<code>std::streambuf</code>，并且需要覆盖一些虚函数来实现自定义功能。<code>std::streambuf</code>是“顺序读取设备”的一个抽象，即我们可以从中顺序的读取字符序列。在特定的场景下，我们可以重填(re-fill)、冲洗(flush)以及清空(empty)一个缓冲区。</p><p>当我们向一个<code>ostream</code>中插入数据时，数据将会被写入缓冲区中的一个数组。当数组上溢(overflow)时，数组中的数据将会被冲洗(flush)到目标接受者，之后这个数组的状态将会重置，以便存储后续的字符。</p><p>当我们从一个<code>istream</code>中获取数据时，数据从缓冲区的数组中读出。当数组下溢时(underflow)，没有数据可读，我们会从数据源重新拉取信息来填充缓冲区，之后这个数组的状态也将被重置。</p><p>我们使用6个指针，来维护缓冲区的内部状态。输入和输出缓冲各使用3个指针。</p><h3 id=维护输出缓冲区的状态>维护输出缓冲区的状态<a hidden class=anchor aria-hidden=true href=#维护输出缓冲区的状态>#</a></h3><ul><li><p>put base pointer<br>输出基指针，用来指定缓冲区内部数组的第一个元素。可以使用<code>std::streambuf::pbase()</code>来获取</p></li><li><p>put pointer<br>输出指针，用来指向内部数组下一个写入的地址。可以使用<code>std::streambuf::pptr()</code>来获取</p></li><li><p>end put pointer<br>输出哨兵指针，指向内部数组最后一个再后面一个(one-past-the-last-element)的地址（译注：类似<code>std::vector::end()</code>）。可以使用<code>std::streambuf:epptr()</code>来获取</p></li></ul><p><img loading=lazy src=http://i1.piimg.com/567571/630a89fe635e1635.png></p><p>一般来说，基指针和哨兵指针不会改变，在使用时，以输出指针维护内部状态。</p><h3 id=维护输入缓冲区的状态>维护输入缓冲区的状态<a hidden class=anchor aria-hidden=true href=#维护输入缓冲区的状态>#</a></h3><p>输入缓冲区和状态维护和输出缓冲区类似，我们有：</p><ul><li>end back pointer<br>输入基指针，指向缓冲区数组内的最后一个字符。可以使用<code>std::streambuf::eback()</code>来获取</li><li>get pointer<br>输入指针，指向缓冲区下一个读取的字符地址。可以使用<code>std::streambuf::gptr()</code>来获取</li><li>end get pointer<br>输入哨兵指针，批号向内部数组最后一个再后面一个(one-past-the-last-element)的地址。可以使用<code>std::streambuf::egptr()</code>来获取</li></ul><p><img loading=lazy src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-9-27/33500590.jpg></p><p>同样，基指针和哨兵指针在流缓冲区的生命周期中也不会改变。</p><p>由于输入缓冲区要支持<code>putback()</code>操作，即将读出的字符重新放回缓冲区，所以输入缓冲区比输出缓冲区更复杂一点。通常来说，<code>putback()</code>操作支持放回一个字符即可。</p><p>一个<code>std::streambuf</code>可以同时支持输入输出两种操作，所以我们不需要我分别实现<code>std::istreambuf</code>和<code>std::ostreambuf</code>。<code>std::fstream</code>是一个良好的例子。但是，实现一个全功能的缓冲区相对更复杂一些，所以我就不趟浑水啦~ ：）</p><p>同时，流缓冲区也可以支持宽字符(wide character)。<code>std::streambuf</code>是<code>std::basic_streambuf&lt;char></code>的别名，如果你需要宽字符流缓冲区，可以使用<code>std::basic_streambuf&lt;wchar_t></code>。</p><h3 id=例1文件缓冲区--与c代码集成>例1：文件缓冲区 —— 与C代码集成<a hidden class=anchor aria-hidden=true href=#例1文件缓冲区--与c代码集成>#</a></h3><p>假设我们需要调用一个历史悠久的库，一个文件操作函数会返回给一个<code>FILE*</code>指针，但是我们想用C++的流接口来读写数据。我们先从读文件开始，用<code>std::istream</code>包装<code>FILE*</code>的读操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FILE_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>, std<span style=color:#f92672>::</span>size_t put_back <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// overrides base class underflow()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        int_type underflow();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        FILE_buffer(<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        FILE_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        FILE <span style=color:#f92672>*</span>fptr_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>size_t put_back_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>由于功能简单，我们只需要实现构造函数以及<code>underflow</code>接口就可以实现我们的功能。</p><p>构造函数指定了读取文件的<code>FILE*</code>指针，以及内部缓冲数组的大小。数组大小由两个参数决定：</p><ul><li>put-back area size</li><li>buffer size</li></ul><p>我们使用<code>std::vector&lt;char></code>做为缓冲区域。<code>put_back_</code>变量用于存储"put-back"区域的大小。</p><p>以下是构造函数的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>size_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FILE_buffer<span style=color:#f92672>::</span>FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, size_t buff_sz, size_t put_back) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    fptr_(fptr),
</span></span><span style=display:flex><span>    put_back_(std<span style=color:#f92672>::</span>max(put_back, size_t(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>    buffer_(std<span style=color:#f92672>::</span>max(buff_sz, put_back_) <span style=color:#f92672>+</span> put_back_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front() <span style=color:#f92672>+</span> buffer_.size();
</span></span><span style=display:flex><span>    setg(end, end, end);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在初始化列表中，我们将缓冲区的常量进行赋值。之后使用<code>std::streambuf::setg()</code>来初始化输出缓冲区。</p><p><code>setg()</code>的三个参数分别代表<code>eback()</code>，<code>gptr()</code>，<code>egptr()</code>三个内部指针的值。一开始，我们将它们都指向同一个地址。表明buffer是空的，在下一次读取时，会重新填充缓冲区。</p><p><code>underflow()</code>会返回数据源中当前的字符。一般来说，会返回buffer中的下一个可用字符。然后当buffer为空时，<code>underflow()</code>应该重新填充缓冲区数组，在本例中，即从<code>FILE*</code>中读取字符。当缓冲区重填后，我们需要再次调用<code>setg()</code>更新流缓冲区的状态。</p><p>当数据源中的数据读完(depleted)后，<code>underflow()</code>会返回一个<code>traits_type::eof()</code>。这里要注意，<code>underflow()</code>的返回值是<code>int_type</code>，这个值足够装下<code>eof()</code>，同时也足够装下任何的字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streambuf<span style=color:#f92672>::</span>int_type FILE_buffer<span style=color:#f92672>::</span>underflow()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (gptr() <span style=color:#f92672>&lt;</span> egptr()) <span style=color:#75715e>// buffer not exhausted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> base;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (eback() <span style=color:#f92672>==</span> base) <span style=color:#75715e>// true when this isn&#39;t the first fill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Make arrangements for putback characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>memmove(base, egptr() <span style=color:#f92672>-</span> put_back_, put_back_);
</span></span><span style=display:flex><span>        start <span style=color:#f92672>+=</span> put_back_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// start is now the start of the buffer, proper.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Read from fptr_ in to the provided buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t n <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>fread(start, <span style=color:#ae81ff>1</span>, buffer_.size() <span style=color:#f92672>-</span> (start <span style=color:#f92672>-</span> base), fptr_);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set buffer pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    setg(base, start, start <span style=color:#f92672>+</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数的第一行，首先判断buffer是否耗尽。如果否，则返回当前字符，即<code>*gptr()</code>。如果是，则进行重填(re-fill)操作。</p><p>回想一下我们在构造函数中的实现，三个状态指针全都指向缓冲区的末尾。如果我们调用<code>underflow()</code>时，发现状态指针并非如此，则说明缓冲区已经被填充了至少一次。</p><p>现在我们考虑重填操作，我们<code>memmove</code>最后<code>put_back_</code>个字符到buffer的末尾，用做"put-back area"。（我们不用<code>memcopy</code>因为我们的buffer比较小，`memmove()的效率会更高一些）</p><blockquote><p>译注：实际上，<code>memcopy</code>与<code>memmove</code>各有所长。<code>memcopy</code>不需要判断内存overlap的情况，即如果源区间与目标区间有重叠，那么得到的结果会是错的。而<code>memmove</code>由于是移动语义，所以在移动步长较小时，可以只操作cache。所以二者各有所长，要根据具体情况判断优劣。Stackoverflow上有更详细的<a href=http://stackoverflow.com/questions/28623895/why-is-memmove-faster-than-memcpy>讨论</a></p></blockquote><p>我们处理完"put-back area"之后，就可以使用<code>fread()</code>函数来重填缓冲区了。如果读不到数据，则意味着文件已经读到了结尾（当然这是一种简化情况，但在现实中99.9%的读取失败都是因为文件结束）。</p><p>在<code>fread()</code>成功读取数据之后，我们通知streambuf更新内部的三个状态指针。之后返回buffer当前的指针。</p><p>这就是我们的流缓冲区的基本实现，希望这并不是太难。当然我们还可以添加更多的功能。特别的是我们可以在缓冲区里面进行查找。如果你想实现它的话，可以试试重写<code>std::streambuf::seekoff()</code>和<code>std::streambuf::seekpos</code>虚成员函数。</p><p>我们也可以实现写缓冲区。不过，在你们读完第三个例子之后，你们就可以轻松愉快的实现自己的版本了，不骗你。</p><h3 id=例2读取内存中的数组>例2：读取内存中的数组<a hidden class=anchor aria-hidden=true href=#例2读取内存中的数组>#</a></h3><p>本例中，我们要使用<code>std::istream</code>包装内存中的一个只读数组，并且格式化的进行读入。这个例子和上一个例子有一点不同的是，我们并不需要一个真正的缓冲数组，从源数组一次性读取就好了。</p><p>想象中的实现是这个样式儿的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            setg(begin, begin, end);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>underflow</span>()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>  gptr() <span style=color:#f92672>==</span> egptr() <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>但是，这并没有什么卵用。因为<code>setg()</code>函数只接受非常量(non-const)指针参数。这显而易见，如果一个缓冲区不可写，我们就不能提供"put-back"功能。所以我们要动一动手脚，重新实现一下这个类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>char_array_buffer</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type underflow();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>uflow</span>();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>pbackfail</span>(int_type ch);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>streamsize showmanyc();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        char_array_buffer(<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        char_array_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> begin_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> end_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> current_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在这个版本中，我们重写了几个私有函数，这些函数都是从<code>std::streambuf</code>继承而来。</p><p>第一个构造函数需要用户指定起止指针，而第二个构造函数只需要指定起始指针，之后我们会调用<code>std::strlen()</code>来判断字符串的大小。</p><p>我们使用<code>uflow()</code>, <code>pbackfail()</code>和<code>showmanyc()</code>来维护缓冲区内部的状态，而不是调用<code>setg()</code>，因为buffer并不可写。</p><p>在这个版本中，我们要手动维护<code>eback</code>, <code>gptr</code>, <code>egptr</code>三个指针。在构造函数中，我们将对其进行赋值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;char_array_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(begin),
</span></span><span style=display:flex><span>    end_(end),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(begin_, end_));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(str),
</span></span><span style=display:flex><span>    end_(begin_ <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>strlen(str)),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>之前我们使用<code>underflow()</code>来获取当前字符，但这次我们需要使用<code>uflow()</code>。因为<code>uflow()</code>需要同时执行两步操作，一是获取当前字符，二是让<code>gptr()</code>前进一步。但是又因为缓冲区由我们手动管理，<code>std::streambuf</code>并不能正确的执行管理操作。所以我们需要重写<code>uflow()</code>而不是<code>underflow()</code>。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 440 121"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="0" y="20" fill="currentcolor" style="font-size:1em">{</text><text text-anchor="middle" x="0" y="100" fill="currentcolor" style="font-size:1em">}</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="32" y="36" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="32" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="40" y="36" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="40" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="48" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="56" y="36" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="56" y="84" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="64" y="36" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="64" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="72" y="36" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="72" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="80" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="88" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="88" y="52" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="88" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="96" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="96" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="96" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="104" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="104" y="52" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="104" y="84" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="112" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="112" y="84" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="120" y="36" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="120" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="120" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="128" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="128" y="84" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="136" y="52" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="136" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="144" y="52" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="144" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="152" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="84" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="52" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="160" y="84" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="168" y="52" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="168" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="176" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="176" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="184" y="52" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="184" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="192" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="192" y="52" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="192" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="200" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="84" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="208" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="208" y="52" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="208" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="216" y="52" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="216" y="84" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="224" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="224" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="232" y="52" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="232" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="240" y="52" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="240" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="248" y="52" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="248" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="256" y="52" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="256" y="84" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="264" y="52" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="264" y="84" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="272" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="280" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="280" y="84" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="288" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="288" y="84" fill="currentcolor" style="font-size:1em">*</text><text text-anchor="middle" x="296" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="296" y="84" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="304" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="304" y="84" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="312" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="320" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="320" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="328" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="328" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="336" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="336" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="344" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="344" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="352" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="352" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="360" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="360" y="84" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="368" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="368" y="84" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="376" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="376" y="84" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="384" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="384" y="84" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="392" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="400" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="408" y="4" fill="currentcolor" style="font-size:1em">w</text><text text-anchor="middle" x="416" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="424" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>下一步我们还要实现<code>pbackfail()</code>。当我们调用<code>std::istream::unget()</code>或<code>std::istream::putback(ch)</code>时，我们会把已经读出的数据写回数组中。但是由于数组是只读的，所以我们只能模拟这种操作。</p><p>在默认的实现中<code>pbackfail()</code>只会返回<code>traits_type::eof()</code>，而在我们的版本中，如果写回成功，将会返回写回的字符，不成功返回eof。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>int_type char_array_buffer<span style=color:#f92672>::</span>pbackfail(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (current_ <span style=color:#f92672>==</span> begin_ <span style=color:#f92672>||</span> (ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> current_[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*--</span>current_);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>FILE_buffer</code>中，我们也可以考虑重写<code>pbackfail()</code>，来提供反向查找以及（用前面的数据）重填buffer的功能。</p><p>最后一个重写的函数是<code>showmanyc()</code>，这个函数被<code>std::streambuf::in_avail()</code>调用，以判断当前有多少个字符可以返回。由于我们接管了状态指针，所以这个函数也要我们自己来实现啊。（译者：为什么要给自己找麻烦。。。）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streamsize char_array_buffer<span style=color:#f92672>::</span>showmanyc()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(current_, end_));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> end_ <span style=color:#f92672>-</span> current_;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由此可见，本例中的buffer比前面的要复杂一点点。这是因为我们接管了状态维护的工作。这使得我们更好的理解了<code>std::streambuf</code>内部是如何工作的。</p><h3 id=例3句首变大写的缓冲区>例3：句首变大写的缓冲区<a hidden class=anchor aria-hidden=true href=#例3句首变大写的缓冲区>#</a></h3><p>本例中我们将要实现一个将句首字符变大写的buffer。当然我们只考虑最基本的情况，移植到不同的区域和语言，其实是很琐碎的事情。（译者：文字编码坑的亲妈都不认了）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iosfwd&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>caps_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> do_caps_and_flush();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type overflow(int_type ch);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        caps_buffer(<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        caps_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> cap_next_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这里我们需要重写<code>overflow()</code>和<code>sync()</code>函数。<code>overflow()</code>在输入缓冲区满的时候被调用，并且在成功时返回任意非eof的值。</p><p><code>sync()</code>的作用是把当前的buffer写入目标，即使当前buffer并未填满。<code>std::flush()</code>会调用<code>sync()</code>函数，当失败时返回-1。</p><p>我们编写一个辅助函数<code>do_caps_and_flush()</code>，用来将小写变大写，并写入<code>sink_</code>输出流。我们再声明一个哨兵变量<code>cap_next_</code>来标识下一个字符是否需要小写变大写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;caps_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cctype&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    cap_next_(true),
</span></span><span style=display:flex><span>    sink_(sink),
</span></span><span style=display:flex><span>    buffer_(buff_sz <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sink_.clear();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    setp(base, base <span style=color:#f92672>+</span> buffer_.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// -1 to make overflow() easier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>buffer_</code>的最小可能大小是1，同时我们也只需要维护两个指针，因为这里不需要像输入缓冲区一样的维护"put-back area"。</p><p>我们把<code>buffer_</code>的大小设成<code>buff_sz + 1</code>，这样是为了<code>overflow()</code>被调用时，我们有一个额外的空间存储当前的字符。最后将缓冲区数组和最后一个字符一起刷新到<code>ostream</code>中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>int_type caps_buffer<span style=color:#f92672>::</span>overflow(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sink_ <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(pptr(), epptr()));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>pptr() <span style=color:#f92672>=</span> ch;
</span></span><span style=display:flex><span>        pbump(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (do_caps_and_flush())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ch;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一步是把ch写入<code>buffer_</code>，并且使用<code>pbump(1)</code>将<code>pptr()</code>向前移一位。之后调用<code>do_caps_and_flush()</code>做一些脏活，之后返回一个字符声明调用成功。</p><p><code>sync()</code>的实现也非常简单:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> caps_buffer<span style=color:#f92672>::</span>sync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>do_caps_and_flush</span>() <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们再看一看<code>do_caps_and_flush()</code>函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> caps_buffer<span style=color:#f92672>::</span>do_caps_and_flush()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> pbase(), <span style=color:#f92672>*</span>e <span style=color:#f92672>=</span> pptr(); p <span style=color:#f92672>!=</span> e; <span style=color:#f92672>++</span>p)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>p <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (std<span style=color:#f92672>::</span>isalpha(<span style=color:#f92672>*</span>p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cap_next_)
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>toupper(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ptrdiff_t n <span style=color:#f92672>=</span> pptr() <span style=color:#f92672>-</span> pbase();
</span></span><span style=display:flex><span>    pbump(<span style=color:#f92672>-</span>n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sink_.write(pbase(), n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于本例来说，内部的缓冲区并非必要，我们可以一个字符一个字符把数据发到<code>sink</code>中。但是我的观点是一个内部buffer仍有其用处。</p><h3 id=介绍-boost-iostreams-库>介绍 Boost IOStreams 库<a hidden class=anchor aria-hidden=true href=#介绍-boost-iostreams-库>#</a></h3><p>如果你是流缓冲区的新手，希望你已经对它有一点点了解了。本文中的例子都非常基础，但是你可以用它们做更多有意思的事情。但是当我实现更复杂的流缓冲区时，问题的复杂度却上升的很快。这时我发现了<code>Boost IOStreams</code>库，它为更复杂的缓冲区和流提供了必要的框架支持。</p><p>它允许你解耦数据源，数据输出，过滤器以及其它一些概念。在我们的最后一个例子中，我们硬编码数据输出到<code>std::ostream</code>中。如果我们要输出到一个没有流接口的类呢？<code>Boost IOStreams</code>库提供了更多的灵活性，将一坨紧耦合的代码分解成独立的抽象概念。</p><h3 id=扩展阅读>扩展阅读<a hidden class=anchor aria-hidden=true href=#扩展阅读>#</a></h3><ul><li>The C++ Standard Library by Nicolai M. Josuttis</li><li>The C++ Standard, BS ISO/IEC 14882:2003 (Second Edition)</li><li><a href=http://www.dinkumware.com/manuals/>Dinkum Compleat Reference online</a></li></ul></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=https://wizmann.top/posts/paxos-raft-pecifica2/><span class=title>«</span><br><span></span>
</a><a class=next href=https://wizmann.top/posts/phxrpc-2/><span class=title>»</span><br><span></span></a></nav></footer><div id=disqus_thread></div><script>(function(){var e=document,t=e.createElement("script");t.src="https://wizmann.disqus.com/embed.js",t.setAttribute("data-timestamp",+new Date),(e.head||e.body).appendChild(t)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>