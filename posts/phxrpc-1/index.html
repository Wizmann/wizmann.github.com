<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=Content-Security-Policy content="script-src 'self'; style-src 'self' 'unsafe-inline'; object-src 'none'; base-uri 'none'"><link rel=stylesheet href=/css/style.feedcd92d05c2cf19ee7487656b358ee4805f831b7b39711851199d0a6f8934cf9ba379d02425d485c5b65ae299bdffda3770739545d595074076bf3ead284ab.css media=screen integrity="sha512-/u3NktBcLPGe50h2VrNY7kgF+DG3s5cRhRGZ0Kb4k0z5ujedAkJdSFxbZa4pm9/9o3cHOVRdWVB0B2vz6tKEqw==" crossorigin=anonymous><title>自定义你的stream buffer - phxrpc阅读笔记(1)</title>
<meta name=description content="写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。
"><link rel=canonical href=https://wizmann.top/posts/phxrpc-1/><link rel=alternate hreflang=zh-CN href=https://wizmann.top/posts/phxrpc-1/><link rel=alternate hreflang=x-default href=https://wizmann.top/posts/phxrpc-1/><meta property="og:title" content="自定义你的stream buffer - phxrpc阅读笔记(1)"><meta property="og:description" content="写在前面
phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。"><meta property="og:type" content="article"><meta property="og:url" content="https://wizmann.top/posts/phxrpc-1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-28T22:35:55+00:00"><meta property="article:modified_time" content="2016-09-28T22:35:55+00:00"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta name=twitter:card content="summary"><meta name=twitter:title content="自定义你的stream buffer - phxrpc阅读笔记(1)"><meta name=twitter:description content="写在前面
phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"自定义你的stream buffer - phxrpc阅读笔记(1)","datePublished":"2016-09-28T22:35:55+00:00","dateModified":"2016-09-28T22:35:55+00:00","mainEntityOfPage":"https://wizmann.top/","publisher":{"@type":"Organization","name":"Maerlyn's Rainbow"},"wordcount":6467,"description":"写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。\n我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。\n","keywords":null}</script></head><body class="posts single d-flex flex-column min-vh-100"><header class=main-header><nav class="navbar navbar-expand-lg"><div class=container><a class=navbar-brand href=/>Maerlyn's Rainbow
</a><button class=navbar-toggler type=button data-bs-toggle=collapse data-bs-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="collapse navbar-collapse" id=navbarSupportedContent><ul class="menu-main navbar-nav me-auto mb-2 mb-lg-0"></ul></div></div></nav></header><div id=content><div class="container py-3"><h2 id=写在前面>写在前面</h2><p><a href=https://github.com/tencent-wechat/phxrpc target=_blank rel=noopener>phxrpc</a>是微信团队开源的一个轻量级RPC框架。</p><p>我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。</p><p>就是这样。</p><h2 id=自定义stream-buffer>自定义stream buffer</h2><p><code>network/socket_stream_base.[h|cpp]</code>中的<code>class BaseTcpStreamBuf</code>继承了<code>std::streambuf</code>，自定义了一个流缓冲区，用于接收/发送TCP数据包。</p><p>这个用法比较新颖（或者是我见识少），网上的资料也不多。这里翻译一篇<a href=http://www.mr-edd.co.uk/blog/beginners_guide_streambuf target=_blank rel=noopener>介绍文章</a>，学习一下新姿势。</p><h2 id=a-beginners-guide-to-writing-a-custom-stream-buffer>A beginner&rsquo;s guide to writing a custom stream buffer</h2><p>流(streams)是STL中提供的一个重要的抽象概念。著名的“Hello world”程序，便是使用了std::cout将字符串写入标准输出流(stdout)。</p><p>流当然可以做比cin/cout更有意思的事。这篇文章我们会研究如何扩展C++流，来实现自定义的流缓冲区(stream buffer)。p.s. 建议本文的读者至少要有基础的C++知识。</p><p>C++标准库为磁盘文件操作提供了基础的接口，如<code>std::fstream</code>，<code>std::ifstream</code>和<code>std::ofstream</code>。我们还有<code>stringstream</code>，可以像流一样操作字符串。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;Hello, world!</span><span style=color:#ae81ff>\\</span><span style=color:#e6db74>n&#34;</span>;
</span></span><span style=display:flex><span>oss <span style=color:#f92672>&lt;&lt;</span> <span style=color:#ae81ff>123</span> <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>std<span style=color:#f92672>::</span>string s <span style=color:#f92672>=</span> oss.str();
</span></span></code></pre></div><p>相似的，我们可以从<code>std::istringstream</code>中使用<code>>></code>操作符读取数据。</p><p>Boost库中的<code>lexical_cast</code>正是使用了这种机制，让用户可以使用统一的方式将一个对象(object)转换为字符串表示。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> boost<span style=color:#f92672>::</span>lexical_cast;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>string;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> x <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>;
</span></span><span style=display:flex><span>string s <span style=color:#f92672>=</span> lexical_cast<span style=color:#f92672>&lt;</span>string<span style=color:#f92672>&gt;</span>(x);
</span></span><span style=display:flex><span>assert(s <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;5&#34;</span>);
</span></span></code></pre></div><p>流缓冲区有着很强的灵活性，可以满足不同的“缓冲并传输字符（串）”需求，比如文件操作、字符串操作、命令行(Console)操作等。我们可以从网络、闪存(Flash memory)等不同设备，使用同样的接口获取流式字符串。“流缓冲区”与“流”是正交的，所以我们可以自由的交换、更改(swap and change)流所使用的缓冲区，或者将其重定向到其它地方。我认为C++中的流，正是“策略模式”(strategy design pattern)的一个良好范例。</p><p>比如，我们可以重定向标准日志流<code>std::clog</code>到一个字符串流：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iomanip&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;string&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;sstream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ostringstream oss;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Make clog use the buffer from oss
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>streambuf <span style=color:#f92672>*</span>former_buff <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>clog.rdbuf(oss.rdbuf());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>clog <span style=color:#f92672>&lt;&lt;</span> <span style=color:#e6db74>&#34;This will appear in oss!&#34;</span> <span style=color:#f92672>&lt;&lt;</span> std<span style=color:#f92672>::</span>flush;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>cout <span style=color:#f92672>&lt;&lt;</span> oss.str() <span style=color:#f92672>&lt;&lt;</span> <span style=color:#960050;background-color:#1e0010>&#39;\\</span>n<span style=color:#960050;background-color:#1e0010>&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Give clog back its previous buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    std<span style=color:#f92672>::</span>clog.rdbuf(former_buff);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>不过，自定义一个流缓冲区却是有一点tricky，或者说有一点吓人，尤其是当你第一次尝试的时候。所以本文意在提供一些流缓冲的实现范例。</p><p>首先我们来看一下流缓冲区的一些基本概念。所有的流缓冲区继承自<code>std::streambuf</code>，并且需要覆盖一些虚函数来实现自定义功能。<code>std::streambuf</code>是“顺序读取设备”的一个抽象，即我们可以从中顺序的读取字符序列。在特定的场景下，我们可以重填(re-fill)、冲洗(flush)以及清空(empty)一个缓冲区。</p><p>当我们向一个<code>ostream</code>中插入数据时，数据将会被写入缓冲区中的一个数组。当数组上溢(overflow)时，数组中的数据将会被冲洗(flush)到目标接受者，之后这个数组的状态将会重置，以便存储后续的字符。</p><p>当我们从一个<code>istream</code>中获取数据时，数据从缓冲区的数组中读出。当数组下溢时(underflow)，没有数据可读，我们会从数据源重新拉取信息来填充缓冲区，之后这个数组的状态也将被重置。</p><p>我们使用6个指针，来维护缓冲区的内部状态。输入和输出缓冲各使用3个指针。</p><h3 id=维护输出缓冲区的状态>维护输出缓冲区的状态</h3><ul><li><p>put base pointer<br>输出基指针，用来指定缓冲区内部数组的第一个元素。可以使用<code>std::streambuf::pbase()</code>来获取</p></li><li><p>put pointer<br>输出指针，用来指向内部数组下一个写入的地址。可以使用<code>std::streambuf::pptr()</code>来获取</p></li><li><p>end put pointer<br>输出哨兵指针，指向内部数组最后一个再后面一个(one-past-the-last-element)的地址（译注：类似<code>std::vector::end()</code>）。可以使用<code>std::streambuf:epptr()</code>来获取</p></li></ul><p><img src=http://i1.piimg.com/567571/630a89fe635e1635.png alt></p><p>一般来说，基指针和哨兵指针不会改变，在使用时，以输出指针维护内部状态。</p><h3 id=维护输入缓冲区的状态>维护输入缓冲区的状态</h3><p>输入缓冲区和状态维护和输出缓冲区类似，我们有：</p><ul><li>end back pointer<br>输入基指针，指向缓冲区数组内的最后一个字符。可以使用<code>std::streambuf::eback()</code>来获取</li><li>get pointer<br>输入指针，指向缓冲区下一个读取的字符地址。可以使用<code>std::streambuf::gptr()</code>来获取</li><li>end get pointer<br>输入哨兵指针，批号向内部数组最后一个再后面一个(one-past-the-last-element)的地址。可以使用<code>std::streambuf::egptr()</code>来获取</li></ul><p><img src=https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-9-27/33500590.jpg alt></p><p>同样，基指针和哨兵指针在流缓冲区的生命周期中也不会改变。</p><p>由于输入缓冲区要支持<code>putback()</code>操作，即将读出的字符重新放回缓冲区，所以输入缓冲区比输出缓冲区更复杂一点。通常来说，<code>putback()</code>操作支持放回一个字符即可。</p><p>一个<code>std::streambuf</code>可以同时支持输入输出两种操作，所以我们不需要我分别实现<code>std::istreambuf</code>和<code>std::ostreambuf</code>。<code>std::fstream</code>是一个良好的例子。但是，实现一个全功能的缓冲区相对更复杂一些，所以我就不趟浑水啦~ ：）</p><p>同时，流缓冲区也可以支持宽字符(wide character)。<code>std::streambuf</code>是<code>std::basic_streambuf&lt;char></code>的别名，如果你需要宽字符流缓冲区，可以使用<code>std::basic_streambuf&lt;wchar_t></code>。</p><h3 id=例1文件缓冲区--与c代码集成>例1：文件缓冲区 —— 与C代码集成</h3><p>假设我们需要调用一个历史悠久的库，一个文件操作函数会返回给一个<code>FILE*</code>指针，但是我们想用C++的流接口来读写数据。我们先从读文件开始，用<code>std::istream</code>包装<code>FILE*</code>的读操作。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdio&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FILE_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>, std<span style=color:#f92672>::</span>size_t put_back <span style=color:#f92672>=</span> <span style=color:#ae81ff>8</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// overrides base class underflow()
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        int_type underflow();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        FILE_buffer(<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        FILE_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> FILE_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        FILE <span style=color:#f92672>*</span>fptr_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>size_t put_back_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>由于功能简单，我们只需要实现构造函数以及<code>underflow</code>接口就可以实现我们的功能。</p><p>构造函数指定了读取文件的<code>FILE*</code>指针，以及内部缓冲数组的大小。数组大小由两个参数决定：</p><ul><li>put-back area size</li><li>buffer size</li></ul><p>我们使用<code>std::vector&lt;char></code>做为缓冲区域。<code>put_back_</code>变量用于存储"put-back"区域的大小。</p><p>以下是构造函数的实现：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>using</span> std<span style=color:#f92672>::</span>size_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>FILE_buffer<span style=color:#f92672>::</span>FILE_buffer(FILE <span style=color:#f92672>*</span>fptr, size_t buff_sz, size_t put_back) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    fptr_(fptr),
</span></span><span style=display:flex><span>    put_back_(std<span style=color:#f92672>::</span>max(put_back, size_t(<span style=color:#ae81ff>1</span>))),
</span></span><span style=display:flex><span>    buffer_(std<span style=color:#f92672>::</span>max(buff_sz, put_back_) <span style=color:#f92672>+</span> put_back_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front() <span style=color:#f92672>+</span> buffer_.size();
</span></span><span style=display:flex><span>    setg(end, end, end);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在初始化列表中，我们将缓冲区的常量进行赋值。之后使用<code>std::streambuf::setg()</code>来初始化输出缓冲区。</p><p><code>setg()</code>的三个参数分别代表<code>eback()</code>，<code>gptr()</code>，<code>egptr()</code>三个内部指针的值。一开始，我们将它们都指向同一个地址。表明buffer是空的，在下一次读取时，会重新填充缓冲区。</p><p><code>underflow()</code>会返回数据源中当前的字符。一般来说，会返回buffer中的下一个可用字符。然后当buffer为空时，<code>underflow()</code>应该重新填充缓冲区数组，在本例中，即从<code>FILE*</code>中读取字符。当缓冲区重填后，我们需要再次调用<code>setg()</code>更新流缓冲区的状态。</p><p>当数据源中的数据读完(depleted)后，<code>underflow()</code>会返回一个<code>traits_type::eof()</code>。这里要注意，<code>underflow()</code>的返回值是<code>int_type</code>，这个值足够装下<code>eof()</code>，同时也足够装下任何的字符。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streambuf<span style=color:#f92672>::</span>int_type FILE_buffer<span style=color:#f92672>::</span>underflow()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (gptr() <span style=color:#f92672>&lt;</span> egptr()) <span style=color:#75715e>// buffer not exhausted
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>start <span style=color:#f92672>=</span> base;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (eback() <span style=color:#f92672>==</span> base) <span style=color:#75715e>// true when this isn&#39;t the first fill
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Make arrangements for putback characters
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        std<span style=color:#f92672>::</span>memmove(base, egptr() <span style=color:#f92672>-</span> put_back_, put_back_);
</span></span><span style=display:flex><span>        start <span style=color:#f92672>+=</span> put_back_;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// start is now the start of the buffer, proper.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// Read from fptr_ in to the provided buffer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    size_t n <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>fread(start, <span style=color:#ae81ff>1</span>, buffer_.size() <span style=color:#f92672>-</span> (start <span style=color:#f92672>-</span> base), fptr_);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (n <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Set buffer pointers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    setg(base, start, start <span style=color:#f92672>+</span> n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>函数的第一行，首先判断buffer是否耗尽。如果否，则返回当前字符，即<code>*gptr()</code>。如果是，则进行重填(re-fill)操作。</p><p>回想一下我们在构造函数中的实现，三个状态指针全都指向缓冲区的末尾。如果我们调用<code>underflow()</code>时，发现状态指针并非如此，则说明缓冲区已经被填充了至少一次。</p><p>现在我们考虑重填操作，我们<code>memmove</code>最后<code>put_back_</code>个字符到buffer的末尾，用做"put-back area"。（我们不用<code>memcopy</code>因为我们的buffer比较小，`memmove()的效率会更高一些）</p><blockquote><p>译注：实际上，<code>memcopy</code>与<code>memmove</code>各有所长。<code>memcopy</code>不需要判断内存overlap的情况，即如果源区间与目标区间有重叠，那么得到的结果会是错的。而<code>memmove</code>由于是移动语义，所以在移动步长较小时，可以只操作cache。所以二者各有所长，要根据具体情况判断优劣。Stackoverflow上有更详细的<a href=http://stackoverflow.com/questions/28623895/why-is-memmove-faster-than-memcpy target=_blank rel=noopener>讨论</a></p></blockquote><p>我们处理完"put-back area"之后，就可以使用<code>fread()</code>函数来重填缓冲区了。如果读不到数据，则意味着文件已经读到了结尾（当然这是一种简化情况，但在现实中99.9%的读取失败都是因为文件结束）。</p><p>在<code>fread()</code>成功读取数据之后，我们通知streambuf更新内部的三个状态指针。之后返回buffer当前的指针。</p><p>这就是我们的流缓冲区的基本实现，希望这并不是太难。当然我们还可以添加更多的功能。特别的是我们可以在缓冲区里面进行查找。如果你想实现它的话，可以试试重写<code>std::streambuf::seekoff()</code>和<code>std::streambuf::seekpos</code>虚成员函数。</p><p>我们也可以实现写缓冲区。不过，在你们读完第三个例子之后，你们就可以轻松愉快的实现自己的版本了，不骗你。</p><h3 id=例2读取内存中的数组>例2：读取内存中的数组</h3><p>本例中，我们要使用<code>std::istream</code>包装内存中的一个只读数组，并且格式化的进行读入。这个例子和上一个例子有一点不同的是，我们并不需要一个真正的缓冲数组，从源数组一次性读取就好了。</p><p>想象中的实现是这个样式儿的：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            setg(begin, begin, end);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>underflow</span>()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span>  gptr() <span style=color:#f92672>==</span> egptr() <span style=color:#f92672>?</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>                    traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*</span>gptr());
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>但是，这并没有什么卵用。因为<code>setg()</code>函数只接受非常量(non-const)指针参数。这显而易见，如果一个缓冲区不可写，我们就不能提供"put-back"功能。所以我们要动一动手脚，重新实现一下这个类。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>char_array_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> <span style=color:#a6e22e>char_array_buffer</span>(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type underflow();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>uflow</span>();
</span></span><span style=display:flex><span>        int_type <span style=color:#a6e22e>pbackfail</span>(int_type ch);
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>streamsize showmanyc();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        char_array_buffer(<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        char_array_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> char_array_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> begin_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> <span style=color:#66d9ef>const</span> end_;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span> current_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>在这个版本中，我们重写了几个私有函数，这些函数都是从<code>std::streambuf</code>继承而来。</p><p>第一个构造函数需要用户指定起止指针，而第二个构造函数只需要指定起始指针，之后我们会调用<code>std::strlen()</code>来判断字符串的大小。</p><p>我们使用<code>uflow()</code>, <code>pbackfail()</code>和<code>showmanyc()</code>来维护缓冲区内部的状态，而不是调用<code>setg()</code>，因为buffer并不可写。</p><p>在这个版本中，我们要手动维护<code>eback</code>, <code>gptr</code>, <code>egptr</code>三个指针。在构造函数中，我们将对其进行赋值。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;char_array_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstring&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>begin, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>end) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(begin),
</span></span><span style=display:flex><span>    end_(end),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(begin_, end_));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>char_array_buffer(<span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>str) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    begin_(str),
</span></span><span style=display:flex><span>    end_(begin_ <span style=color:#f92672>+</span> std<span style=color:#f92672>::</span>strlen(str)),
</span></span><span style=display:flex><span>    current_(begin_)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>之前我们使用<code>underflow()</code>来获取当前字符，但这次我们需要使用<code>uflow()</code>。因为<code>uflow()</code>需要同时执行两步操作，一是获取当前字符，二是让<code>gptr()</code>前进一步。但是又因为缓冲区由我们手动管理，<code>std::streambuf</code>并不能正确的执行管理操作。所以我们需要重写<code>uflow()</code>而不是<code>underflow()</code>。</p><div class="goat svg-container"><svg font-family="Menlo,Lucida Console,monospace" viewBox="0 0 440 121"><g transform="translate(8,16)"><text text-anchor="middle" x="0" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="0" y="20" fill="currentcolor" style="font-size:1em">{</text><text text-anchor="middle" x="0" y="100" fill="currentcolor" style="font-size:1em">}</text><text text-anchor="middle" x="8" y="4" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="16" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="24" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="32" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="32" y="36" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="32" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="40" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="40" y="36" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="40" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="48" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="48" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="56" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="56" y="36" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="56" y="84" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="64" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="64" y="36" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="64" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="64" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="72" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="72" y="36" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="72" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="72" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="80" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="80" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="80" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="88" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="88" y="36" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="88" y="52" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="88" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="96" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="96" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="96" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="96" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="104" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="104" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="104" y="52" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="104" y="84" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="112" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="112" y="36" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="112" y="84" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="120" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="120" y="36" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="120" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="120" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="128" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="128" y="52" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="128" y="84" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="136" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="136" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="136" y="52" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="136" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="144" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="144" y="36" fill="currentcolor" style="font-size:1em">=</text><text text-anchor="middle" x="144" y="52" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="144" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="4" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="152" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="152" y="84" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="160" y="4" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="160" y="36" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="160" y="52" fill="currentcolor" style="font-size:1em">s</text><text text-anchor="middle" x="160" y="84" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="168" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="168" y="36" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="168" y="52" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="168" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="176" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="176" y="36" fill="currentcolor" style="font-size:1em">d</text><text text-anchor="middle" x="176" y="52" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="176" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="184" y="4" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="184" y="36" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="184" y="52" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="184" y="84" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="192" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="192" y="36" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="192" y="52" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="192" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="200" y="4" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="200" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="200" y="84" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="208" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="208" y="52" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="208" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="216" y="52" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="216" y="84" fill="currentcolor" style="font-size:1em">i</text><text text-anchor="middle" x="224" y="4" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="224" y="52" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="224" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="232" y="4" fill="currentcolor" style="font-size:1em">h</text><text text-anchor="middle" x="232" y="52" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="232" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="240" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="240" y="52" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="240" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="248" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="248" y="52" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="248" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="256" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="256" y="52" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="256" y="84" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="264" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="264" y="52" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="264" y="84" fill="currentcolor" style="font-size:1em">p</text><text text-anchor="middle" x="272" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="272" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="280" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="280" y="84" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="288" y="4" fill="currentcolor" style="font-size:1em">a</text><text text-anchor="middle" x="288" y="84" fill="currentcolor" style="font-size:1em">*</text><text text-anchor="middle" x="296" y="4" fill="currentcolor" style="font-size:1em">y</text><text text-anchor="middle" x="296" y="84" fill="currentcolor" style="font-size:1em">c</text><text text-anchor="middle" x="304" y="4" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="304" y="84" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="312" y="4" fill="currentcolor" style="font-size:1em">b</text><text text-anchor="middle" x="312" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="320" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="320" y="84" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="328" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="328" y="84" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="336" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="336" y="84" fill="currentcolor" style="font-size:1em">n</text><text text-anchor="middle" x="344" y="4" fill="currentcolor" style="font-size:1em">e</text><text text-anchor="middle" x="344" y="84" fill="currentcolor" style="font-size:1em">t</text><text text-anchor="middle" x="352" y="4" fill="currentcolor" style="font-size:1em">r</text><text text-anchor="middle" x="352" y="84" fill="currentcolor" style="font-size:1em">_</text><text text-anchor="middle" x="360" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="360" y="84" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="368" y="4" fill="currentcolor" style="font-size:1em">:</text><text text-anchor="middle" x="368" y="84" fill="currentcolor" style="font-size:1em">+</text><text text-anchor="middle" x="376" y="4" fill="currentcolor" style="font-size:1em">u</text><text text-anchor="middle" x="376" y="84" fill="currentcolor" style="font-size:1em">)</text><text text-anchor="middle" x="384" y="4" fill="currentcolor" style="font-size:1em">f</text><text text-anchor="middle" x="384" y="84" fill="currentcolor" style="font-size:1em">;</text><text text-anchor="middle" x="392" y="4" fill="currentcolor" style="font-size:1em">l</text><text text-anchor="middle" x="400" y="4" fill="currentcolor" style="font-size:1em">o</text><text text-anchor="middle" x="408" y="4" fill="currentcolor" style="font-size:1em">w</text><text text-anchor="middle" x="416" y="4" fill="currentcolor" style="font-size:1em">(</text><text text-anchor="middle" x="424" y="4" fill="currentcolor" style="font-size:1em">)</text></g></svg></div><p>下一步我们还要实现<code>pbackfail()</code>。当我们调用<code>std::istream::unget()</code>或<code>std::istream::putback(ch)</code>时，我们会把已经读出的数据写回数组中。但是由于数组是只读的，所以我们只能模拟这种操作。</p><p>在默认的实现中<code>pbackfail()</code>只会返回<code>traits_type::eof()</code>，而在我们的版本中，如果写回成功，将会返回写回的字符，不成功返回eof。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>char_array_buffer<span style=color:#f92672>::</span>int_type char_array_buffer<span style=color:#f92672>::</span>pbackfail(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (current_ <span style=color:#f92672>==</span> begin_ <span style=color:#f92672>||</span> (ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof() <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> current_[<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>to_int_type(<span style=color:#f92672>*--</span>current_);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>在<code>FILE_buffer</code>中，我们也可以考虑重写<code>pbackfail()</code>，来提供反向查找以及（用前面的数据）重填buffer的功能。</p><p>最后一个重写的函数是<code>showmanyc()</code>，这个函数被<code>std::streambuf::in_avail()</code>调用，以判断当前有多少个字符可以返回。由于我们接管了状态指针，所以这个函数也要我们自己来实现啊。（译者：为什么要给自己找麻烦。。。）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>std<span style=color:#f92672>::</span>streamsize char_array_buffer<span style=color:#f92672>::</span>showmanyc()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(current_, end_));
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> end_ <span style=color:#f92672>-</span> current_;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>由此可见，本例中的buffer比前面的要复杂一点点。这是因为我们接管了状态维护的工作。这使得我们更好的理解了<code>std::streambuf</code>内部是如何工作的。</p><h3 id=例3句首变大写的缓冲区>例3：句首变大写的缓冲区</h3><p>本例中我们将要实现一个将句首字符变大写的buffer。当然我们只考虑最基本的情况，移植到不同的区域和语言，其实是很琐碎的事情。（译者：文字编码坑的亲妈都不认了）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;streambuf&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iosfwd&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cstdlib&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;vector&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>caps_buffer</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>streambuf
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>explicit</span> caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz <span style=color:#f92672>=</span> <span style=color:#ae81ff>256</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>protected</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> do_caps_and_flush();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        int_type overflow(int_type ch);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sync</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// copy ctor and assignment not implemented;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#75715e>// copying not allowed
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        caps_buffer(<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>        caps_buffer <span style=color:#f92672>&amp;</span><span style=color:#66d9ef>operator</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>const</span> caps_buffer <span style=color:#f92672>&amp;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>bool</span> cap_next_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink_;
</span></span><span style=display:flex><span>        std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span><span style=color:#f92672>&gt;</span> buffer_;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>这里我们需要重写<code>overflow()</code>和<code>sync()</code>函数。<code>overflow()</code>在输入缓冲区满的时候被调用，并且在成功时返回任意非eof的值。</p><p><code>sync()</code>的作用是把当前的buffer写入目标，即使当前buffer并未填满。<code>std::flush()</code>会调用<code>sync()</code>函数，当失败时返回-1。</p><p>我们编写一个辅助函数<code>do_caps_and_flush()</code>，用来将小写变大写，并写入<code>sink_</code>输出流。我们再声明一个哨兵变量<code>cap_next_</code>来标识下一个字符是否需要小写变大写。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;caps_buffer.hpp&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cctype&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;functional&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;cassert&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>caps_buffer(std<span style=color:#f92672>::</span>ostream <span style=color:#f92672>&amp;</span>sink, std<span style=color:#f92672>::</span>size_t buff_sz) <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>    cap_next_(true),
</span></span><span style=display:flex><span>    sink_(sink),
</span></span><span style=display:flex><span>    buffer_(buff_sz <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    sink_.clear();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>base <span style=color:#f92672>=</span> <span style=color:#f92672>&amp;</span>buffer_.front();
</span></span><span style=display:flex><span>    setp(base, base <span style=color:#f92672>+</span> buffer_.size() <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>); <span style=color:#75715e>// -1 to make overflow() easier
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p><code>buffer_</code>的最小可能大小是1，同时我们也只需要维护两个指针，因为这里不需要像输入缓冲区一样的维护"put-back area"。</p><p>我们把<code>buffer_</code>的大小设成<code>buff_sz + 1</code>，这样是为了<code>overflow()</code>被调用时，我们有一个额外的空间存储当前的字符。最后将缓冲区数组和最后一个字符一起刷新到<code>ostream</code>中。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>caps_buffer<span style=color:#f92672>::</span>int_type caps_buffer<span style=color:#f92672>::</span>overflow(int_type ch)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (sink_ <span style=color:#f92672>&amp;&amp;</span> ch <span style=color:#f92672>!=</span> traits_type<span style=color:#f92672>::</span>eof())
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        assert(std<span style=color:#f92672>::</span>less_equal<span style=color:#f92672>&lt;</span><span style=color:#66d9ef>char</span> <span style=color:#f92672>*&gt;</span>()(pptr(), epptr()));
</span></span><span style=display:flex><span>        <span style=color:#f92672>*</span>pptr() <span style=color:#f92672>=</span> ch;
</span></span><span style=display:flex><span>        pbump(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (do_caps_and_flush())
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> ch;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> traits_type<span style=color:#f92672>::</span>eof();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>第一步是把ch写入<code>buffer_</code>，并且使用<code>pbump(1)</code>将<code>pptr()</code>向前移一位。之后调用<code>do_caps_and_flush()</code>做一些脏活，之后返回一个字符声明调用成功。</p><p><code>sync()</code>的实现也非常简单:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>int</span> caps_buffer<span style=color:#f92672>::</span>sync()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>do_caps_and_flush</span>() <span style=color:#f92672>?</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>:</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>我们再看一看<code>do_caps_and_flush()</code>函数</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>bool</span> caps_buffer<span style=color:#f92672>::</span>do_caps_and_flush()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> pbase(), <span style=color:#f92672>*</span>e <span style=color:#f92672>=</span> pptr(); p <span style=color:#f92672>!=</span> e; <span style=color:#f92672>++</span>p)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (<span style=color:#f92672>*</span>p <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>)
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>if</span> (std<span style=color:#f92672>::</span>isalpha(<span style=color:#f92672>*</span>p))
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (cap_next_)
</span></span><span style=display:flex><span>                <span style=color:#f92672>*</span>p <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>toupper(<span style=color:#f92672>*</span>p);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            cap_next_ <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    std<span style=color:#f92672>::</span>ptrdiff_t n <span style=color:#f92672>=</span> pptr() <span style=color:#f92672>-</span> pbase();
</span></span><span style=display:flex><span>    pbump(<span style=color:#f92672>-</span>n);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sink_.write(pbase(), n);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>对于本例来说，内部的缓冲区并非必要，我们可以一个字符一个字符把数据发到<code>sink</code>中。但是我的观点是一个内部buffer仍有其用处。</p><h3 id=介绍-boost-iostreams-库>介绍 Boost IOStreams 库</h3><p>如果你是流缓冲区的新手，希望你已经对它有一点点了解了。本文中的例子都非常基础，但是你可以用它们做更多有意思的事情。但是当我实现更复杂的流缓冲区时，问题的复杂度却上升的很快。这时我发现了<code>Boost IOStreams</code>库，它为更复杂的缓冲区和流提供了必要的框架支持。</p><p>它允许你解耦数据源，数据输出，过滤器以及其它一些概念。在我们的最后一个例子中，我们硬编码数据输出到<code>std::ostream</code>中。如果我们要输出到一个没有流接口的类呢？<code>Boost IOStreams</code>库提供了更多的灵活性，将一坨紧耦合的代码分解成独立的抽象概念。</p><h3 id=扩展阅读>扩展阅读</h3><ul><li>The C++ Standard Library by Nicolai M. Josuttis</li><li>The C++ Standard, BS ISO/IEC 14882:2003 (Second Edition)</li><li><a href=http://www.dinkumware.com/manuals/ target=_blank rel=noopener>Dinkum Compleat Reference online</a></li></ul></div></div><footer class="py-3 mt-auto bg-light"><div class="container py-1 my-1"><div class="d-flex flex-wrap justify-content-between align-items-center"><p class="col-md mb-0 text-muted"></p><ul class="nav col-md-auto justify-content-end"></ul></div></div></footer><script src=/js/main.min.e8d88c82c0438b527f1aca4115652ba1e2877bf805b75593b23ac0e3fe2b3fe95a467d1feef275355132ba061da6404b0d24d55afabc209b294b1db043be014d.js integrity="sha512-6NiMgsBDi1J/GspBFWUroeKHe/gFt1WTsjrA4/4rP+laRn0f7vJ1NVEyugYdpkBLDSTVWvq8IJspSx2wQ74BTQ==" crossorigin=anonymous defer></script></body></html>