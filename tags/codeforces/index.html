<!doctype html><html lang=zh-cn dir=auto><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Codeforces</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #290 (Div. 2) Tutorial</h2></header><div class=entry-content><p>A. Fox And Snake Implementation
(n, m) = map(int, raw_input().split()) res = [] for i in xrange(n): if i % 2 == 0: res.append('#' * m) elif (i / 2) % 2 == 0: res.append('.' * (m - 1) + '#') else: res.append('#' + '.' * (m - 1)) for line in res: print line B. Fox And Two Dots DFS
A A A A B A A C A A A A We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle.
...</p></div><footer class=entry-footer><span title='2015-02-18 00:30:24 +0000 UTC'>February 18, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #290 (Div. 2) Tutorial" href=https://wizmann.top/posts/cf-290-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #289 (Div. 2) Tutorial</h2></header><div class=entry-content><p>A. Maximum in Table Simulation.
n = int(raw_input()) g = [[1 for i in xrange(n)] for j in xrange(n)] for i in xrange(1, n): for j in xrange(1, n): g[i][j] = g[i - 1][j] + g[i][j - 1] print g[n - 1][n - 1] B. Painting Pebbles Reading comperhension & Constructive.
The key point of this problem is abs(b(i, c) - b(j, c)) &lt;= 1.
First of all, it’s safe to paint k pebbles of every pile with the same color, when k = min(piles). At this moment, every b(i, c) - b(j, c) == 0.
...</p></div><footer class=entry-footer><span title='2015-02-16 21:16:31 +0000 UTC'>February 16, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #289 (Div. 2) Tutorial" href=https://wizmann.top/posts/cf-289-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #288 (Div. 2)</h2></header><div class=entry-content><p>A. Pasha and Pixels Brute force.
There are multiple ways to form a 2*2 square at one single step.
So at every step, we have to check the neighbours of pixel that is colored black.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;vector> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x const int SIZE = 1024 + 123; const int mx[] = {0, 1, 0, 1}; const int my[] = {0, 0, 1, 1}; const int MOVE = 4; int mp[SIZE][SIZE]; int n, m, k; bool isBlackBlock(int y, int x) { int cnt = 0; for (int i = 0; i &lt; MOVE; i++) { int ny = y + my[i]; int nx = x + mx[i]; if (ny >= 0 && ny &lt; n && nx >= 0 && nx &lt; m && mp[ny][nx]) { cnt++; } } return cnt == MOVE; } int main() { int y, x; input(n >> m >> k); memset(mp, 0, sizeof(mp)); int ans = 0; for (int i = 0; i &lt; k; i++) { input(y >> x); x--; y--; mp[y][x] = 1; bool flag = false; for (int j = 0; j &lt; MOVE; j++) { flag |= isBlackBlock(y - my[j], x - mx[j]); } if (flag) { ans = i + 1; break; } } print(ans); return 0; } B. Anton and currency you all know At first, you have to understand the questions accurately.
...</p></div><footer class=entry-footer><span title='2015-02-16 21:16:30 +0000 UTC'>February 16, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #288 (Div. 2)" href=https://wizmann.top/posts/cf-288-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>思维训练 - Thinkin' in induction</h2></header><div class=entry-content><p>热身题 - 24Game 原题请戳我
题意 给你一个包含整数1…n的集合S。接下来进行n-1次操作，每次操作从集合S中选取两个数，在加、减、乘三种运算中选取一种，将结果放回再集合S。在n-1次操作完成后，集合S中只剩下一个数。求问一种取数和运算策略，使最后的结果为24。
...</p></div><footer class=entry-footer><span title='2014-09-26 00:10:45 +0000 UTC'>September 26, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 思维训练 - Thinkin' in induction" href=https://wizmann.top/posts/thinking-in-induction/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces 447D DZY Loves Modification</h2></header><div class=entry-content><p>题意 给你一个n * m的矩阵，让你做K次操作，使得最后得到的值最大。
操作有两种：
一是在任意一行上操作，最终的结果值加上这一行数的和，然后这一行每一个数都要减去p。
...</p></div><footer class=entry-footer><span title='2014-07-24 23:44:44 +0000 UTC'>July 24, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces 447D DZY Loves Modification" href=https://wizmann.top/posts/cf-447d/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #253 Tutorial</h2></header><div class=entry-content><p>443A - Anton and Letters Simple and easy, solved by two lines of python code.
ls = filter(lambda y: y, map(lambda x: x.strip(), raw_input()[1:-1].split(","))) print len(set(ls)) 443B - Kolya and Tandem Repeat Brute force. Just enumerate the beginning and the end of the substring, and check if that substring is tandem repeat.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;algorithm> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x string str; int k; int main() { freopen("input.txt", "r", stdin); input(str >> k); for (int i = 0; i &lt; k; i++) { str += '?'; } int len = str.length(); int ans = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == '?') { break; } for (int j = 1; i + j &lt; len; j += 2) { int slip = (j + 1) / 2; for (int k = 0; k &lt; slip; k++) { if (str[i + k] == str[i + k + slip] || str[i + k + slip] == '?') { /* pass */; } else { goto fail; } } ans = max(ans, j + 1); fail: /*pass*/; } } print(ans); return 0; } 442A - Borya and Hanabig Because Borya knows about the color and value of all his cards, he just need to distinguish each card from the others.
...</p></div><footer class=entry-footer><span title='2014-06-21 19:24:37 +0000 UTC'>June 21, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #253 Tutorial" href=https://wizmann.top/posts/cf-253/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #242 (Div. 2) Tutorials and Solutions</h2></header><div class=entry-content><p>A. Squats Trun x => X or X => x to make the number of ‘x’ is equal to the number of ‘X’.
n = int(raw_input()) hamsters = [c for c in raw_input()] sits = hamsters.count('x') stands = hamsters.count('X') if sits == stands: print 0 print ''.join(hamsters) else: if sits > stands: num = sits - n/2 key = 'x' else: num = stands - n/2 key = 'X' print num for i, c in enumerate(hamsters): if c == key: hamsters[i] = c.swapcase() num -= 1 if not num: break print ''.join(hamsters) B. Megacity Binary search.
...</p></div><footer class=entry-footer><span title='2014-04-30 17:39:00 +0000 UTC'>April 30, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #242 (Div. 2) Tutorials and Solutions" href=https://wizmann.top/posts/cf-242-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)</h2></header><div class=entry-content><p>Overview It has been months that I didn’t participate in the contest on CF, now I’m back. :)
This round of contest makes me confused that the problem B and C is a little bit too twisted, if you can’t catch the vital point, you will get a lot of WAs in the end.
Additionally, the problem D is too easy, just a simple DP and the time limit is too long for an unoptimized solution.
...</p></div><footer class=entry-footer><span title='2014-04-08 14:39:11 +0000 UTC'>April 8, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)" href=https://wizmann.top/posts/cf-240-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #223 (Div. 2) 不完全不正确题解</h2></header><div class=entry-content><p>由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱
事情一直很多，所以题解落后了好久才发。
A. Sereja and Dima 纯模拟，Python随便搞
...</p></div><footer class=entry-footer><span title='2014-01-18 14:47:00 +0000 UTC'>January 18, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #223 (Div. 2) 不完全不正确题解" href=https://wizmann.top/posts/cf-223-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces 3C - Tic-tac-toe</h2></header><div class=entry-content><p>啥？ Tic-tac-toe是我很久之前在CF上做的一道题。非常考细心的模拟题。
最近有同学和我讨论过类似的问题。于是拿出来重新做一遍。练练手。
原题做法 没有任何“算法”成分。纯模拟。
又由于数据量实在是太小（3 × 3的矩阵），所以只要是思路正确。代码怎么写都能过。
...</p></div><footer class=entry-footer><span title='2013-12-29 20:23:00 +0000 UTC'>December 29, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces 3C - Tic-tac-toe" href=https://wizmann.top/posts/cf-3c-tic-tac-toe/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #221 (Div. 2)不完全不正确题解</h2></header><div class=entry-content><p>A. Lever 水题，杠杆原理。
用^把字符串分割开。然后分别计算两边的重量即可。
#Result: Dec 24, 2013 6:04:41 PM Wizmann A - Lever Python 2 Accepted 312 ms 4200 KB def calc(ss): res = 0 p = 1 for item in ss: if item != '=': t = int(item) res += t * p p += 1 return res s = raw_input() (a, b) = s.split('^') left = calc(a[::-1]) right = calc(b) if left == right: print 'balance' elif left > right: print 'left' else: print 'right' B. I.O.U. 水题，算出每个人负债和贷出（这个词的现学的~）的绝对值差。
...</p></div><footer class=entry-footer><span title='2013-12-25 19:05:00 +0000 UTC'>December 25, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #221 (Div. 2)不完全不正确题解" href=https://wizmann.top/posts/cf-221-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>自己动手搭建第三方的Codeforces CDN</h2></header><div class=entry-content><p>啥？ 校园网上CF那叫一个卡。
原因是什么呢？ 因为codeforces大量的使用了ajax技术，所以引用了很多js/css文件，并且引用的位置位于页面之前。
...</p></div><footer class=entry-footer><span title='2013-12-14 00:00:00 +0000 UTC'>December 14, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 自己动手搭建第三方的Codeforces CDN" href=https://wizmann.top/posts/third-party-codeforces-cdn/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #218 (Div. 2)不完全不正确题解</h2></header><div class=entry-content><p>A. K-Periodic Array 将Array切片，然后按位统计某一位上1的个数C(1)和2的个数C(2)。然后在这一位上的操作数就为M = min(C(1), C(2))。
简单题
B. Fox Dividing Cheese 傻逼才错的题，不幸中枪。
...</p></div><footer class=entry-footer><span title='2013-12-09 23:02:00 +0000 UTC'>December 9, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #218 (Div. 2)不完全不正确题解" href=https://wizmann.top/posts/cf-218-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #215 (Div. 2)不完全不正确题解</h2></header><div class=entry-content><p>A. Sereja and Coat Rack 傻逼才错的题。不幸中枪。
没什么可说的。直接看代码就好。
B. Sereja and Suffixes 关键思想在于统计A[i…n-1]中有多少互不相同的数。
使用离线思想，把查询按greater&lt;int>排序，然后使用Hash表进行统计，简单题。
...</p></div><footer class=entry-footer><span title='2013-11-27 00:00:00 +0000 UTC'>November 27, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #215 (Div. 2)不完全不正确题解" href=https://wizmann.top/posts/cf-215-div-2/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>