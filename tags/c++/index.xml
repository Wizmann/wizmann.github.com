<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>C++ on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/c++/</link><description>Recent content in C++ on Maerlyn's Rainbow</description><generator>Hugo -- 0.146.0</generator><language>zh-CN</language><lastBuildDate>Fri, 01 Feb 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/c++/index.xml" rel="self" type="application/rss+xml"/><item><title>C++类型擦除与`std::function`性能探索</title><link>https://wizmann.top/posts/cpp-type-erasure-and-std-function/</link><pubDate>Fri, 01 Feb 2019 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/cpp-type-erasure-and-std-function/</guid><description>&lt;h2 id="什么是类型擦除">什么是类型擦除&lt;/h2>
&lt;p>对于Python这种动态类型语言来说，是不存在“类型擦除”这个概念的。Python对象的行为并不由接口定义，而是由“当前方法和属性的集合”决定。&lt;/p></description></item><item><title>一种区间交问题的奇怪姿势</title><link>https://wizmann.top/posts/range-problem/</link><pubDate>Tue, 20 Feb 2018 22:59:47 +0000</pubDate><guid>https://wizmann.top/posts/range-problem/</guid><description>&lt;blockquote>
&lt;p>Update[220504]: 原来这种数据结构叫&lt;a href="https://oi-wiki.org/ds/odt/">珂朵莉树&lt;/a>啊，真神奇。。。&lt;/p>&lt;/blockquote>
&lt;h2 id="我们要解决什么问题">我们要解决什么问题&lt;/h2>
&lt;p>区间交问题，是我们在做题中经常遇到的问题。&lt;/p>
&lt;p>例如，&lt;a href="https://leetcode.com/problems/insert-interval/description/">Insert Interval&lt;/a>一题，就是比较直白的区间交问题：&lt;/p>
&lt;blockquote>
&lt;p>给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么&lt;/p></description></item><item><title>定时器以及其它 - phxrpc阅读笔记(2)</title><link>https://wizmann.top/posts/phxrpc-2/</link><pubDate>Thu, 29 Sep 2016 01:28:09 +0000</pubDate><guid>https://wizmann.top/posts/phxrpc-2/</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>phxrpc使用了协程(ucontext)和IO复用技术(epoll)来实现网络通信。定时器在其中起到了非常重要的作用。下面我们就来分析一下phxrpc的&lt;code>timer.[h|cpp]&lt;/code>中的代码。&lt;/p></description></item><item><title>自定义你的stream buffer - phxrpc阅读笔记(1)</title><link>https://wizmann.top/posts/phxrpc-1/</link><pubDate>Wed, 28 Sep 2016 22:35:55 +0000</pubDate><guid>https://wizmann.top/posts/phxrpc-1/</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>&lt;a href="https://github.com/tencent-wechat/phxrpc">phxrpc&lt;/a>是微信团队开源的一个轻量级RPC框架。&lt;/p>
&lt;p>我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。&lt;/p></description></item><item><title>用C++实现一个通用的sort函数</title><link>https://wizmann.top/posts/a-common-sorting-function-with-cpp/</link><pubDate>Sat, 25 Apr 2015 11:17:01 +0000</pubDate><guid>https://wizmann.top/posts/a-common-sorting-function-with-cpp/</guid><description>&lt;h2 id="问题">问题&lt;/h2>
&lt;p>用C++实现一个尽可能通用的sort函数&lt;/p>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>一个通用的sort函数应该包含以下要点：&lt;/p>
&lt;ul>
&lt;li>确实可以排序(LOL)&lt;/li>
&lt;li>可以应对C-style array和C++-style container的排序需求&lt;/li>
&lt;li>可以应用于任意random access container&lt;/li>
&lt;li>可以使用用户自定义的排序函数 / 仿函数 / lambda函数&lt;/li>
&lt;/ul>
&lt;h2 id="实现">实现&lt;/h2>
&lt;p>为了与std中的通用函数做区别，这里的命名规则，包括类型与函数，都在前面加了&amp;quot;my&amp;quot;以示区别。可能与标准的命名法有出入，所以仅做示例用。&lt;/p></description></item><item><title>alloca vs placement new</title><link>https://wizmann.top/posts/alloca-vs-placement-new/</link><pubDate>Mon, 07 Apr 2014 21:08:59 +0000</pubDate><guid>https://wizmann.top/posts/alloca-vs-placement-new/</guid><description>&lt;h2 id="what">WHAT?!&lt;/h2>
&lt;p>For most time, we use &lt;code>malloc&lt;/code> or &lt;code>new&lt;/code> for memory allocation, which will get it on &lt;em>heap&lt;/em>.&lt;/p>
&lt;p>However, access memory on &lt;em>heap&lt;/em> is not as effective as the memory on &lt;em>stack&lt;/em>, because the heap is &amp;ldquo;free-floating region of memory&amp;rdquo;. To the contrary, memory on &lt;em>stack&lt;/em> is managed by CPU automacitally and tightly. As a result, the further of the &lt;em>stack&lt;/em> compared to &lt;em>heap&lt;/em> is that we can have a faster read/write speed due to the fact that &lt;em>stack&lt;/em> memory is more likely to optimized by &lt;strong>CPU cache&lt;/strong>, in addition, it only uses a single instruction to allocate or deallocate &lt;em>stack&lt;/em> memory. Just like this.&lt;/p></description></item></channel></rss>