<!doctype html><html lang=zh-cn dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | Maerlyn's Rainbow</title>
<meta name=keywords content><meta name=description content><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/tags/c++/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wizmann.top/tags/c++/index.xml><link rel=alternate hreflang=zh-cn href=https://wizmann.top/tags/c++/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-2X5NE9PX0B"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-2X5NE9PX0B")</script><meta property="og:url" content="https://wizmann.top/tags/c++/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="C++"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>C++</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>C++类型擦除与`std::function`性能探索</h2></header><div class=entry-content><p>什么是类型擦除 对于Python这种动态类型语言来说，是不存在“类型擦除”这个概念的。Python对象的行为并不由接口定义，而是由“当前方法和属性的集合”决定。
...</p></div><footer class=entry-footer><span title='2019-02-01 00:00:00 +0000 UTC'>February 1, 2019</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to C++类型擦除与`std::function`性能探索" href=https://wizmann.top/posts/cpp-type-erasure-and-std-function/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>一种区间交问题的奇怪姿势</h2></header><div class=entry-content><p>Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题：
给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么
...</p></div><footer class=entry-footer><span title='2018-02-20 22:59:47 +0000 UTC'>February 20, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 一种区间交问题的奇怪姿势" href=https://wizmann.top/posts/range-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>定时器以及其它 - phxrpc阅读笔记(2)</h2></header><div class=entry-content><p>写在前面 phxrpc使用了协程(ucontext)和IO复用技术(epoll)来实现网络通信。定时器在其中起到了非常重要的作用。下面我们就来分析一下phxrpc的timer.[h|cpp]中的代码。
...</p></div><footer class=entry-footer><span title='2016-09-29 01:28:09 +0000 UTC'>September 29, 2016</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 定时器以及其它 - phxrpc阅读笔记(2)" href=https://wizmann.top/posts/phxrpc-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>自定义你的stream buffer - phxrpc阅读笔记(1)</h2></header><div class=entry-content><p>写在前面 phxrpc是微信团队开源的一个轻量级RPC框架。
我对RPC这些东西了解不多，看到phxrpc的代码相对简单，而且还在初步开发阶段（在本文写作时，版本号是0.8）。所以想读一读，提高一下姿势水平。
...</p></div><footer class=entry-footer><span title='2016-09-28 22:35:55 +0000 UTC'>September 28, 2016</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 自定义你的stream buffer - phxrpc阅读笔记(1)" href=https://wizmann.top/posts/phxrpc-1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>用C++实现一个通用的sort函数</h2></header><div class=entry-content><p>问题 用C++实现一个尽可能通用的sort函数
分析 一个通用的sort函数应该包含以下要点：
确实可以排序(LOL) 可以应对C-style array和C++-style container的排序需求 可以应用于任意random access container 可以使用用户自定义的排序函数 / 仿函数 / lambda函数 实现 为了与std中的通用函数做区别，这里的命名规则，包括类型与函数，都在前面加了"my"以示区别。可能与标准的命名法有出入，所以仅做示例用。
...</p></div><footer class=entry-footer><span title='2015-04-25 11:17:01 +0000 UTC'>April 25, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 用C++实现一个通用的sort函数" href=https://wizmann.top/posts/a-common-sorting-function-with-cpp/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>alloca vs placement new</h2></header><div class=entry-content><p>WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.
...</p></div><footer class=entry-footer><span title='2014-04-07 21:08:59 +0000 UTC'>April 7, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to alloca vs placement new" href=https://wizmann.top/posts/alloca-vs-placement-new/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>