<!doctype html><html lang=zh-cn dir=auto><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Distributed System</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[tl;dr] 论文阅读：Borg - Large-scale cluster management at Google</h2></header><div class=entry-content><p>系统概览 Borg是谷歌开发的一种高效的集群管理系统，旨在优化资源利用率和提高系统的可靠性及可用性 隐藏资源管理细节与故障处理，允许用户专注于应用程序的开发 保证非常高的可靠性和可用性，以支持用户应用程序的高可靠性和高可用性 支持运行来自众多应用的数十万个作业，并高效运行于数以万计的机器上 用户视角 用户通过定义job和task与Borg进行交互 一个job由运行相同程序的一个或多个task组成 每一个job运行于一个Borg cell（单元）之中，cell是一组机器的集合，是Borg管理的基本单元 Borg的工作负载 长期运行的时延敏感型服务 批处理作业 运行在实体机上，避免VM的虚拟化开销 Allocs 预留给一项或多项任务的一组资源 Alloc可以将不同 jobs 的 tasks 聚集到同一台机器上 如果一个 alloc 必须重新分配到另外一台主机，属于它的 task(s) 也会同它一起重新被调度 一旦创建一个 alloc 集合，就可以提交一个或多个 jobs 运行其中 命名服务和监控 Borg包含一个稳定的 Borg命名服务 (BNS)，包括 cell 名，job 名和 task id Borg将 task 的主机名和端口写入 Chubby，用于 RPC 系统查找 task endpoint Borg还会将 job size与其运行状态写入Chubby，便于load balancer平衡流量 Borg的架构 Borgmaster 主管理进程 逻辑上的“单点”，有5个在线备份，使用Paxos选举master 状态存储在内存中，并且备份在高可靠性的Paxos存储中 调度进程 可行性检查 用于找到满足任务约束、具备足够可用资源的一组机器 打分（scoring） 在“可行机器”中根据用户偏好，为机器打分 打分策略 worst fit（E-PVN的变种）会将任务分散到不同的机器上 有余量应对流量的尖峰 会导致资源的碎片化，阻碍大型task的部署 best fit，会尽量“紧凑”的使用机器，以减少资源碎片 便于大型task的部署 错误的资源估计会被“惩罚”，尤其影响突发的负载 影响利于富裕计算资源的batch jobs 混合模型，尽量减少“受困资源”，即因为其它资源被完全占用而无法分配出去的资源 优化 启动时间优化 中位数启动时间为25s，80%用于安装相关依赖 将相关task优先分配到拥有相关依赖的机器上 使用 tree-like 或 torrent-like 机制，并发的分发相关依赖 计算开销优化 使得Borg能管理更多的机器 打分缓存：将可行性检查和打分结果缓存 等价类：同一 job 中的 task 通常具有类似的约束，因此可以将多个任务视为一个等价类 松弛随机化：计算所有机器的可行性和得分代价太高，可以随机取样一批机器，然后选择其中一个“足够好”的机器 Borglet Borglet 是运行在每台机器上的本地代理，管理本地的任务和资源 Borgmaster 会周期性地向每一个Borglet拉取当前状态，易于控制通信速度，避免“恢复风暴” 为了性能可扩展性，每个Borgmaster副本会运行无状态的 link shard 去处理与部分Borglet通信 当 Borgmaster 重新选举时，link shard 会重新划分分区 link shard 会聚合和压缩信息，仅仅向被Borgmaster报告状态的更新，以此减少更新负载 如果 Borglet 多轮没有响应资源查询，则会被标记为down。运行其上的任务会被重新调度到其他机器。如果恢复通信，则 Borgmaster 会通知 Borglet 杀死已经重新调度的任务，以此保证任务的唯一性 Borglet与Borgmaster失去联系时，仍会继续处理相关任务。以应对 Borgmaster 的暂时失效 可靠性 自动重新调度器被驱逐的任务 将任务分散到不同的失败域中 限制一个作业中同时失败任务的个数和中断率 使用声明式的期望状态表示和幂等的变更操作，以便无害地重新提交请求 对于机器级别的失效，限制其重新调度的速率，因为难以区分大规模机器故障和网络分区 避免重试引发错误的&lt;任务-机器>匹配对 关键数据持久化，写入磁盘 资源利用和效率 评估方法 cell compaction：通过移除机器来找出给定工作负载能适应的最小的单元大小，然后反复从头开始重新打包工作负载，以确保不会因错误的配置而陷入困境 “单元共享”：在同一台机器上运行生产任务和非生产任务，以优化资源使用 实验表明，共享资源会影响实际的CPU计算性能 但是在节约成本的巨大优势上面，CPU性能的退化是可以容忍的 “大型单元”：允许超大型计算任务，减少任务的碎片化 细粒度资源请求 以千分之一的CPU核，和内存、磁盘的字节数为资源请求的最小单元 相比预设资源分配（套餐），可以避免额外的资源开销 资源回收 对于可以容忍低质量资源的工作（例如批处理作业），Borg会评估任务将使用的资源，并回收空闲资源 最初的预留值与其资源请求一致，然后300秒之后，会慢慢降低到实际使用率外加一个安全边缘 如果利用率超过资源预留值，预留值会快速增长。 隔离与安全性： 安全隔离 使用Linux chroot jail在共享同一台机器的任务之间确保安全性 性能隔离 基于cgroup的资源容器，允许详细的资源核算并执行限制，防止任务相互干扰，确保稳定和可预测的性能 使用appclass，尽可能保证延迟敏感服务的资源使用 区分可压缩资源 和 不可压缩资源 可压缩资源（compressiable） - CPU%和Disk IO，可以暂时限流 不可压缩资源（non-compressible） - 内存、磁盘占用，需要清除优先级低的线程 内核的CPU调度器，允许根据每个资源容器的负载状况来动态决定是否要驱逐低优先级任务，同时避免多个高优先级任务在一个cpu上争抢 仍在尝试cpu调度时更好的考虑线程亲和、NUMA亲和等策略 经验教训： 负面经验 Job作为Task的唯一分组机制的局限性 缺乏将整个多Job服务作为单一实体进行管理，或引用服务相关Job（如Canary与Prod滚动更新）的方式 用户会在Job名称中编入拓扑，并构建外部管理工具来解析这些名称，这导致了滚动更新和作业调整大小等问题的不灵活语义 Kubernetes通过使用标签组织其调度单元（Pods），提供了更多灵活性 单个IP地址带来的复杂性 同一台机器上的所有任务共享该机器的单个IP地址和端口空间 导致端口也成为一种资源，在调度时候需要被考虑 Kubernetes采用了更友好的方法，每个Pod和服务都获取自己的IP地址，从而简化了这些复杂性。 偏向于高级用户 Borg提供了一整套面向“高级用户”的功能，允许他们细致调整程序运行方式 这种API的丰富性使得对于“普通”用户更加困难，并限制了其演变 Google构建了自动化工具，对于允许“失败”的应用程序，通过实验来探测适当配置 积极经验 Allocs是有用的 Kubernetes中的Alloc等效物是Pod，它是一个资源包，用于一个或多个容器，总是被调度到同一台机器上并可以共享资源 集群管理不仅是任务管理 尽管Borg的主要角色是管理任务和机器的生命周期，但运行在Borg上的应用程序从许多其他集群服务中受益，包括命名和负载均衡 Kubernetes使用服务抽象支持命名和负载均衡，服务有一个名称和一组由标签选择器定义的动态Pods。 自省至关重要 尽管Borg几乎总是“运行良好”，但当出现问题时，找到根本原因可能具有挑战性 Borg的重要设计决策之一是向所有用户展示调试信息 Kubernetes旨在复制Borg的许多内省技术，例如，它配备了cAdvisor等工具进行资源监控和基于Elasticsearch/Kibana和Fluentd的日志聚合 主控节点是分布式系统的核心 Borgmaster最初被设计为一个单体系统，但随着时间的推移，它变得更像是一个内核，位于协作管理用户作业的一系列服务的中心 Kubernetes架构更进一步，它有一个核心的API服务器，仅负责处理请求和操纵底层状态对象，集群管理逻辑被构建为小型可组合的微服务，这些服务是这个API服务器的客户端​​ 论文 本文部分内容由ChatGPT4生成</p></div><footer class=entry-footer><span title='2023-12-27 00:00:00 +0000 UTC'>December 27, 2023</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to [tl;dr] 论文阅读：Borg - Large-scale cluster management at Google" href=https://wizmann.top/posts/tl-dr-borg/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>[tl;dr] 论文阅读：Rarest First and Choke Algorithms Are Enough</h2></header><div class=entry-content><p>基本概念 Peer：BitTorrent P2P下载的参与者 Leecher：“吸血者”，仍在下载过程中的peer Seeder：做种者，下载完成后还在继续做种的peer Piece：Piece是文件的数据单元。当文件被分享时，它被分割成多个大小相等的片段，称为"pieces"。这些pieces是peer间传输的基本单位 “最稀有优先算法”（Rarest First Algorithm） “最稀有优先算法”（Rarest First Algorithm）是BitTorrent协议中的一个关键策略，用于决定哪些数据块（piece）首先被下载和分享。这个算法的核心目标是优化整个网络中数据的分布，确保更快的下载速度和更高的效率。 基本原理 数据块的稀有度 在BitTorrent网络中，文件被分割成许多小的数据块。 “最稀有优先”算法的目的是优先下载那些网络中数量最少的数据块。 选择下载的块： 当一个peer加入Torrent网络，并开始下载文件时，它首先会从所有连接的peer那里获取有关哪些数据块是稀有的信息。 然后，它优先请求下载那些最稀有的数据块。 动态调整： 随着下载的进行，每个peer会不断更新和重新评估网络中每个数据块的稀有度，并相应地调整其下载优先级。 算法的重要性 提高效率：通过优先下载最稀有的块，这个算法帮助加快了文件的整体下载速度。一旦最稀有的块被更多peer获取，它们就更容易被进一步分享和分发。 防止瓶颈：如果没有这个算法，某些数据块可能会变得很难获得，导致下载过程在接近完成时放慢，这被称为“最后一块问题”（Last Piece Problem）。 促进平等分享：这种方法鼓励peer分享它们拥有的稀有块，从而提高了整个网络中的合作和资源共享。 实际应用 在BitTorrent网络中，这个算法对于确保高效的数据分发至关重要。它不仅提高了单个用户的下载速度，而且还提高了整个网络的效率，确保了资源在用户之间的均衡分配。通过这种方式，BitTorrent网络能够有效地避免瓶颈和提高数据的可用性，即使在面对大量用户的情况下也是如此。 结论 最稀有优先算法是BitTorrent网络高效运行的关键组成部分。它通过智能地选择下载和分享网络中最稀有的数据块，提高了资源的整体分布和可用性，确保了快速、平衡的文件共享。 “窒息算法”（Choking Algorithm） “窒息算法”（Choking Algorithm）是BitTorrent协议中的一个关键组成部分，用于管理多个peer之间的数据传输。这个算法帮助优化带宽的使用，确保网络中的资源被高效合理地分配。其核心目的是促进peer间的合作和数据的快速分发。 窒息算法的基本原理 选择和窒息（Choking and Unchoking） 在BitTorrent网络中，每个peer同时维护着一组“窒息”（choked）和“未窒息”（unchoked）的peer名单。 被“窒息”的peer无法从窒息方接收文件数据，而“未窒息”的peer可以进行数据交换。 这种状态是动态的，peer根据算法定期更新它们的窒息/未窒息peer名单。 利益驱动的决策 算法核心是“利益驱动”（tit-for-tat）策略，即peer更倾向于向那些能给它提供数据的peer提供数据。 这种方法鼓励peer分享数据，因为分享越多，获得数据的机会也越大。 优化器： 除了基于交换数据的量来决定窒息状态外，大多数BitTorrent客户端还实现了一个“优化器”（Optimizer），用于探索新的peer。 通常，这是通过定期“未窒息”一个随机选择的peer来实现的，即使它在过去的数据交换中表现不佳或没有数据交换。 窒息周期： peer定期评估其连接，并根据从其他peer接收到的数据速率来更新其窒息/未窒息名单 窒息算法的重要性 合作促进：通过奖励那些分享资源的peer，窒息算法鼓励合作，提高了网络中的资源共享效率。 防止自私行为：算法减少了自私peer（只下载不上传的）的优势，因为这些peer不太可能被其他peer“未窒息”。 网络拥塞控制：它帮助控制网络拥塞，通过限制peer的连接数量和数据传输，优化带宽使用。 结论 窒息算法是BitTorrent协议高效性的关键，它通过一种简单但有效的方式来鼓励数据共享和合作，保证了整个网络的健康和高效运行。通过这种动态的窒息/未窒息机制，BitTorrent网络能够有效地管理带宽和连接，确保资源在网络中的快速且公平的分配。 为什么说“已经足够了” 因为这是一门实验科学
...</p></div><footer class=entry-footer><span title='2023-12-08 00:00:00 +0000 UTC'>December 8, 2023</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to [tl;dr] 论文阅读：Rarest First and Choke Algorithms Are Enough" href=https://wizmann.top/posts/tl-dr-rarest-first-and-choke-algorithms-are-enough/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Introduction to Ceph</h2></header><div class=entry-content><p>什么是Ceph Ceph是一个可扩展的，高性能的分布式存储系统。提供了三种不同类型的接口以适应不同的应用场景：
block-based: 块存储，可以用做VM的虚拟磁盘 object-based: 对象存储，与Amazon S3等常用对象存储兼容 file system: POSIX兼容的分布式文件系统，可以被本地系统挂载，并且能被多个客户端共享 ...</p></div><footer class=entry-footer><span title='2020-11-29 00:00:00 +0000 UTC'>November 29, 2020</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Introduction to Ceph" href=https://wizmann.top/posts/introduction-to-ceph/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>ZeroMQ启示录</h2></header><div class=entry-content><p>ØMQ是一个消息系统 ZeroMQ是一个消息系统，也被称为“消息中间件”。它被广泛的用于经济、游戏、嵌入式等领域。
什么是消息系统 打个比方，消息系统就像我们使用的IM软件一样。首先，一方决定将消息发往何处（一对一或一对多）。然后将信息打包，点击发送按钮。之后，IM系统会帮你料理剩余的事务。
...</p></div><footer class=entry-footer><span title='2015-04-07 10:01:34 +0000 UTC'>April 7, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to ZeroMQ启示录" href=https://wizmann.top/posts/inspiration-from-zeromq/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>