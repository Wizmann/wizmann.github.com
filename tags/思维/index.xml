<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>思维 on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/%E6%80%9D%E7%BB%B4/</link><description>Recent content in 思维 on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 28 Dec 2013 14:42:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/%E6%80%9D%E7%BB%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>How to "Rotate Image"?</title><link>https://wizmann.top/posts/how-to-rotate-image-leetcode/</link><pubDate>Sat, 28 Dec 2013 14:42:00 +0000</pubDate><guid>https://wizmann.top/posts/how-to-rotate-image-leetcode/</guid><description>&lt;h2 id="啥">啥？ &lt;a href="#%e5%95%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>原题&lt;a href="http://oj.leetcode.com/problems/rotate-image/">戳我&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>Rotate Image&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>You are given an n x n 2D matrix representing an image.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Rotate the image by 90 degrees (clockwise).&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Follow up:&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>Could you do this in-place?&lt;/p>&lt;/blockquote>
&lt;p>示意图如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-tk-pic/blog-rotate-image-leetcode.png" alt="rotate-image">&lt;/p>
&lt;p>当然，矩阵中的数字&lt;strong>不一定&lt;/strong>是规律的。&lt;/p>
&lt;h2 id="为什么要提出这个问题">为什么要提出这个问题 &lt;a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%8f%90%e5%87%ba%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>自觉是一个&lt;strong>不聪明&lt;/strong>的人（双低。。。&amp;lt;(=＠_＠;=)?&amp;gt;）。&lt;/p>
&lt;p>别人一下子就想明白的事，在我这里要计算好几个来回。&lt;/p>
&lt;p>所以努力想找到一个思维方法去弥补这个不足。&lt;/p>
&lt;p>就以这题为例，如何使用简单、直接的方法，迅速正确的找出变化的映射规律。&lt;/p>
&lt;h2 id="初步思路">初步思路 &lt;a href="#%e5%88%9d%e6%ad%a5%e6%80%9d%e8%b7%af" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>由于不可以使用&lt;strong>额外的空间&lt;/strong>。所以必须找到一个坐标映射&lt;code>f(x, y) =&amp;gt; (next_x, next_y)&lt;/code>。&lt;/p>
&lt;p>这样，我们就可以通过循环来&lt;code>swap&lt;/code>矩阵中的元素。&lt;/p>
&lt;h2 id="遇到问题">遇到问题 &lt;a href="#%e9%81%87%e5%88%b0%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>如何确定映射&lt;code>f(x, y)&lt;/code>？&lt;/p>
&lt;p>由于我的思维不能支持我在头脑中形成正确的公式。&lt;/p>
&lt;p>于是我想到，因为我们要求的变换是在二维矩阵中的简单移位。所以我们可以做出如下一个方程。&lt;/p>
&lt;p>&lt;code>f(x, y) = (ax + by + c, dx + ey + f)&lt;/code>&lt;/p>
&lt;p>然后找出特殊点，代入方程中，求出&lt;code>a&lt;/code>到&lt;code>f&lt;/code>各自代表的值。&lt;/p>
&lt;p>于是求出映射&lt;code>f(x, y) =&amp;gt; (y, n - x)&lt;/code>。&lt;/p>
&lt;p>即可以分解为：&lt;code>reverse_X(Matrix.T)&lt;/code>&lt;/p>
&lt;h2 id="思考方式">思考方式 &lt;a href="#%e6%80%9d%e8%80%83%e6%96%b9%e5%bc%8f" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>以上的方法是我失败了N次之后才想到的。（弱。。。）&lt;/p>
&lt;p>于是我又有了进一步的思考。&lt;/p>
&lt;p>这样的思考方式是不是最佳的。如果大家遇到这样的问题，会用什么巧妙的方法去思考，去优雅的解决问题。&lt;/p>
&lt;p>不过要记得我们的条件&lt;/p>
&lt;ul>
&lt;li>矩阵顺时针旋转90度&lt;/li>
&lt;li>in-place变换，不得使用额外的空间&lt;/li>
&lt;/ul>
&lt;p>欢迎大家提出自己的看法。代码请贴到&lt;a href="https://gist.github.com/">gist&lt;/a>或&lt;a href="http://lpaste.net/">hpaste&lt;/a>等网站上，不要把代码直接写到评论中，我会及时update本文，展示大家的想法。&lt;/p></description></item></channel></rss>