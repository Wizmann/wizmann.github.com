<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FIFO on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/fifo/</link><description>Recent content in FIFO on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 17 Dec 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/fifo/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 SPIN/Promela 对多线程 Concurrent FIFO Queue 进行建模与验证</title><link>https://wizmann.top/posts/spin-promela-concurrent-queue-1/</link><pubDate>Sun, 17 Dec 2023 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/spin-promela-concurrent-queue-1/</guid><description>&lt;h2 id="引言">引言 &lt;a href="#%e5%bc%95%e8%a8%80" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>并发编程中设计和验证多线程数据结构是一项极大的挑战，即使是实现一个简单的数据结构（见&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">《实现一个无锁消息队列》&lt;/a>一文），都需要不少的脑力、讨论与实践才可以尽可能保证其正确性。&lt;/p>
&lt;p>本文尝试使用 SPIN/Promela 对多线程环境下的 Concurrent FIFO Queue 的一种实现进行建模与验证。&lt;/p>
&lt;h2 id="concurrent-fifo-queue-的设计">Concurrent FIFO Queue 的设计 &lt;a href="#concurrent-fifo-queue-%e7%9a%84%e8%ae%be%e8%ae%a1" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>为了保证多线程操作的正确性，我们采用了以下关键设计：&lt;/p>
&lt;ul>
&lt;li>Dummy Head 和 Dummy Tail 节点：引入这两个节点简化了队列操作逻辑，降低并发中的复杂性&lt;/li>
&lt;li>Dummy Tail Data 指针作为“锁”：这个方法确保多个线程不会同时操作尾节点，降低了对锁的依赖&lt;/li>
&lt;li>利用指针赋值的原子性：通过这种方式，减少了锁的使用，提高了效率&lt;/li>
&lt;/ul>
&lt;h2 id="spinpromela-建模中的考虑因素">SPIN/Promela 建模中的考虑因素 &lt;a href="#spinpromela-%e5%bb%ba%e6%a8%a1%e4%b8%ad%e7%9a%84%e8%80%83%e8%99%91%e5%9b%a0%e7%b4%a0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在使用 SPIN/Promela 建模时，我们面临了几个挑战：&lt;/p>
&lt;ul>
&lt;li>静态内存管理：SPIN/Promela 缺乏动态内存操作，因此我们实现了一个极简的手动管理的静态内存堆栈。&lt;/li>
&lt;li>减少状态空间：队列的长度可以是无限的，这也就意味着无限的状态空间。因此，我们将队列的最大长度设为3，以减少状态的穷举空间。&lt;/li>
&lt;li>模拟CAS操作：由于缺少CAS指令，我们使用 do 循环和 atomic 块来模拟，同时开启 weak fairness 避免无限循环。（见&lt;a href="https://wizmann.top/simple-cas-model-in-spin-promela.html">《在SPIN/Promela中模拟CAS》&lt;/a>一文）&lt;/li>
&lt;li>LTL表达式的使用：使用 LTL 表达式来穷举检查所有可能的程序状态，包括边缘情况。
&lt;ul>
&lt;li>LTL表达式偶尔会有一些”反直觉“的情况出现&lt;/li>
&lt;li>例如在程序验证路径中，虽然理论上队列大小可以为0~3当中的任意数。但是也存在一种可能，即队列大小可以在2和3之间反复变化。如果我们声明“&lt;strong>永远&lt;/strong> &lt;strong>最终&lt;/strong> 一定存在 queue size==1” 的表达式会失败，因为队列大小在这种“人造场景”下永远不会为1。&lt;/li>
&lt;li>这种情况要求我们非常精确地设计 LTL 表达式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>代码与断言的结合：因为 LTL 表达式的表达能力有限，需要结合代码中的 assert 语句来进行更全面的验证&lt;/li>
&lt;/ul>
&lt;h2 id="代码示例">代码示例 &lt;a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>下面是我们用于建模和验证 Concurrent FIFO Queue 的 Promela 代码示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-promela" data-lang="promela">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define MAX_CAPACITY 3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define NUM_NODES MAX_CAPACITY + 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define EMPTY -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define INVALID_PTR -1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define QUEUE_NOT_FULL (memptr &amp;gt; 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define QUEUE_NOT_EMPTY (memptr &amp;lt; MAX_CAPACITY)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define QUEUE_IS_EMPTY (memptr == MAX_CAPACITY)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define QUEUE_IS_FULL (memptr == 0)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define HEAD 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">typedef&lt;/span> QueueNode {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> nextptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 1 dummy head + 1 dummy tail + #(data nodes)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>QueueNode nodes[NUM_NODES];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// data nodes + dummy tail
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> memory[MAX_CAPACITY &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> memptr &lt;span style="color:#f92672">=&lt;/span> MAX_CAPACITY;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> queue_size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> running &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> .. NUM_NODES &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> INVALID_PTR;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[i]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> .. MAX_CAPACITY &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memory[i] &lt;span style="color:#f92672">=&lt;/span> i &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memory[MAX_CAPACITY] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">-1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> HEAD &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail &lt;span style="color:#f92672">=&lt;/span> HEAD &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span> worker(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span> worker(&lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> running &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> update_queue_size() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">d_step&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> HEAD;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> size &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> nodes[cur]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> INVALID_PTR &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(cur &lt;span style="color:#f92672">!=&lt;/span> INVALID_PTR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> nodes[cur]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(nodes[cur]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">==&lt;/span> INVALID_PTR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> size&lt;span style="color:#f92672">--&lt;/span>; &lt;span style="color:#75715e">// remove HEAD
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#a6e22e">assert&lt;/span>(size &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> size &lt;span style="color:#f92672">&amp;lt;=&lt;/span> MAX_CAPACITY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue_size &lt;span style="color:#f92672">=&lt;/span> size;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> enqueue(workerId) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cur1 &lt;span style="color:#f92672">=&lt;/span> INVALID_PTR;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (memptr &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;gt;=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur1 &lt;span style="color:#f92672">=&lt;/span> memory[memptr &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memory[memptr &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">-1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memptr&lt;span style="color:#f92672">--&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(nodes[cur1]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">==&lt;/span> EMPTY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(nodes[cur1]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">==&lt;/span> INVALID_PTR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> cur1 &lt;span style="color:#f92672">!=&lt;/span> INVALID_PTR &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (true) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// CAS
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (nodes[tail]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">==&lt;/span> EMPTY) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[tail]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> workerId;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> update_queue_size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[tail]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> cur1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail &lt;span style="color:#f92672">=&lt;/span> cur1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> dequeue(workerId) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> cur2 &lt;span style="color:#f92672">=&lt;/span> INVALID_PTR;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (true) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> nxt2 &lt;span style="color:#f92672">=&lt;/span> nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur2 &lt;span style="color:#f92672">=&lt;/span> INVALID_PTR;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (nxt2 &lt;span style="color:#f92672">!=&lt;/span> tail) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur2 &lt;span style="color:#f92672">=&lt;/span> nxt2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> update_queue_size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">==&lt;/span> nxt2 &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> nxt2 &lt;span style="color:#f92672">!=&lt;/span> tail) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> nodes[cur2]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[cur2]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">=&lt;/span> INVALID_PTR;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> nodes[cur2]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">=&lt;/span> EMPTY;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> update_queue_size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (cur2 &lt;span style="color:#f92672">!=&lt;/span> INVALID_PTR) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">d_step&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(nodes[cur2]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">==&lt;/span> INVALID_PTR);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(nodes[cur2]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">data&lt;/span> &lt;span style="color:#f92672">==&lt;/span> EMPTY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(memptr &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">&amp;lt;=&lt;/span> MAX_CAPACITY);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> .. memptr &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(memory[i] &lt;span style="color:#f92672">!=&lt;/span> cur2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">assert&lt;/span>(memory[memptr] &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">-1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memory[memptr] &lt;span style="color:#f92672">=&lt;/span> cur2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> memptr&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">proctype&lt;/span> worker(&lt;span style="color:#66d9ef">int&lt;/span> workerId) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (QUEUE_NOT_FULL) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> enqueue(workerId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (QUEUE_NOT_EMPTY) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> dequeue(workerId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ltl&lt;/span> valid_first_node { &lt;span style="color:#f92672">[]&lt;/span>( running &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ((nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">!=&lt;/span> INVALID_PTR) &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> (nodes[HEAD]&lt;span style="color:#f92672">.&lt;/span>&lt;span style="color:#a6e22e">nextptr&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> NUM_NODES)) ); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ltl&lt;/span> not_always_empty { &lt;span style="color:#f92672">[]&lt;/span>(running &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (QUEUE_IS_EMPTY &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>QUEUE_NOT_EMPTY)); };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ltl&lt;/span> not_always_full { &lt;span style="color:#f92672">[]&lt;/span>(running &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (QUEUE_IS_FULL &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>QUEUE_NOT_FULL)); };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ltl&lt;/span> size_change_by_1 { &lt;span style="color:#f92672">[]&lt;/span>(running &lt;span style="color:#f92672">-&amp;gt;&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">U&lt;/span> queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">U&lt;/span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">||&lt;/span> queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>)) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">U&lt;/span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">||&lt;/span> queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span>)) &lt;span style="color:#f92672">||&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">U&lt;/span> queue_size &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>))) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="讨论">讨论 &lt;a href="#%e8%ae%a8%e8%ae%ba" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="混合编程的可能性">混合编程的可能性 &lt;a href="#%e6%b7%b7%e5%90%88%e7%bc%96%e7%a8%8b%e7%9a%84%e5%8f%af%e8%83%bd%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们是否可以通过 Promela 与 C/C++ 的混合编程来解决模型中的一些困难？这种方法或许能提供更加灵活的解决方案，但代价又是什么呢？&lt;/p>
&lt;h3 id="ltl语句的合理性">LTL语句的合理性 &lt;a href="#ltl%e8%af%ad%e5%8f%a5%e7%9a%84%e5%90%88%e7%90%86%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在多线程环境下验证数据结构的正确性始终是一项艰巨的任务。对于代码中使用的LTL语句，是否需要继续完善以保证其在更多（甚至所有）场景下的正确性?&lt;/p>
&lt;h3 id="对于其他实现的验证">对于其他实现的验证 &lt;a href="#%e5%af%b9%e4%ba%8e%e5%85%b6%e4%bb%96%e5%ae%9e%e7%8e%b0%e7%9a%84%e9%aa%8c%e8%af%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">《实现一个无锁消息队列》&lt;/a>一文中，涉及了更多的多线程队列模型，后续会对其进行验证。&lt;/p>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item></channel></rss>