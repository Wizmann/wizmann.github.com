<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Thread on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/thread/</link><description>Recent content in Thread on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 18 Mar 2024 23:21:35 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/thread/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU缓存一致性与内存一致性（第一部分-MESI协议）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order/</link><pubDate>Mon, 18 Mar 2024 23:21:35 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order/</guid><description>&lt;p>在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。
然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。&lt;/p>
&lt;h3 id="缓存一致性">缓存一致性 &lt;a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>缓存一致性是指在一个多处理器系统中，确保当某个处理器修改了存储在共享资源（如主内存或缓存中的数据）时，其他处理器能够访问到最新的数据版本，从而保证数据的一致性。&lt;/p>
&lt;p>为了达到这一目标，缓存一致性机制必须处理两个主要问题：写传播（Write Propagation）和事务串行化（Transaction Serialization）。&lt;/p>
&lt;p>写传播确保一个处理器核心的写操作能被传播并被其他处理器核心所见。而事务串行化则确保所有处理器核心的写操作按照一定的顺序执行，对所有处理器核心而言这个顺序是一致的。这两个机制共同工作，确保了即使多个CPU可能并发地修改同一份数据，它们也能看到一致的数据视图。&lt;/p>
&lt;h3 id="mesi协议">MESI协议 &lt;a href="#mesi%e5%8d%8f%e8%ae%ae" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>为了实现缓存一致性，多种协议和机制被设计出来，其中MESI协议是最广泛使用的一种机制。&lt;/p>
&lt;blockquote>
&lt;p>实际上，AMD处理器使用的是MOESI协议，Intel处理器使用的是MESIF协议。这两种协议都是MESI协议的变种。这里不展开讨论。&lt;/p>&lt;/blockquote>
&lt;p>MESI 协议通过定义缓存行的四种状态——修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid），管理多个处理器缓存之间的一致性。状态之间的转换受到缓存协议控制，以确保数据的一致性和同步。&lt;/p>
&lt;ul>
&lt;li>独占（Exclusive, E）：缓存行仅存在于当前缓存中，并且是干净的（即缓存数据与主存数据一致）。当其他缓存尝试读取该数据时，状态转变为共享；当前缓存写入数据时，转变为已修改状态&lt;/li>
&lt;li>共享（Shared, S）：缓存行同时存在于其他缓存中，并且是干净的。该缓存行可以在任意时刻被抛弃&lt;/li>
&lt;li>已修改（Modified, M）：缓存行的数据是“脏”的（即与主存的值不同）。如果其他 CPU 核心需要读取这块数据，该缓存行必须先回写到主存，然后状态转变为共享&lt;/li>
&lt;li>无效（Invalid, I）：表示该缓存行无效，即为空。上文提到的缓存策略会优先填充无效行&lt;/li>
&lt;/ul>
&lt;p>简单来说，MESI的设计目标在于：&lt;/p>
&lt;ol>
&lt;li>防止多个处理器核心同时对共享数据进行修改。任何需要修改共享数据的核心都会先发出RFO（Read For Ownership）请求来获取该缓存块的所有权，并使其他处理器核心中的相应缓存块变为无效。&lt;/li>
&lt;li>通过推迟写回操作来减少对内存的频繁修改，确保只有在必要时才将缓存中的更改写回内存。&lt;/li>
&lt;/ol>
&lt;h3 id="mesi-的状态转移">MESI 的状态转移 &lt;a href="#mesi-%e7%9a%84%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>MESI 协议的状态转移如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-03-31/1711876193915_Diagrama_MESI.gif" alt="">&lt;/p>
&lt;ul>
&lt;li>从无效（I）到独占（E）：当 CPU 需要写入一个缓存行而该行当前状态为无效时，如果其他 CPU 缓存中没有该缓存行的副本，该行状态变为独占。这表明当前 CPU 缓存中的数据是最新的，且没有其他副本存在&lt;/li>
&lt;li>从无效（I）到共享（S）：当 CPU 需要读取一个缓存行而该行当前状态为无效时，如果其他 CPU 缓存中存在该缓存行的副本，则该行状态变为共享&lt;/li>
&lt;li>从共享（S）到独占（E）：当一个 CPU 想要写入一个处于共享状态的缓存行时，必须首先获取其他所有 CPU 上该缓存行的独占访问权，如果成功，该缓存行状态变为独占&lt;/li>
&lt;li>从独占（E）到修改（M）：当 CPU 对处于独占状态的缓存行进行写操作时，该缓存行状态变为修改。这表示数据已被当前 CPU 修改，且与主存不同步&lt;/li>
&lt;li>从修改（M）到共享（S）：当其他 CPU 请求读取处于修改状态的缓存行时，当前 CPU 必须将该缓存行的数据写回主存，并将缓存行状态改为共享，以便其他 CPU 可以读取最新数。&lt;/li>
&lt;li>从任何状态到无效（I）：当 CPU 接收到其他 CPU 发出的无效化请求时，如果当前 CPU 缓存中有该缓存行的副本，不论它处于何种状态，都必须将其标记为无效。这通常发生在其他 CPU 想要写入同一缓存行的情况下&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>可以使用这个&lt;a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESI.htm">简单的模拟器&lt;/a>来模拟MESI协议的工作状态&lt;/p>&lt;/blockquote>
&lt;h3 id="mesi的优化">MESI的优化 &lt;a href="#mesi%e7%9a%84%e4%bc%98%e5%8c%96" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>随着多核处理器的普及和系统复杂度的增加，MESI协议面临着性能瓶颈和效率问题。因此，为了提高系统性能和缩短响应时间，对MESI协议的优化变得非常必要。&lt;/p>
&lt;h4 id="写缓冲区store-buffer机制">写缓冲区（Store Buffer）机制 &lt;a href="#%e5%86%99%e7%bc%93%e5%86%b2%e5%8c%bastore-buffer%e6%9c%ba%e5%88%b6" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在进行写入操作时，一个CPU核心（例如核心1）首先需要广播一个读取为了写入（Read For Ownership，RFO）请求，以获得对应数据的独占访问权。在等待其他核心响应此请求并发送回确认信号（ACK）期间，核心1原本需要空闲等待，这无疑是对CPU资源的一种浪费。&lt;/p>
&lt;p>为了提高效率，现代CPU设计了“写缓冲区”机制。通过这种机制，当核心1发出RFO请求并将写入操作放入写缓冲区后，它可以立即继续执行其他任务，而不需要等待ACK的到来。一旦收到ACK，CPU再从写缓冲区中取出写入操作，实际写入到缓存中。这样不仅优化了CPU的工作流程，还提升了处理器的整体效能。&lt;/p>
&lt;h4 id="失效队列invalidation-queue">失效队列（Invalidation Queue） &lt;a href="#%e5%a4%b1%e6%95%88%e9%98%9f%e5%88%97invalidation-queue" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>为了解决核心在忙碌时无法及时响应RFO请求的问题，现代CPU引入了“失效队列”机制。收到的RFO请求被放入失效队列，并立即发送回ACK，待核心完成手头上的任务后，再处理失效队列中的请求。这种设计有效地缩短了等待时间，加速了数据同步过程。&lt;/p>
&lt;h3 id="mesi的潜在问题">MESI的潜在问题 &lt;a href="#mesi%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="false-sharing">False Sharing &lt;a href="#false-sharing" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>由于CPU以64B的Cache Line为最小单位从内存中加载数据，可能会出现这样的问题：&lt;/p>
&lt;p>假设变量a和b位于同一个Cache Line中，当前CPU0和CPU1都将这个Cache Line加载到Cache，CPU0只修改变量a，CPU1只读取变量b。当CPU0修改a时，CPU1的Cache Line会变为Invalid状态，即使CPU1并没有修改b，这会导致CPU1从内存或其它核心重新加载Cache Line中的所有变量，影响性能。这就是False Sharing。&lt;/p>
&lt;p>解决False Sharing的常用方法是进行字节填充，在a和b之间填充无意义的变量，使一个变量单独占用一个Cache Line。&lt;/p>
&lt;h4 id="rmw操作">RMW操作 &lt;a href="#rmw%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在并发编程中，读-改-写（RMW）操作，如比较并交换（CAS）和原子加（ADD），需作为单一的原子操作执行以避免数据竞争。&lt;/p>
&lt;p>尽管MESI缓存一致性协议确保了处理器核心间缓存行状态的一致性，它并不解决操作的原子性问题。在RMW操作中，由于从读取到写回的时间窗口内可能发生其他处理器的干预修改，可能导致数据竞争和状态不一致。&lt;/p>
&lt;p>在为此，&lt;code>LOCK&lt;/code>指令被用来确保RMW操作的原子性，通过锁定操作涉及的缓存行，防止在操作完成前被其他处理器访问，从而有效地解决了数据竞争问题，保障了操作的安全性和数据的一致性。&lt;/p>
&lt;h4 id="写缓冲区store-buffer优化带来的潜在问题">写缓冲区（Store Buffer）优化带来的潜在问题 &lt;a href="#%e5%86%99%e7%bc%93%e5%86%b2%e5%8c%bastore-buffer%e4%bc%98%e5%8c%96%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>写缓冲区带来的最主要的问题是与其他核心的数据一致性问题。由于写操作被延迟执行，其他核心可能在这段时间内读取到了旧的数据值，从而导致数据不一致的问题。此外，写缓冲区可能导致内存顺序的问题，即编写的程序逻辑与实际执行逻辑不符。&lt;/p>
&lt;h4 id="失效队列invalidation-queue带来的潜在问题">失效队列（Invalidation Queue）带来的潜在问题 &lt;a href="#%e5%a4%b1%e6%95%88%e9%98%9f%e5%88%97invalidation-queue%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>失效队列提高了响应速度，但它也可能引入新的问题。失效队列允许CPU核心在确认接收到失效请求后，延迟处理这些请求。这种延迟可能导致数据在不同核心间的一致性问题，即一个核心可能会在短时间内继续使用已经失效的数据，而这段时间内其他核心已经修改了这部分数据。&lt;/p>
&lt;h2 id="参考链接">参考链接 &lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/LeoYang90/Golang-Internal-Notes/blob/master/Go%20%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.md#go-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B">Go 内存一致性模型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7158395475362578462">12 张图看懂 CPU 缓存一致性与 MESI 协议，真的一致吗？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/">Cache一致性和内存一致性&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.chongsheng.art/post/golang/cpu-cache-memory-barrier/">CPU缓存架构到内存屏障&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>Parallel patterns in C#</title><link>https://wizmann.top/posts/parallel-in-csharp/</link><pubDate>Sun, 22 Jan 2017 22:52:28 +0000</pubDate><guid>https://wizmann.top/posts/parallel-in-csharp/</guid><description>&lt;h2 id="写在前面">写在前面 &lt;a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>与C/C++所使用的，传统的基于线程的并行模式不同，C#实现了丰富的并发编程模型，其中以异步模型最为流行。&lt;/p>
&lt;p>本文中我们重点讨论C#在发展过程中出现的几种异步编程模型：&lt;/p>
&lt;ul>
&lt;li>Async Programming Model（APM）&lt;/li>
&lt;li>Event-based Async Pattern (EAP)&lt;/li>
&lt;li>Task-based Async Pattern（TAP）&lt;/li>
&lt;li>async/await语法糖&lt;/li>
&lt;/ul>
&lt;h2 id="异步编程入门">异步编程入门 &lt;a href="#%e5%bc%82%e6%ad%a5%e7%bc%96%e7%a8%8b%e5%85%a5%e9%97%a8" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>同步模式是最常见，也是最被人熟知的编程模型，每一个任务按顺序执行，前一个任务执行完之后才会执行下一个任务。&lt;/p>
&lt;p>异步编程和同步编程不同，程序的执行流程是由“事件”所驱动的。异步编程有两种实现方式，回调与future模式。&lt;/p>
&lt;p>回调函数在Javascript中被大量使用，相信大家也都不会陌生。但是大量的回调函数会让代码失去可读性，陷入“Callback hell”。&lt;/p>
&lt;p>Promise模式是回调函数的一种“包装”。我们使用一个占位符来表示“未来”将会产生的一个异步处理结果。&lt;/p>
&lt;p>这个占位符在不同的语言/框架里面有不同的名字，其定义也不尽相同：&lt;/p>
&lt;ul>
&lt;li>Task - C#&lt;/li>
&lt;li>Deferred - Python Twisted&lt;/li>
&lt;li>Promise - Javascript&lt;/li>
&lt;/ul>
&lt;p>在任务结束后，会触发绑定在这个占位符上定义的回调函数，继续预定义好的逻辑。&lt;/p>
&lt;p>举个例子，同步模型就是你：&lt;/p>
&lt;p>宅家想吃饭 -&amp;gt; 下楼买饭 -&amp;gt; 上楼 -&amp;gt; 吃饭 -&amp;gt; 打游戏看漂亮小姐姐。&lt;/p>
&lt;p>而异步模型呢，就是：&lt;/p>
&lt;p>宅家想吃饭 -&amp;gt; 手机叫外卖 -&amp;gt; 拿到了外卖定单（拿到占位符 或 注册回调）-&amp;gt; 打游戏看漂亮小姐姐 -&amp;gt; 外卖小哥把饭送上门（启动回调） -&amp;gt; 吃饭 -&amp;gt; 继续打游戏看漂亮小姐姐。&lt;/p>
&lt;p>虽然从上面看，异步模型比同步模型要复杂一些。但是它却节省了耗时的“上下楼买饭”的时间，让你可以分配更多的时间用来看漂亮小姐姐。这和我们写程序时的思路是一致的，节省动辄十几几十毫秒耗时的IO时间，将更多的时间用在CPU上。&lt;/p>
&lt;h2 id="thread-based-parallel">Thread Based Parallel &lt;a href="#thread-based-parallel" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>基于线程的并发模型是比较传统的并发模型了，基本上所有的现代编程语言都会支持。C#中Thread的用法与Java类似，这里就不做展开。&lt;/p>
&lt;p>与此同时，C#还支持Thread pool，用来运行&amp;quot;long-running processor-bound tasks&amp;quot;。&lt;/p>
&lt;p>直接操作线程也许是中年程序员的必修课，但是手动管理线程会给程序带来额外的负担。所以各种模型与框架应运而生，试图降低并发编程的复杂度。&lt;/p>
&lt;h2 id="async-programming-model-apm">Async Programming Model (APM) &lt;a href="#async-programming-model-apm" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在我们熟悉的async/await语法糖出现之前，C#中使用APM来表示异步操作。虽然这是一种上古时期的回调模式语法，但是现在有很多库仍旧支持这种风格。如Azure Storage SDK中的&lt;code>CloudTable.BeginExecute&lt;/code>等一系列函数。&lt;/p>
&lt;p>下面是一个简单的使用APM模式的代码范例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Collections.Generic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Linq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Runtime.Remoting.Messaging;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Runtime.Remoting.Proxies;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> ConsoleApplication6
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">delegate&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> AsyncInvoke();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> SI = &lt;span style="color:#66d9ef">new&lt;/span> AsyncInvoke(MyCall);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> ar = SI.BeginInvoke(MyCallback, &lt;span style="color:#66d9ef">null&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Main()&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (!ar.AsyncWaitHandle.WaitOne(&lt;span style="color:#ae81ff">1000&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Main() waiting...&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Main() done&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.ReadLine();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> MyCall()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i = &lt;span style="color:#ae81ff">0&lt;/span>; i &amp;lt; &lt;span style="color:#ae81ff">5&lt;/span>; i++)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;running...&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.Sleep(&lt;span style="color:#ae81ff">500&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;done&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> MyCallback(IAsyncResult iResult)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> result = iResult &lt;span style="color:#66d9ef">as&lt;/span> AsyncResult;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> si = (AsyncInvoke) result.AsyncDelegate;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> ret = si.EndInvoke(result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(ret);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-19/26234044-file_1484828912411_150f3.gif" alt="">&lt;/p>
&lt;p>我们可以看到：&lt;/p>
&lt;ol>
&lt;li>我们将&lt;code>MyCall()&lt;/code>“包装”在一个&lt;code>delegate&lt;/code>中，然后调用&lt;code>BeginInvoke&lt;/code>函数实现异步执行。这个delegate的执行不会阻塞main thread。&lt;/li>
&lt;li>一个异步执行的&lt;code>delegate&lt;/code>可以有一个回调，这个回调在delegate执行完后被触发。&lt;/li>
&lt;li>我们可以&amp;quot;long-polling&amp;quot;等待一个异步调用执行完。这里的“执行完”不包括条目2提到的回调（小心race condition！）。&lt;/li>
&lt;li>异步执行的结果可以通过&lt;code>delegate.EndInvoke(IAsyncResult)&lt;/code>函数获取到异步调用的结果。&lt;/li>
&lt;li>由条目3我们可以知道，在callback函数中获取异步调用的结果是最合适的。&lt;/li>
&lt;/ol>
&lt;p>所以APM风格的代码写起来非常像javascript中的回调写法，如果逻辑复杂的话，维护起来会是一个大坑。&lt;/p>
&lt;h2 id="event-asynchronous-pattern-eap">Event Asynchronous Pattern (EAP) &lt;a href="#event-asynchronous-pattern-eap" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>EAP是回调函数的另一种封装。&lt;/p>
&lt;p>我们来看下面的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Collections.Generic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.ComponentModel;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Linq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> ConsoleApplication2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">StringEventArgs&lt;/span> : EventArgs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">string&lt;/span> Content { &lt;span style="color:#66d9ef">get&lt;/span>; &lt;span style="color:#66d9ef">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Solution&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">event&lt;/span> EventHandler&amp;lt;StringEventArgs&amp;gt; _eventHandler;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> Solution()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _eventHandler += Handle1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _eventHandler += Handle2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Run()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _eventHandler?.Invoke(&lt;span style="color:#66d9ef">this&lt;/span>, &lt;span style="color:#66d9ef">new&lt;/span> StringEventArgs()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Content = &lt;span style="color:#e6db74">&amp;#34;123&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> Handle1(&lt;span style="color:#66d9ef">object&lt;/span> sender, StringEventArgs args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Handle1 &amp;#34;&lt;/span> + args.Content);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.Sleep(&lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> Handle2(&lt;span style="color:#66d9ef">object&lt;/span> sender, StringEventArgs args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Handle2 &amp;#34;&lt;/span> + args.Content);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.Sleep(&lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Solution sol = &lt;span style="color:#66d9ef">new&lt;/span> Solution();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sol.Run();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.ReadLine();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行结果如下：&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-1-20/46892581-file_1484911655343_68ae.gif" alt="">&lt;/p>
&lt;p>我们可以看出，所有的函数都执行在同一个线程上。并且&lt;code>Handle1&lt;/code>和&lt;code>Handle2&lt;/code>顺序执行。&lt;/p>
&lt;p>在实际工程中，我们fire event的代码可以在不同的线程，之后&lt;code>EventHandler&lt;/code>，也就是callback函数会被调用。&lt;/p>
&lt;p>Event同时支持&lt;code>BeginInvoke&lt;/code>和&lt;code>EndInvoke&lt;/code>函数，也就意味着我们可以异步的fire相应的回调。但是注意此时我们只能注册唯一的回调，因为&lt;code>BeginInvoke&lt;/code>只能有一个目标回调（原理：在同一时间同一线程只能有一个函数调用）。&lt;/p>
&lt;h2 id="task-asynchronous-pattern-tap">Task Asynchronous Pattern (TAP) &lt;a href="#task-asynchronous-pattern-tap" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在.NET 4.0（现在已经到6.0了哦），C#引入了TPL，Task Parallel Library。Task的目标是统一C#中的不同异步编程风格。&lt;/p>
&lt;p>TPL中的Task非常像JS中的promise和twisted中的deferred，是“未来会完成的操作的结果”的占位符。&lt;/p>
&lt;p>我们来看一段简单代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Collections.Generic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Linq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> ConsoleApplication3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Task t = Task.Run(() =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Task start&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.Sleep(&lt;span style="color:#ae81ff">2000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Task end&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (!t.IsCompleted)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Main(): Task is running...&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.Sleep(&lt;span style="color:#ae81ff">1000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.ReadLine();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码我们前面提到的APM和EAP风格的代码有明显的不同，TAP更易读，并且保持了控制流的完整性。不像APM需要在&lt;code>EndInvoke&lt;/code>函数中获取返回值以及进行后续操作，也不像EAP一样需要根据不同的event声明不同的回调。&lt;/p>
&lt;p>Task也可能“串起来”，实现多级回调的机制。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Collections.Generic;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Linq;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Text;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> System.Threading.Tasks;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">namespace&lt;/span> ConsoleApplication4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Program&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> Main(&lt;span style="color:#66d9ef">string&lt;/span>[] args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> t0 = Task.Run(() =&amp;gt; &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> t1 = t0.ContinueWith((antecedent) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(antecedent.Result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> antecedent.Result + &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> t2 = t1.ContinueWith((antecedent) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(antecedent.Result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> antecedent.Result + &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> t3 = t2.ContinueWith((antecedent) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(antecedent.Result);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> antecedent.Result + &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.ReadLine();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然我们还可以把回调写成一棵树状结构，然后一层一层的执行，不过生命是如此宝贵，我们并没有充分的理由要这么做。&lt;/p>
&lt;h2 id="asyncawait语法糖">async/await语法糖 &lt;a href="#asyncawait%e8%af%ad%e6%b3%95%e7%b3%96" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>async/await语法糖在C# 5.0中被引入，其目的是为了避免回调带来的代码复杂度。就像Twisted中的&lt;code>@inlineCallbacks&lt;/code>一样，省去了defer复杂的回调链。&lt;/p>
&lt;p>&lt;code>await&lt;/code>中有一个&amp;quot;wait&amp;quot;，说明这是一个“等待”操作。它等待的是相应的Task执行完成。&lt;/p>
&lt;p>我们来看一段代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">async&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> DumpWebPageAsync(&lt;span style="color:#66d9ef">string&lt;/span> uri)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> WebClient webClient = &lt;span style="color:#66d9ef">new&lt;/span> WebClient();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">string&lt;/span> page = &lt;span style="color:#66d9ef">await&lt;/span> webClient.DownloadStringTaskAsync(uri);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Console.WriteLine(page);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当代码执行到&lt;code>await&lt;/code>一行时，当前函数会主动放弃当前的控制流。当使用&lt;code>await&lt;/code>修饰的Task完成后，当前函数会从之前中断的地方继续执行。&lt;/p>
&lt;p>这样做的好处是我们可以写出和同步版本非常相似的异步代码，只需要在必须的地方加上&lt;code>await&lt;/code>关键字，提醒编译器这里是一个异步函数，需要额外的处理逻辑，但这一切都是对开发者透明的。&lt;/p>
&lt;h3 id="asyncawait干了什么">async/await干了什么 &lt;a href="#asyncawait%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>想弄清楚async/await到底干了什么，首先我们要想明白线程到底是什么、干了什么。&lt;/p>
&lt;p>线程是进程内一条执行流的状态，其中包括了硬件状态（IP、Registers等）以及堆栈（栈上的局部变量和堆上的进程级内存）。那么如果我们想实现挂起/启动（Hibernating and Resuming），那么我们就要有一个机制来保存当前线程的运行状态。&lt;/p>
&lt;p>所以当你写下了async/await关键字后，编译器在后面帮助你生成了状态保存和恢复运行上下文的代码。&lt;/p>
&lt;h3 id="asyncawait到底干了什么">async/await到底干了什么 &lt;a href="#asyncawait%e5%88%b0%e5%ba%95%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>想像我们有一个复杂的async函数，里面有很多个await调用，那就意味着这个函数中会有多次挂起/继续操作。同时我们还要维护这个函数的状态。如果我们是这个语法糖的设计者，我们会选择怎么样的手段来处理这个问题呢？&lt;/p>
&lt;p>是的，状态机。async/await避免了代码的碎片化，它的解决方案并不是消灭了回调函数和Continuation Tasks，而是使用工具（编译器）来帮助人类进行重复劳动。当async函数从挂起中恢复时，会调用&lt;code>MoveNext&lt;/code>函数（相信看过async函数那一长串的traceback的同学肯定对这个函数非常眼熟），&lt;code>MoveNext&lt;/code>函数会在async函数第一次被调用以及从挂起中恢复时被调用。状态机保存了当前函数的执行状态，当&lt;code>MoveNext&lt;/code>函数被调用时，会根据当前状态来判断接下来执行什么代码。&lt;/p>
&lt;h3 id="asycnawait到底tmd干了什么">asycn/await到底TMD干了什么 &lt;a href="#asycnawait%e5%88%b0%e5%ba%95tmd%e5%b9%b2%e4%ba%86%e4%bb%80%e4%b9%88" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>由于async/awaic语法糖是在编译期才被翻译成相应的程序代码，所以我们只能使用IL反编译器来窥探编译器到底做了怎样的处理与优化。不过反编译器你懂得，生成的代码基本没法看，讲解起来也会非常晦涩。&lt;/p>
&lt;p>幸好在99%的情况下，我们并不需要知道async/await是怎样被展开的。如果你确实对这个问题感兴趣，可以参考这篇文章：&lt;a href="https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine">Async Await and the Generated StateMachine&lt;/a>。&lt;/p>
&lt;h2 id="几个常见的坑">几个常见的坑 &lt;a href="#%e5%87%a0%e4%b8%aa%e5%b8%b8%e8%a7%81%e7%9a%84%e5%9d%91" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="await-与-锁">await 与 锁 &lt;a href="#await-%e4%b8%8e-%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>由于await会中断当前函数在当前线程的执行流，并且可能在恢复时，被指派到另外的线程。所以对await加锁明显是多此一举的。并且如果操作不当，还会造成死锁。&lt;/p>
&lt;p>所以我们应该把await放到加锁的区域外。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">lock&lt;/span> (sync)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Prepare for async operation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> myNum = &lt;span style="color:#66d9ef">await&lt;/span> AlexsMethodAsync();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">lock&lt;/span> (sync)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Use result of async operation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="there-is-an--unfired-task-between-us">&amp;ldquo;There is an &amp;hellip; unfired Task between us&amp;rdquo; &lt;a href="#there-is-an--unfired-task-between-us" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>一个async函数如果返回的是Task，那么它返回的一定是一个hot task，即已经被启动了的Task。&lt;/p>
&lt;p>并且await只可能等待一个启动了的Task，否则await操作将会hang住，破坏程序既定的执行流。&lt;/p>
&lt;h3 id="使用tpl-task-parallel-library">使用TPL (Task parallel library) &lt;a href="#%e4%bd%bf%e7%94%a8tpl-task-parallel-library" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>Async methods are synchronous util needed.&lt;/p>&lt;/blockquote>
&lt;p>如果我们想同时执行几个异步操作，使用for来遍历执行可不是一个好主意。因为这样函数执行流仍然是顺序执行相应的函数。&lt;/p>
&lt;p>TPL提供了&lt;code>WhenAll&lt;/code>、&lt;code>WhenAny&lt;/code>等函数，让我们可以有弹性的并发执行Task。&lt;/p>
&lt;p>当然我们还可以使用PLINQ，不过这就是另外一个话题了。&lt;/p>
&lt;h2 id="参考链接">参考链接 &lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://www.codeproject.com/Articles/535635/Async-Await-and-the-Generated-StateMachine">Async Await and the Generated StateMachine&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.stephencleary.com/2012/07/async-interop-with-iasyncresult.html">Async Interop with IAsyncResult&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://msdn.microsoft.com/en-us/library/wewwczdw(v=vs.110).aspx">Event-based Asynchronous Pattern Overview&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.safaribooksonline.com/library/view/async-in-c/9781449337155/">Async in C# 5.0&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.safaribooksonline.com/library/view/essential-c-60/9780134176147/">Essential C# 6.0&lt;/a> Cpt18&lt;/li>
&lt;/ul></description></item><item><title>内存屏障初探</title><link>https://wizmann.top/posts/read-paper-barrier/</link><pubDate>Thu, 08 May 2014 19:05:26 +0000</pubDate><guid>https://wizmann.top/posts/read-paper-barrier/</guid><description>&lt;h2 id="原文地址">原文地址 &lt;a href="#%e5%8e%9f%e6%96%87%e5%9c%b0%e5%9d%80" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;a href="http://ridiculousfish.com/blog/posts/barrier.html">Barrier February 17th, 2007&lt;/a>&lt;/p>
&lt;h2 id="前言多核时代的挑战">前言：多核时代的挑战 &lt;a href="#%e5%89%8d%e8%a8%80%e5%a4%9a%e6%a0%b8%e6%97%b6%e4%bb%a3%e7%9a%84%e6%8c%91%e6%88%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。&lt;/p>
&lt;h2 id="线程技术探讨">线程技术探讨 &lt;a href="#%e7%ba%bf%e7%a8%8b%e6%8a%80%e6%9c%af%e6%8e%a2%e8%ae%a8" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="名词解释">名词解释 &lt;a href="#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="线程">线程 &lt;a href="#%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>线程是一种拥有共享地址空间的、能被抢占式调度的执行上下文。&lt;/p>
&lt;h4 id="多线程">多线程 &lt;a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>多线程是一种用于简化控制流、绕过阻塞系统调用的方法，并不专门用于实现程序的并行化。&lt;/p>
&lt;h4 id="并发多线程">并发多线程 &lt;a href="#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>物理上并行执行的线程，旨在通过利用多核处理器优化系统性能。&lt;/p>
&lt;h3 id="并发多线程的挑战">“并发多线程”的挑战 &lt;a href="#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%8c%91%e6%88%98" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>尽管并发多线程被广泛讨论，其挑战并非源自自然原因，而是我们自己的设计选择所造成的。主要问题在于，针对单线程程序的过度优化在多线程环境中不再适用。&lt;/p>
&lt;p>具体来说，由于CPU的执行速度远超内存响应速度，我们开始对内存内容进行“预测”，从而避免CPU等待内存检查。这里的“预测”实际上是CPU和编译器对内存状态做出的越来越激进的假设。&lt;/p>
&lt;h2 id="示例分析">示例分析 &lt;a href="#%e7%a4%ba%e4%be%8b%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="写线程示例">写线程示例 &lt;a href="#%e5%86%99%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初始时 variable1 = variable2 = 0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable2&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="读线程示例">读线程示例 &lt;a href="#%e8%af%bb%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local2 &lt;span style="color:#f92672">=&lt;/span> variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (local2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> local1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Error!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正常逻辑下，local2 应当始终小于或等于 local1，因为 variable1 总是在 variable2 之后增加。&lt;/p>
&lt;p>然而，现实是否如此？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;ctime&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> variable1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> variable2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ITERATIONS 200000000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">writer&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1 &lt;span style="color:#f92672">=&lt;/span> variable1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable2 &lt;span style="color:#f92672">=&lt;/span> variable2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reader&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">timeval&lt;/span> start, end;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gettimeofday(&lt;span style="color:#f92672">&amp;amp;&lt;/span>start, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> i, failureCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> ITERATIONS; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v2 &lt;span style="color:#f92672">=&lt;/span> variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> v1) failureCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gettimeofday(&lt;span style="color:#f92672">&amp;amp;&lt;/span>end, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> seconds &lt;span style="color:#f92672">=&lt;/span> end.tv_sec &lt;span style="color:#f92672">+&lt;/span> end.tv_usec &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">1000000.&lt;/span> &lt;span style="color:#f92672">-&lt;/span> start.tv_sec &lt;span style="color:#f92672">-&lt;/span> start.tv_usec &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">1000000.&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%u failure%s (%2.1f percent of the time) in %2.1f seconds&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failureCount, failureCount &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;s&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">100.&lt;/span> &lt;span style="color:#f92672">*&lt;/span> failureCount) &lt;span style="color:#f92672">/&lt;/span> ITERATIONS, seconds);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_t thread1, thread2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>thread1, NULL, writer, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>thread2, NULL, reader, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) sleep(&lt;span style="color:#ae81ff">1000000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;code>0 failures (0.0 percent of the time) in 1.2 seconds&lt;/code>&lt;/p>
&lt;h3 id="貌似是正确的">貌似是正确的？ &lt;a href="#%e8%b2%8c%e4%bc%bc%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>程序运行的正如我们预期的那样，那么我们可以确信程序是一定正确的吗？&lt;/p>
&lt;p>不能。&lt;/p>
&lt;p>因为程序中的两个线程如果在同一个CPU上被调度，我们永远都会得到正确的结果。&lt;/p>
&lt;h3 id="线程与不同的cpu进行绑定">线程与不同的CPU进行绑定 &lt;a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e4%b8%8d%e5%90%8c%e7%9a%84cpu%e8%bf%9b%e8%a1%8c%e7%bb%91%e5%ae%9a" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">writer&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu_set_t cpuset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sched_setaffinity(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cpuset), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reader&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu_set_t cpuset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sched_setaffinity(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cpuset), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// p.s. 我机器是i5双核四线程，所以绑在了CPU0和CPU2上
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果：&lt;code>0 failures (0.0 percent of the time) in 1.4 seconds&lt;/code>&lt;/p>
&lt;h3 id="似乎仍然是准确的">似乎仍然是准确的 &lt;a href="#%e4%bc%bc%e4%b9%8e%e4%bb%8d%e7%84%b6%e6%98%af%e5%87%86%e7%a1%ae%e7%9a%84" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>尽管如此，我们考虑到CPU对变量的操作其实是作用在寄存器上，而variable1和variable2紧密相邻，这可能导致它们位于缓存的同一行。因此，它们有可能会同时被写入缓存并一起写回内存。&lt;/p>
&lt;p>为了观察不同的效果，我们尝试将这两个变量分别放置在堆和栈上。&lt;/p>
&lt;pre tabindex="0">&lt;code>0 failures (0.0 percent of the time) in 1.2 seconds
0 failures (0.0 percent of the time) in 1.2 seconds
2000000000 failures (100.0 percent of the time) in 1.2 seconds
&lt;/code>&lt;/pre>&lt;p>&lt;strong>太感人了！&lt;/strong>&lt;/p>
&lt;h3 id="我们的敌人--编译器">我们的敌人 —— 编译器 &lt;a href="#%e6%88%91%e4%bb%ac%e7%9a%84%e6%95%8c%e4%ba%ba--%e7%bc%96%e8%af%91%e5%99%a8" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>Multithreading bugs are very delicate.&lt;/p>&lt;/blockquote>
&lt;p>并行多线程的错误总是那么的奇妙，也许你的程序运行了几天安然无恙，但是在某一天某一时突然出现了难以复现的精妙bug。&lt;/p>
&lt;p>如果多个线程调度在同一个CPU核心上，Bug会被掩盖。 &lt;br>
如果多个变量在CPU同一行Cache上，Bug会被掩盖。 &lt;br>
如果你人品足够好的话，Bug同样会被掩盖。&lt;/p>
&lt;p>但是，如果我们排除了以上的情况后，问题就浮现出来了。&lt;/p>
&lt;p>我们来看一看reader的反汇编代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>(gdb) disas reader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> function reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400950&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> push &lt;span style="color:#f92672">%&lt;/span>rbx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400951&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>eax,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400953&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x10&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400958&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x80&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040095d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040095f&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0xa0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>rsp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400966&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">22&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>rsp,&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400969&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">25&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>rsp,&lt;span style="color:#f92672">%&lt;/span>rdx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040096c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">28&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> rep stos &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>es:(&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040096f&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">31&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>edi,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400971&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">33&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> movq &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x4&lt;/span>,(&lt;span style="color:#f92672">%&lt;/span>rsp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400979&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">41&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400790&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sched_setaffinity&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040097e&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">46&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> lea &lt;span style="color:#ae81ff">0x80&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400986&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">54&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>esi,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400988&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">56&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400710&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>gettimeofday&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040098d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">61&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e4&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>rax &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601078&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable2_p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400994&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">68&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e6&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>edx &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601080&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable1&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040099a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">74&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov (&lt;span style="color:#f92672">%&lt;/span>rax),&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040099c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">76&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x77359400&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009a1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">81&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> nopl &lt;span style="color:#ae81ff">0x0&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#f92672">%&lt;/span>ecx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009aa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> adc &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ad&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">93&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009b0&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">96&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> jne &lt;span style="color:#ae81ff">0x4009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009b2&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">98&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> lea &lt;span style="color:#ae81ff">0x90&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ba&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">106&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>esi,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009bc&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">108&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400710&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>gettimeofday&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009c1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">113&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x98&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009cb&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">123&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x90&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009d5&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">133&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> movsd &lt;span style="color:#ae81ff">0x1a3&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm3 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009dd&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">141&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009df&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">143&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x88&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009e9&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">153&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ec&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">156&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b3d&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009f1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">161&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009f6&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">166&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#f92672">%&lt;/span>xmm3,&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009fa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">170&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009fc&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">172&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b40&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a01&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">177&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#f92672">%&lt;/span>xmm3,&lt;span style="color:#f92672">%&lt;/span>xmm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a05&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">181&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> addsd &lt;span style="color:#f92672">%&lt;/span>xmm0,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a09&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">185&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x80&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a13&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">195&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> subsd &lt;span style="color:#f92672">%&lt;/span>xmm0,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a17&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">199&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sd &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a1c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">204&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b3c&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a21&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">209&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmovne &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>rcx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a25&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">213&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x2&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a2a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">218&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mulsd &lt;span style="color:#ae81ff">0x156&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm0 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a32&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">226&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> subsd &lt;span style="color:#f92672">%&lt;/span>xmm2,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a36&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">230&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#ae81ff">0x152&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm0 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a3e&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">238&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400700&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>__printf_chk&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a43&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">243&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>edi,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a45&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">245&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x4006f0&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>exit&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简而言之，关键在以下几句：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040098d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">61&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e4&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>rax &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601078&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable2_p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x0000000000400994&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">68&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e6&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>edx &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601080&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable1&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040099a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">74&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov (&lt;span style="color:#f92672">%&lt;/span>rax),&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040099c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">76&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x77359400&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009a1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">81&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> nopl &lt;span style="color:#ae81ff">0x0&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#f92672">%&lt;/span>ecx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009aa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> adc &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009ad&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">93&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009b0&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">96&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> jne &lt;span style="color:#ae81ff">0x4009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看出，循环体在+88～+96行，而对variable1与variable2的取值都放在了循环以外。&lt;/p>
&lt;blockquote>
&lt;p>注：&lt;br>
adc是带进位加法，adc $0x0, %ebx =&amp;gt; %ebx = $0x0 + %ebx + CF &lt;br>
cmp的结果正是放在CF（大于表示为溢出），ZF（相等表示为0），PF（小于表示为-1,则低8位全为1,故有偶数个1）&lt;/p>&lt;/blockquote>
&lt;p>正是这个“小意外”，导致了我们的结果要不是100%正确，要不是100%错误。&lt;/p>
&lt;h4 id="使用volitile">使用volitile（？） &lt;a href="#%e4%bd%bf%e7%94%a8volitile" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>让我们修改一下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> variable1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2_p &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ITERATIONS 500000000LL &lt;/span>&lt;span style="color:#75715e">// 调小一下数据规模，因为volatile太慢了_(:з」∠)_
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我得出的来的结果是：&lt;/p>
&lt;pre tabindex="0">&lt;code>0 failures (0.0 percent of the time) in 9.6 seconds
&lt;/code>&lt;/pre>&lt;p>而作者得出的结果是：
（时间上的差异不计，因为我们的数据规模不一样，我实验的次数要多一些。&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
12462711 failures (24.9 percent of the time) in 3.7 seconds
&lt;/code>&lt;/pre>&lt;p>从作者的结果来看，看起来效果好了很多，虽然慢了30多倍，但是结果并不是全对全错了。&lt;/p>
&lt;p>而从我的结果来看，volatile看似神丹妙药，解决了所有的问题。(both g++ and clang++)&lt;/p>
&lt;p>&lt;strong>这是为什么呢?&lt;/strong>&lt;/p>
&lt;p>其原因在于体系结构的差异。volatile只能保证如下两点：&lt;/p>
&lt;ul>
&lt;li>volatile变量的访问不会优化成寄存器访问，而是每次都去访问“内存”（这个引号一会再解释）&lt;/li>
&lt;li>volatile变量间的访问顺序不会被编译器乱序&lt;/li>
&lt;/ul>
&lt;p>而其他的一切，volatile和编译器都不会给出任何保证。&lt;/p>
&lt;p>例如，不同的CPU都有其内部的私有Cache，CPU的内存访问，如果命中了Cache，则不会真正的访问内存。但由于其私有Cache对于其它的CPU是不可见的，使用volatile就埋下的Bug的种子。&lt;/p>
&lt;p>虽然在我们的实验中，程序运行的很好，没有出现Bug。但是，一是由于多线程的Bug都是subtle和delicate的，我不能保证在一个需要7x24工作的服务器程序中，它不会出现任何Bug；二是至少我们的代码是** not portable **的，如果有一天，我们从x86-64平台切换到了&lt;code>PowerPC&lt;/code>？或是&lt;code>IA64&lt;/code>？我们不能保证在这些体系结构上，编译器和CPU能为我们提供同样的保障。&lt;/p>
&lt;p>于是有人高声疾呼： volatile不能用来做为多线程的同步机制！&lt;/p>
&lt;blockquote>
&lt;p>补充于20240317：在一台老旧的安卓手机上重复了实验，volatile确实无法提供相关的保障&lt;/p>&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>~/tmp $ clang++ -O2 a.cc &amp;amp;&amp;amp; ./a.out
99880586 failures (49.9 percent of the time) in 3.0 seconds
&lt;/code>&lt;/pre>&lt;h4 id="小心cpu的行为">小心CPU的行为 &lt;a href="#%e5%b0%8f%e5%bf%83cpu%e7%9a%84%e8%a1%8c%e4%b8%ba" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在先前的实验中，尽管程序的表现与预期一致，但我们无法确保CPU将始终按顺序执行代码。实际上，CPU可能会对操作顺序进行优化，例如，将var1++和var2++的执行顺序调换，这在当前主流的CPU中是常见的做法。&lt;/p>
&lt;p>值得注意的是，由于乱序执行会导致功耗增加，某些处理器如ARM和Intel Atom已经取消了这一机制。然而，我们无法预知未来代码可能会在哪种硬件架构上运行，例如ARM集群，这需要我们保持警惕。&lt;/p>
&lt;h4 id="避免使用锁">避免使用锁 &lt;a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>通常情况下，通过引入互斥锁（mutex）似乎能够解决并发问题。然而，根据作者的测试，引入互斥锁可能会导致程序速度降低至原来的1/130，而自旋锁（spinlock）也可能使得速度降低至原来的1/4。&lt;/p>
&lt;p>因此，我们应该暂缓，仔细考虑作者接下来的建议。&lt;/p>
&lt;h3 id="内存屏障的应用">内存屏障的应用 &lt;a href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c%e7%9a%84%e5%ba%94%e7%94%a8" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在多CPU环境中，处理器往往独立运行，不会协调彼此的操作。&lt;/p>
&lt;p>目前，我们面临两个并不理想的解决方案：一是将所有线程限制在单个CPU上运行，二是通过引入重量级锁来同步操作。这些方法都不尽人意，且效率低下。&lt;/p>
&lt;p>实际上，我们需要做的是，通过内存屏障技术，暂时阻止编译器或CPU对程序中的数据读写操作进行重排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1 &lt;span style="color:#f92672">=&lt;/span> variable1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> barrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>variable2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们保证了，在var1++必然早于var2++。var2++后面也可以加一道barrier，只不过在我们的场景下，提供这种保证是不必须的。&lt;/p>
&lt;p>作者又做了一次试验。&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
260 failures (0.0 percent of the time) in 0.9 seconds
&lt;/code>&lt;/pre>&lt;p>这次且错误减少了许多。&lt;/p>
&lt;p>我们再把读线程写加上memory barrier.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> ITERATIONS; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> barrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> v1) failureCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看看结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
0 failures (0.0 percent of the time) in 4.2 seconds
&lt;/code>&lt;/pre>&lt;p>程序表现出了正确的结果。&lt;/p>
&lt;p>我们可以看出，如果你对线程A的读写顺序做出要求，必然的，你也要对线程B的顺序做要求，以此类推，线程C，线程D……&lt;/p>
&lt;p>所以，&lt;strong>Memory barriers always come in pairs, or triplets or more.&lt;/strong>&lt;/p>
&lt;p>同样的，线程锁也是这样的，自己锁自己总不是一种愉快的体验（笑&lt;/p>
&lt;h3 id="cpu的乱序执行">CPU的乱序执行 &lt;a href="#cpu%e7%9a%84%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们可以看到PowerPC有三种内存屏障，而DEC Alpha平台有更多。这意味着，CPU使用更激进的策略来重排指令，而强制限制其重排的代价是非常高的。&lt;/p>
&lt;p>而x86平台则非常守序，作者猜测其原因是由于早期x86的指令技术并非完善，而在那时内存与CPU的速度不像现在这样悬殊，所以x86使用了&lt;code>strongly ordered memory&lt;/code>而非像上面几款CPU一样的采用过多的指令重排序。如今，由于x86背上了向前兼容性的包袱，看似我们的&amp;quot;好日子&amp;quot;一直不会结束。&lt;/p>
&lt;p>x86-64，做为x86的64位升级版，同样没有实现&lt;code>weakly ordered&lt;/code>，或者说，保留了实现&lt;code>weakly ordered&lt;/code>的权利。而&lt;code>IA64&lt;/code>平台，如&lt;code>Itanium&lt;/code>，则实现了&lt;code>weakly ordered&lt;/code>。&lt;/p>
&lt;p>作者猜测x86_64之所以保守，是为了与IA64平台对抗。x86_64的对于x86良好的兼容性可以让程序员多活几年，所以x86_64在市场的表现更好。&lt;/p>
&lt;p>作者还表示，而苹果放弃IA64平台转投x86-64多少有一些可惜，因为苹果并没有移植性问题，PowerPC已经逐渐衰落，为什么不试试IA64呢。&lt;/p>
&lt;p>实际上，根据Wikipedia，现在支持IA64的操作系统非常少，只有WinNT Family，Red Hat Linux，Debian/Gentoo/Suse以及其它。而从Windows Server 2008 R2之后，Microsoft也表示不再支持Itanium。所以从现在看来，IA64平台相对x86/x64来说，是失败的。&lt;/p>
&lt;h3 id="双重检查锁">双重检查锁 &lt;a href="#%e5%8f%8c%e9%87%8d%e6%a3%80%e6%9f%a5%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>让我们看一下如下的Obj-C代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-objc" data-lang="objc">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是非常经典的一种DCLP(Double Checked Lock Pattern)的实现。&lt;/p>
&lt;p>这个看起来不错，但是你已经知道这并不靠谱了。当我们初始化我们的共享单例，先要再修改类内的指针，使其指向一块声明好的内存，再初始化一个sharedObject的instance。&lt;/p>
&lt;p>不过，你是知道的，CPU和编译器会把一切都搞砸，它们会以任意的顺序执行我们的命令，同时处理器之间互相不通气，于是就会出现如下的情况：&lt;/p>
&lt;p>线程A为指针声明了一段空间，但是还没来及初始化这个instance，线程A就被挂起了。&lt;/p>
&lt;p>之后线程B接管一切，发现指针有值，结果因为访问了野指针导致程序挂掉。&lt;/p>
&lt;p>不过根据上面的文章，你们应该知道怎么处理这个问题了 —— 试试内存屏障！&lt;/p>
&lt;p>p.s. 如果大家对obj-c不熟悉的话，可以看我另外一篇文章。那篇文章是关于Scott Meyers大神写的一篇论文，专门用来讨论DCLP问题的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-objc" data-lang="objc">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">id&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而在《C++ and the Perils of Double-Checked Locking》一文中，Scott Meyers和Andrei Alexandrescu给出的解决方案如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>instance () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Singleton&lt;span style="color:#f92672">*&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// insert memory barrier
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// clear the cache to flush ``pInstance``
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevents &amp;#34;downwards migration&amp;#34; of Singleton’s construction (by another thread);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (tmp &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Lock lock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tmp &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// insert memory barrier
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevent optimistic that eliminate the temporary variable ``tmp``
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevents &amp;#34;upwards migration&amp;#34; of pInstance’s initialization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pInstance &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>两种解决方案的memory barrier插入的位置不同。但是都不能说是错的。因为一个是传static instance，一个是传pointer。&lt;/p>
&lt;p>其实还有更“暴力”的方法。&lt;/p>
&lt;p>直接来一把大锁，哐当把整个函数锁起来，并且在每一个线程内保留一个&lt;strong>本线程专属&lt;/strong>指向单例的指针（做cache）。这样N个线程只需要调用这个函数N次，线程竞争也相对少很多。并且根据Linux下的futex技术，无竞争下的锁相对节省了不少资源。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>instance() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Lock lock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(pInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="我们真的需要这么做吗">我们真的需要这么做吗 &lt;a href="#%e6%88%91%e4%bb%ac%e7%9c%9f%e7%9a%84%e9%9c%80%e8%a6%81%e8%bf%99%e4%b9%88%e5%81%9a%e5%90%97" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>上面的obj-c代码中，保证双重检查锁正确的，其实是第二个内存屏障。但是，在那里，我们需要的其实是一个&amp;quot;data dependency barrier&amp;quot;。&lt;/p>
&lt;p>Linux内核中给出很多经过精心优化的内存屏障，我们在这里可以使用。不过，要在使用的时候写好注释，一是为了未来的验证，二是为了记录自己当时的思路。&lt;/p>
&lt;p>毕竟多线程的操作要小心再小心，我们需要充足的理由，更多的小心来应对。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-obj-c" data-lang="obj-c">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">id&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* data dependency memory barrier here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="一切都结束了吗">一切都结束了吗？ &lt;a href="#%e4%b8%80%e5%88%87%e9%83%bd%e7%bb%93%e6%9d%9f%e4%ba%86%e5%90%97" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>是的。不过让我们总结一下吧。&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-tk-pic/barrier_tank.png" alt="Mutex Tank">&lt;/p>
&lt;ul>
&lt;li>处理器和编译器并不能充分保证代码执行的顺序，它们会把你的代码到处移动。所以&lt;strong>Be warned and wary!&lt;/strong>&lt;/li>
&lt;li>多线程的错误是非常subtle和delicate的，所以我们很难设计测试用例&lt;/li>
&lt;li>因此，别指责QA了，他们也不是故意的。RD要对自己的代码负责&lt;/li>
&lt;li>锁很安全，但是也很重&lt;/li>
&lt;li>内存屏障是一种更快的，不阻塞的，不会死锁的一种锁的替代物。它们总要花费更多的心思，并且也不是到处可用的银弹。但是它确实很快，有更好的伸缩性。&lt;/li>
&lt;li>内存屏障往往是成对出现的。了解第二个内存屏障要出现在哪里，有助于你理解你的代码，即使你所使用的体系结构不需要第二个内存屏障。&lt;/li>
&lt;/ul>
&lt;h3 id="扩展阅读">扩展阅读 &lt;a href="#%e6%89%a9%e5%b1%95%e9%98%85%e8%af%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.8112">Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors&lt;/a>&lt;/p></description></item></channel></rss>