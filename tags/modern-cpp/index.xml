<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Modern Cpp on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/modern-cpp/</link><description>Recent content in Modern Cpp on Maerlyn's Rainbow</description><generator>Hugo -- 0.146.0</generator><language>zh-CN</language><lastBuildDate>Tue, 21 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/modern-cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</title><link>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</guid><description>&lt;p>智能指针（如 &lt;code>std::shared_ptr&lt;/code> 和 &lt;code>std::weak_ptr&lt;/code>）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 &lt;code>boost::shared_ptr&lt;/code> 和 &lt;code>boost::weak_ptr&lt;/code>，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。&lt;/p></description></item><item><title>std::visit实现运行时多态 - C++ for the Antiquated（之三）</title><link>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</guid><description>&lt;p>在传统的 &lt;strong>C++&lt;/strong> 中，&lt;strong>运行时多态&lt;/strong> 通常依赖于 &lt;strong>“接口 - 虚函数”&lt;/strong> 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 &lt;strong>子类型多态&lt;/strong>（&lt;em>Subtype Polymorphism&lt;/em>）。&lt;/p></description></item><item><title>动手实现std::visit - C++ for the Antiquated（之二）</title><link>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</link><pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</guid><description>&lt;h2 id="stdvariant-与-stdvisit">std::variant 与 std::visit&lt;/h2>
&lt;h3 id="stdvariant">std::variant&lt;/h3>
&lt;p>&lt;code>std::variant&lt;/code> 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 &lt;code>union&lt;/code> 不同，&lt;code>std::variant&lt;/code> 能够在运行时安全地检查当前存储的类型，避免未定义行为。&lt;/p></description></item><item><title>constexpr详解 - C++ for the Antiquated（之一）</title><link>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</guid><description>&lt;p>在这篇文章中，我们将深入讨论 C++ 中的常量表达式（&lt;code>constexpr&lt;/code>）及其与传统的&lt;code>const&lt;/code>常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨&lt;code>constexpr&lt;/code>函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。&lt;/p></description></item></channel></rss>