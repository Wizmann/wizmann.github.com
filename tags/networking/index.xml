<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Networking on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/networking/</link><description>Recent content in Networking on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 17 Aug 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/networking/index.xml" rel="self" type="application/rss+xml"/><item><title>浅淡TCP BBR</title><link>https://wizmann.top/posts/bbr-intro/</link><pubDate>Tue, 17 Aug 2021 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/bbr-intro/</guid><description>&lt;h2 id="背景">背景 &lt;a href="#%e8%83%8c%e6%99%af" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在一对跨地域的机器（美国&amp;lt;-&amp;gt;香港），使用TCP（Cubic拥塞控制算法）通信throughput最高2MB/s，丢包率0.02%。使用UDP通信throughput最高能达到140MB/s。&lt;/p>
&lt;p>这是一个非常典型的长肥管道（LFN），并且丢包率比较高。尝试使用BBR算法后，throughput可达50MB/s+（Windows系统，通信协议使用用户态MsQuic）。&lt;/p>
&lt;h2 id="loss-based-congestion-control-algorithm">Loss-based Congestion Control Algorithm &lt;a href="#loss-based-congestion-control-algorithm" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>Reno和Cubic是比较经典的，用于TCP的拥塞控制算法。这一类算法使用的是基于丢包反馈的思想，即一旦产生了丢包，就认为链路上产生了拥塞。先将拥塞窗口减半，再进入快速恢复模式。&lt;/p>
&lt;p>在快速恢复完成后中，就又会重新进入拥塞避免阶段。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/21-08-16/2021-08-16_23-07-29.png" alt="TCP-Reno-Cubic">&lt;/p>
&lt;p>Reno当收到一个ACK包时，会将拥塞窗口增大一个MSS，窗口大小线性增长。而Cubic使用的是一个基于上次拥塞事件产生时间的三次函数，所以拥塞窗口能更快速的恢复到拥塞事件发生之前的大小。&lt;/p>
&lt;p>但无论是Reno还是Cubic，在遭遇高丢包率的时候，其拥塞控制窗口的大小会一直处于一个非常小的状态。&lt;/p>
&lt;p>在RTT较大时，拥塞窗口的大小增长速度更加缓慢，使得带宽利用率长时间维持在一个较低的状态。&lt;/p>
&lt;p>下图为Cubic在有丢包（0.002%, 0.02%, 0.2%, 1%, 2%），高延时（200ms RTT）的网络条件下throughput数据。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/21-08-17/2021-08-17_00-18-45.png" alt="cubic-bandwidth">&lt;/p>
&lt;h2 id="bbr---congestion-based-congestion-control">BBR - Congestion-based Congestion Control &lt;a href="#bbr---congestion-based-congestion-control" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>不同于Reno和Cubic，BBR并没有使用“丢包”做为拥塞产生的信号，而是构建了一个反馈系统，通过时延的变化来确定链路上是否发生了拥塞。&lt;/p>
&lt;h3 id="拥塞产生的三个阶段">拥塞产生的三个阶段 &lt;a href="#%e6%8b%a5%e5%a1%9e%e4%ba%a7%e7%94%9f%e7%9a%84%e4%b8%89%e4%b8%aa%e9%98%b6%e6%ae%b5" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/21-08-17/2021-08-17_00-58-34.png" alt="BBR-3-stages">&lt;/p>
&lt;ul>
&lt;li>
&lt;p>App Limited 应用限制阶段 &lt;br>
在此阶段，数据传输速率由用户程序决定。用户程序并没有利用所有的带宽，RTT维持稳定&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Bandwidth Limited 带宽限制阶段 &lt;br>
在此阶段，数据传输速率由链路带宽所决定，有效吞吐量等于链路带宽。但由于链路缓存的存在，发送端的发送速率可以略大于链路带宽。此时数据开始在链路缓存上堆积，RTT增加&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Buffer Limited 缓冲区限制阶段 &lt;br>
当链路缓存无法容纳所有的数据包时，就会产生丢包&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Loss-based拥塞控制算法会在阶段3的时候产生“拥塞”信号，但是此时大概率为时已晚。因为链路缓存堆积的数据已经开始影响RTT，并且各个节点之间的缓存大小差异，还会导致短时间内的持续丢包，使得拥塞窗口大小急剧减小。&lt;/p>
&lt;p>而BBR会将拥塞控制在阶段1和阶段2的交界处，这样可以最大化利用带宽，并且使得链路时延最小。&lt;/p>
&lt;h3 id="确定拥塞窗口的大小">确定拥塞窗口的大小 &lt;a href="#%e7%a1%ae%e5%ae%9a%e6%8b%a5%e5%a1%9e%e7%aa%97%e5%8f%a3%e7%9a%84%e5%a4%a7%e5%b0%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>从理论上分析，要使一条连接同时保持最高throughput和最小的延迟，那么其发送速率一定等于网络带宽。此时，在途的数据大小BDP = BtlBw × RTprop，就可以用满链路的带宽而不产生拥塞。&lt;/p>
&lt;p>BDP意为“带宽时延乘积”。而BtlBw意为“瓶颈带宽”，即为整条链路中，带宽最小的部分。RTprop意为“链路固有传输延迟”。&lt;/p>
&lt;blockquote>
&lt;p>RTT（往返时延）与RTprop（链路固有传输延迟）的区别是：RTT包括了收发两端应用层的时延，而RTprop只包含网络传播的时延&lt;/p>&lt;/blockquote>
&lt;p>不凑巧的是，在通信中我们几乎无法直接确定BtlBw和RTprop。BBR建立了一个模型来对其进行估计。公式如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/21-08-17/2021-08-17_10-02-28.png" alt="rtprop-hat">&lt;/p>
&lt;p>η代表的是网络队列的抖动、接收方ACK时延等等。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/21-08-17/2021-08-17_10-04-06.png" alt="btlbw-hat">&lt;/p>
&lt;p>但是，时延与带宽无法同时探测。因为探测时延时，我们必然要减慢发包速度，排空队列避免拥塞；而探测带宽时，我们需要尽量占满带宽，以检测ACK速率是否发生变化。所以时延与带宽的探测需要交替进行。&lt;/p>
&lt;h4 id="probertt---时延探测">ProbeRTT - 时延探测 &lt;a href="#probertt---%e6%97%b6%e5%bb%b6%e6%8e%a2%e6%b5%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>BBR每10秒钟会进入时延探测状态。在此状态下，BBR会限制拥塞窗口的大小到4个MSS（&lt;a href="https://blog.csdn.net/dog250/article/details/72042516">为什么？&lt;/a>）。当收到ACK包后，会更新MinRTT的取样值。&lt;/p>
&lt;h4 id="probebw---带宽探测">ProbeBW - 带宽探测 &lt;a href="#probebw---%e5%b8%a6%e5%ae%bd%e6%8e%a2%e6%b5%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>BBR大部分时间都会处于ProbeBW状态。&lt;/p>
&lt;p>BBR通过计算包的发送时间与收到ACK时间的差来确定带宽，使用“送达速度”来拟合带宽。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/6b0dcc0d2f7b2446ea0c3ca6faec29da6f28dc7e/wizmann-pic/21-08-17/image.png" alt="bw-probe-pacing">&lt;/p>
&lt;p>同时，BBR会采用gain cycle来随机微调（+25%, -25%, 不变）发送速率，以实时检测链路上带宽的变化。（图中的绿线看起来像心电图的部分）&lt;/p>
&lt;h3 id="性能比较">性能比较 &lt;a href="#%e6%80%a7%e8%83%bd%e6%af%94%e8%be%83" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>这里是Cubic与BBR在有丢包（0.002%, 0.02%, 0.2%, 1%, 2%），高延时（200ms RTT）的网络条件下的throughput对比。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/8a78e8e7c7193f4bf5d6de01997f21491f3794ab/wizmann-pic/21-08-17/Snipaste_2021-08-17_14-54-21.png" alt="perf-bbr-cubic">&lt;/p>
&lt;h2 id="杂项">杂项 &lt;a href="#%e6%9d%82%e9%a1%b9" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在Linux系统下，可以使用tc命令模拟不同的网络状态。&lt;/p>
&lt;p>例如100ms延迟（RTT=2*延迟），1%丢包率：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo tc qdisc add dev lo root handle 1:0 netem delay 100msec loss 1%
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Windows下可以使用&lt;a href="http://jagt.github.io/clumsy/">Clumsy&lt;/a>进行模拟，但是有怀疑其会严重影响网络性能，效果有待进一步测试。&lt;/p>
&lt;p>在Linux系统下，可以使用以下命令替换系统congestion control算法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>sudo sysctl -w net.ipv4.tcp_congestion_control&lt;span style="color:#f92672">=&lt;/span>cubic
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo sysctl -w net.ipv4.tcp_congestion_control&lt;span style="color:#f92672">=&lt;/span>bbr
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="references">References &lt;a href="#references" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://juejin.cn/post/6844904065759969287">浅谈TCP/IP传输层TCP BBR算法&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/CUBIC_TCP">CUBIC TCP&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://queue.acm.org/detail.cfm?id=3022184">BBR: Congestion-Based Congestion Control&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/facebookincubator/mvfst">facebookincubator/mvfst&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.csdn.net/dog250/article/details/72042516">使用TCP时序图解释BBR拥塞控制算法的几个细节&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>STUP - the Implementation (3)</title><link>https://wizmann.top/posts/stup-3/</link><pubDate>Mon, 08 May 2017 22:15:58 +0000</pubDate><guid>https://wizmann.top/posts/stup-3/</guid><description>&lt;h2 id="throughput-and-window-size">throughput and window size &lt;a href="#throughput-and-window-size" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>The wisdom of STUP protocol is all about the window size. The throughput of a TCP communication is limited by two windows: the congestion window and the receive window. The congestion window can determine how many bytes that can be send a simple piece of time, and the receive window indicates the capacity of the receiver to process data.&lt;/p>
&lt;p>Both windows influence the throughput of our connection. As the size of receive window is already set after 3-way handshake process, the congestion window is the critical influence. But why?&lt;/p>
&lt;p>TCP use congestion control to achieve high performance (really?) and avoid congestion collapse. But here in STUP, we have different situations.&lt;/p>
&lt;p>Firstly, we need real high performance. We don&amp;rsquo;t want the window size cut into half when there is a lost / timeout packet, which is very normal in our &amp;ldquo;long thin pipe&amp;rdquo;. Secondly, STUP is not a protocol for general usage, by the initial design, it should be used in an exclusive, non-production environment. So we don&amp;rsquo;t need to care about our neighbors, we can just use up a reserved, reasonable bandwidth.&lt;/p>
&lt;p>However, be aware of the number in &lt;code>Config.py&lt;/code>. Our router was down once because of a wrong configuration. :)&lt;/p>
&lt;h2 id="other-mechanisms-and-algorithms-in-stup">other mechanisms and algorithms in STUP &lt;a href="#other-mechanisms-and-algorithms-in-stup" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>Keep Alive&lt;/li>
&lt;li>Nagle algorithm&lt;/li>
&lt;li>Piggybacking&lt;/li>
&lt;li>Fast retransmission&lt;/li>
&lt;/ul>
&lt;p>These features are copied from TCP protocol and absolutely a cliché to have a discuss here. If you have any problem about these, just look it up in Wikipedia.&lt;/p>
&lt;h2 id="twisted-twisted-framework">twisted Twisted Framework &lt;a href="#twisted-twisted-framework" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>STUP protocol takes me about a whole year to do the development work (and it&amp;rsquo;s not finished yet). But for more than half of the time, I was struggling with the Twisted framework. For people who want to learn more about Twisted Framework, you can read the &lt;a href="http://twistedmatrix.com/trac/wiki/Documentation">official manual&lt;/a> or look through &lt;a href="https://wizmann.top/twisted-defer-and-deferredqueue.html">this blog&lt;/a> for a quick start.&lt;/p>
&lt;p>What a pun!&lt;/p>
&lt;h2 id="future-of-stup">future of STUP &lt;a href="#future-of-stup" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>Since STUP protocol is written in Python, one of the main problem is the performance. As a result, I&amp;rsquo;m planning to rewrite this with C++ (and golang, perhaps) to gain a better performance. I call it: STUPP (STUP in cpp).&lt;/p>
&lt;p>In STUPP, several features are to be added:&lt;/p>
&lt;ul>
&lt;li>Selective ACK&lt;/li>
&lt;li>Monotonic strictly increasing sequence number to prevent replay attacks&lt;/li>
&lt;li>Multiple socks5 connections share a single STUP connection&lt;/li>
&lt;/ul></description></item><item><title>STUP - Packet Structure and State Machine (2)</title><link>https://wizmann.top/posts/stup-2/</link><pubDate>Thu, 04 May 2017 00:53:03 +0000</pubDate><guid>https://wizmann.top/posts/stup-2/</guid><description>&lt;h2 id="stup-packet-structure">STUP Packet Structure &lt;a href="#stup-packet-structure" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="brief-introduction-of-tcp--udp-packet-structure">Brief Introduction of TCP &amp;amp; UDP Packet Structure &lt;a href="#brief-introduction-of-tcp--udp-packet-structure" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-4-24/73808256-file_1493006773118_a335.png" alt="">&lt;/p>
&lt;p>STUP pretend itself as a protocol at the Transmission Layer, but actually it&amp;rsquo;s absolutely an Application Layer protocol. So before we start, I&amp;rsquo;d like to recall some knowledge of two important Transmission Layer protocol: TCP &amp;amp; UDP.&lt;/p>
&lt;p>It is well known that TCP is a &amp;ldquo;connection-oriented&amp;rdquo;, &amp;ldquo;reliable&amp;rdquo;, &amp;ldquo;ordered&amp;rdquo;. To make an analogy (a little bit inappropriate), TCP is like a phone call (good cell signal strength):&lt;/p>
&lt;ol>
&lt;li>you are keeping a connection&lt;/li>
&lt;li>your words and sentences are well-received and well-ordered&lt;/li>
&lt;/ol>
&lt;p>As a result, each TCP packet has a unique and ordered sequence number, and your partner has to reply an &amp;ldquo;ACK&amp;rdquo; (short of &amp;ldquo;ACKnowledgement&amp;rdquo;) when it receive a packet. And it has to keep a connection and control the flow, a lot of control header is added to the header, so as the &amp;ldquo;window size&amp;rdquo;.&lt;/p>
&lt;p>In a word, TCP is a heavy-weight protocol which offers high reliability. But the performance is highly depend on the network condition.&lt;/p>
&lt;p>UDP is on the other way around, it&amp;rsquo;s &amp;ldquo;connectionless&amp;rdquo;, &amp;ldquo;unreliable&amp;rdquo; and &amp;ldquo;unordered&amp;rdquo;. To make another analogy, UDP is like a SMS message:&lt;/p>
&lt;ol>
&lt;li>there is no connection&lt;/li>
&lt;li>there is no guarantee that your partner will receive the message&lt;/li>
&lt;li>there is no guarantee of the order of messages, espiecially on a bad network&lt;/li>
&lt;/ol>
&lt;p>UDP is a lightweight protocol who doesn&amp;rsquo;t care about the connection and reliability, it just does it best to serve. And, of course, the performance is better than TCP.&lt;/p>
&lt;h3 id="stup-packet-structure--why">STUP Packet Structure &amp;amp; Why? &lt;a href="#stup-packet-structure--why" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>As I mentioned before, the only problem for me in TCP is the flow control. But that part is deep in the kernel, it is unnecessarily complicated to hack the kernel, a user application is good enough here for me.&lt;/p>
&lt;p>So, I build STUP over UDP to make everything simple. Firstly, UDP is a commonly used and well-known protocol, we can take advantages of existing infrastructure, framwork and libs. Secondly, UDP is lightweighted protocol, the overhead to build a new protocol over it is almost nothing.&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-5-2/38201062-file_1493708415970_dc40.png" alt="">&lt;/p>
&lt;p>The chart above shows STUP packet structure. And the bits in green are plain-text and the others in red are encrypted.&lt;/p>
&lt;ul>
&lt;li>Random IV (16bits): plain text, used to assemble the encrypt key&lt;/li>
&lt;li>Version (3 bits): for compatibility use, currently is &amp;ldquo;000&amp;rdquo;&lt;/li>
&lt;li>Nonce (6 bits): indicate the length of random trail padding data, used for data confusion&lt;/li>
&lt;li>URG (1 bit): urgent flag, internal use&lt;/li>
&lt;li>LIV (1 bit): keep-alive flag&lt;/li>
&lt;li>ACK (1 bit): acknowledgement flag&lt;/li>
&lt;li>PSH (1 bit): temporarily prohibit nagle algorithm for this packet&lt;/li>
&lt;li>RST (1 bit): reset flag&lt;/li>
&lt;li>SYN (1 bit): sync flag&lt;/li>
&lt;li>FIN (1 bit): finalize flag&lt;/li>
&lt;li>Seq number (32 bits): same as TCP&lt;/li>
&lt;li>Ack number (32 bits): same as TCP&lt;/li>
&lt;/ul>
&lt;p>The structure of STUP packet is quite similar to TCP packet, because we are imitating TCP, literally.&lt;/p>
&lt;h3 id="data-obfuscation-of-stup-packets">Data obfuscation of STUP packets &lt;a href="#data-obfuscation-of-stup-packets" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>One of the most important part of STUP protocol is obfuscation. We try to hide our intend of the network traffic to bypass the G*W. Except obfuscate the data, we also need to hide some patterns, for example, the handshack process, ack mechanism, etc.&lt;/p>
&lt;p>The first step is encryption, of course. It can help us the hide the feature inside data, for example, the pattern of a HTTP request can be easily detected. We use AES-ECB to encrypt the content of our packet.&lt;/p>
&lt;p>But why AES-ECB? There are a lot of saying on the internet that AES-ECB sucks, because it leaks plaintext data patterns.&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-5-2/19737252-file_1493708926479_15add.png" alt="">&lt;/p>
&lt;p>It is because we ecrypt the STUP packet &lt;strong>as a whole&lt;/strong>, it means there is no way to get the sequence number to order the packets before we decrypt it. As a solution, we add a &amp;ldquo;random IV&amp;rdquo; as a plain text in the STUP header. So the key to ecrypt is a combination of 48 bits pre-defined key and 16 bits random key. It might lead to a risk of small key space, but actually it&amp;rsquo;s more than enough to keep out traffic safe as we are not VIP who worth a brute force hacking.&lt;/p>
&lt;p>And still, there is another problem that we can&amp;rsquo;t hide the length information of our packet with a symmetric encryption. The solution is to append random padding bytes at the tail of every packets for data obfuscation, and use the &lt;code>nonce&lt;/code> field to mark the length of the paddings, then enrypt it. When receiver get the packets, firstly decrypt the packet, then drop the useless padding bytes and get the real data.&lt;/p>
&lt;h2 id="stup-state-machine">STUP State Machine &lt;a href="#stup-state-machine" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-4-24/70104484-file_1493025532333_338c.png" alt="">&lt;/p>
&lt;p>STUP state machine is also a simplify TCP state machine. And, in essence, they behave exactly the same.&lt;/p>
&lt;h2 id="whats-next">What&amp;rsquo;s next? &lt;a href="#whats-next" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>In next blog (maybe the last one for STUP series), we will talk about some details about the implementation, and future plan for this protocol.&lt;/p></description></item><item><title>STUP - another (stupid) TCP over UDP protocol (1)</title><link>https://wizmann.top/posts/stup-1/</link><pubDate>Thu, 20 Apr 2017 23:17:45 +0000</pubDate><guid>https://wizmann.top/posts/stup-1/</guid><description>&lt;h2 id="what-is-stup">What is STUP? &lt;a href="#what-is-stup" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>STUP is the abbreviation of &amp;ldquo;Speeded/Secure Tcp-like Udp Protocol&amp;rdquo;, which means that it&amp;rsquo;s another TCP over UDP protocol.&lt;/p>
&lt;p>Why TCP over UDP?&lt;/p>
&lt;p>TCP is a network protocol for general purpose, and it&amp;rsquo;s one of the most commonly used internet protocol on this planet. It is reliable, ordered and well optimized with decades of efforts.&lt;/p>
&lt;p>But, there&amp;rsquo;s plenty of reasons to replace that protocol for my scenario.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;del>Firstly, create my own network protocol is something geeky-nerdy, yep, suits me perfectly.&lt;/del>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Firstly, TCP is not &amp;ldquo;secure&amp;rdquo; (enough to bypass G*W). &lt;br>
Of course, it&amp;rsquo;s not TCP&amp;rsquo;s fault, because the security job is for the application layer. But &amp;ldquo;大清自有国情在&amp;rdquo;, we are in urgent need for a secure network protocol to obfuscate our network packet to bypass the firewall to get access to the &amp;ldquo;free internet&amp;rdquo;. &lt;br>
Shado*socks is one of the commonly used &amp;ldquo;secure&amp;rdquo; network protocol which based on socks5 proxy protocol and TCP. But still, it has its own problem.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Secondly, TCP performs badly on harsh transmission condition. &lt;br>
Because of the flow control and congestion control, the sliding window of TCP will be cut into half when packet is lost or timeout, which is very common on a harsh network connection as the jitter is inevitable. &lt;br>
It&amp;rsquo;s understandble that TCP has to negotiate the sliding window size with zero knowledge to achieve intra- and inter- protocol fairness, and make a stable network. But for us, we may have enough knowledge for our network, and we may not have too many connections at the same time, so here we don&amp;rsquo;t need control, we need speed. We come up with our own control mechanism - no control is best the control.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="how-it-works">How it works? &lt;a href="#how-it-works" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-4-20/98249887-file_1492687602713_f658.png" alt="">&lt;/p>
&lt;p>Our local application behavess like a socks5 proxy client, and send its data to a local adapter which will translate socks5 packet into STUP packet. The adapter doesn&amp;rsquo;t need to understand the &amp;ldquo;meaning&amp;rdquo; of socks5 packets, it just take it as a byte-flow, then encapsulate the data into the STUP packet.&lt;/p>
&lt;p>The local STUP client will encrypt the outgoing UDP packet. More precisely, the job of the encryption is to obfuscate the packet to bypass the detector of the G*W. We will talk about this later.&lt;/p>
&lt;p>Then the remote STUP protocol server received the encrypted packet, then it unpack the data and translate it back into the same byte-flow. After that, the socks5 server will get the message and retrieve what we want from the free internet.&lt;/p>
&lt;p>In a word, STUP procotol is a secure tunnel between the socks5 client and socks5 server. This design reduces the complexity of the whole system, and make it easy to implement.&lt;/p>
&lt;h2 id="how-we-implement-it-big-picture">How we implement it? (Big picture) &lt;a href="#how-we-implement-it-big-picture" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>We use Twisted framework to implement our protocol. The good parts of twisted is it hides the details of network programming and turn everything into events. But twisted is aptly named and it is really &amp;ldquo;twisted&amp;rdquo;, especially for the new comers.&lt;/p>
&lt;p>We implemented our simplfied &amp;ldquo;TCP stack&amp;rdquo; with fixed-size sliding window, nagle algorithm, retry mechanism, encrypting, etc. But with the help of Python, one of my favorite programming language &amp;hellip; it&amp;rsquo;s still a complex task to do. And it takes me a year to make it work.&lt;/p>
&lt;p>I say thankya.&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/17-4-20/89638264-file_1492701304939_10484.png" alt="">&lt;/p></description></item></channel></rss>