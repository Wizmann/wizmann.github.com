<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Valgrind on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/valgrind/</link><description>Recent content in Valgrind on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 20 Jul 2014 00:18:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/valgrind/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU cache引发的性能血案</title><link>https://wizmann.top/posts/cpu-cache-miss/</link><pubDate>Sun, 20 Jul 2014 00:18:00 +0000</pubDate><guid>https://wizmann.top/posts/cpu-cache-miss/</guid><description>&lt;p>在__&lt;a href="http://evol128.is-programmer.com/posts/35453.html">为什么转置一个512x512的矩阵，会比513x513的矩阵慢很多？&lt;/a>__一文中，作者引用了一个矩阵转置的例子，来讲解由于CPU cache的失效而带来的性能损失。&lt;/p>
&lt;p>上面的文章对问题的解释与讨论都非常的透彻。我的这篇文章只是对上面文章的一篇读后感和实验报告。就酱。&lt;/p>
&lt;h2 id="cpu-cache-之-组相联">CPU cache 之 组相联 &lt;a href="#cpu-cache-%e4%b9%8b-%e7%bb%84%e7%9b%b8%e8%81%94" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-tk-pic/blog-cpu-cache-2-way-set-assosiate.jpg" alt="组相联">&lt;/p>
&lt;p>组相联的实现和原理不必再赘述了。我想讨论的是，如何在编程中优化CPU的cache性能。&lt;/p>
&lt;h2 id="查看cpu信息">查看CPU信息 &lt;a href="#%e6%9f%a5%e7%9c%8bcpu%e4%bf%a1%e6%81%af" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>我的系统是Ubuntu 12.04，CPU是i5-3230M。（屌丝机 :D)&lt;/p>
&lt;pre tabindex="0">&lt;code>wizmann@Wichmann:~$ ls /sys/devices/system/cpu/cpu0/cache/index0/
coherency_line_size physical_line_partition size
level shared_cpu_list type
number_of_sets shared_cpu_map ways_of_associativity
&lt;/code>&lt;/pre>&lt;p>使用cat命令查看文件内容，可以获得CPU L1 cache的一些信息。&lt;/p>
&lt;table class="table table-striped-white table-bordered">
&lt;thead>
&lt;tr>
&lt;th>Key&lt;/th>
&lt;th>Value&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>&lt;tr>
&lt;td>level&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>size&lt;/td>
&lt;td>32K&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ways_of_associativity&lt;/td>
&lt;td>8&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>type&lt;/td>
&lt;td>Data&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>number_of_sets&lt;/td>
&lt;td>64&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;p>以上可知，CPU L1 cache有64组，每组有8个cache line。是&lt;strong>8位组相联&lt;/strong>的Cache类型。&lt;/p>
&lt;h2 id="分析缓存失效率">分析缓存失效率 &lt;a href="#%e5%88%86%e6%9e%90%e7%bc%93%e5%ad%98%e5%a4%b1%e6%95%88%e7%8e%87" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>对于以上问题，我们可以手工计算，也可以使用程序模拟Cache的失效率。&lt;/p>
&lt;p>同时，Valgrind为我们提供了cachegrind工具来分析cache的失效。&lt;/p>
&lt;pre tabindex="0">&lt;code>wizmann@Wichmann:/tmp$ valgrind --tool=cachegrind --D1=32768,2,16 ./test
==14282== Cachegrind, a cache and branch-prediction profiler
==14282== Copyright (C) 2002-2011, and GNU GPL&amp;#39;d, by Nicholas Nethercote et al.
==14282== Using Valgrind-3.7.0 and LibVEX; rerun with -h for copyright info
==14282== Command: ./test
==14282==
--14282-- warning: L3 cache found, using its data for the LL simulation.
Average for a matrix of 257: 1875==14282==
==14282== I refs: 18,708,198
==14282== I1 misses: 1,404
==14282== LLi misses: 1,355
==14282== I1 miss rate: 0.00%
==14282== LLi miss rate: 0.00%
==14282==
==14282== D refs: 8,936,548 (4,543,346 rd + 4,393,202 wr)
==14282== D1 misses: 1,107,687 (1,086,263 rd + 21,424 wr)
==14282== LLd misses: 10,502 ( 5,179 rd + 5,323 wr)
==14282== D1 miss rate: 12.3% ( 23.9% + 0.4% )
==14282== LLd miss rate: 0.1% ( 0.1% + 0.1% )
==14282==
==14282== LL refs: 1,109,091 (1,087,667 rd + 21,424 wr)
==14282== LL misses: 11,857 ( 6,534 rd + 5,323 wr)
==14282== LL miss rate: 0.0% ( 0.0% + 0.1% )
&lt;/code>&lt;/pre>&lt;p>其中I1代表指令1级缓存，D1代表数据1级缓存，而LL代表二级或三级缓存。&lt;/p>
&lt;p>上面的输出也许过于复杂，我们在下面列表分析。&lt;/p>
&lt;h3 id="测试环境">测试环境 &lt;a href="#%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>只讨论L1的情况，L1大小32768 Bytes，2路组相联，每个cache line有16 Bytes。&lt;/p>
&lt;p>valgrind测试命令为：&lt;/p>
&lt;pre tabindex="0">&lt;code>wizmann@Wichmann:/tmp$ valgrind --tool=cachegrind --D1=32768,2,16 ./test
&lt;/code>&lt;/pre>&lt;h3 id="测试程序">测试程序 &lt;a href="#%e6%b5%8b%e8%af%95%e7%a8%8b%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define SAMPLES 64
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define MATSIZE 256
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;time.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> mat[MATSIZE][MATSIZE];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">transpose&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> MATSIZE ; i&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> i ; j&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> aux &lt;span style="color:#f92672">=&lt;/span> mat[i][j];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mat[i][j] &lt;span style="color:#f92672">=&lt;/span> mat[j][i];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mat[j][i] &lt;span style="color:#f92672">=&lt;/span> aux;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//initialize matrix
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> MATSIZE ; i&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> j &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ; j &lt;span style="color:#f92672">&amp;lt;&lt;/span> MATSIZE ; j&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mat[i][j] &lt;span style="color:#f92672">=&lt;/span> i&lt;span style="color:#f92672">+&lt;/span>j;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> t &lt;span style="color:#f92672">=&lt;/span> clock();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> ( &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> ; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> SAMPLES ; i&lt;span style="color:#f92672">++&lt;/span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> transpose();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> elapsed &lt;span style="color:#f92672">=&lt;/span> clock() &lt;span style="color:#f92672">-&lt;/span> t;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Average for a matrix of &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> MATSIZE &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> elapsed &lt;span style="color:#f92672">/&lt;/span> SAMPLES;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="测试结果">测试结果 &lt;a href="#%e6%b5%8b%e8%af%95%e7%bb%93%e6%9e%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;table class="table table-striped-white table-bordered">
&lt;thead>
&lt;tr>
&lt;th>-&lt;/th>
&lt;th>MATSIZE = 256&lt;/th>
&lt;th>MATSIZE = 256 + 1&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>&lt;tr>
&lt;td>运行时间 (g++ O2) 1024次&lt;/td>
&lt;td>78ms&lt;/td>
&lt;td>39ms&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D1 Miss&lt;/td>
&lt;td>2,621,967&lt;/td>
&lt;td>1,107,687&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>D1 Miss Rate&lt;/td>
&lt;td>29.5%&lt;/td>
&lt;td>12.3%&lt;/td>
&lt;/tr>
&lt;/tbody>&lt;/table>
&lt;p>由此可见，Cache的Miss Rate基本决定了程序的运行速度，运行时间比例和D1 MISS RATE的比例基本一致。&lt;/p>
&lt;ul>
&lt;li>注：本机环境与cachegrind参数是不一致的，在本机上由于cache较大，且采用8位组相联，所以D1 cache miss较少，差异主要体现在LLd Miss Rate上。&lt;/li>
&lt;/ul>
&lt;h2 id="实际意义">实际意义 &lt;a href="#%e5%ae%9e%e9%99%85%e6%84%8f%e4%b9%89" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>如果程序对一段内存进行顺序读取的时候，以上的缓存失效问题有可能会显现出来。但是缓存失效只是程序性能问题的一个可能的原因，应该在对程序进行profile之后再做结论。&lt;/p>
&lt;h2 id="其它profile工具">其它profile工具 &lt;a href="#%e5%85%b6%e5%ae%83profile%e5%b7%a5%e5%85%b7" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>我的提问：__&lt;a href="http://www.zhihu.com/question/24540567/noti-answers?group_id=564624072">有没有什么方法可以对CPU cache失效进行计数？&lt;/a>__中，各位答主还提供了以下几种工具：&lt;/p>
&lt;ul>
&lt;li>perf (linux)&lt;/li>
&lt;li>&lt;a href="http://tiptop.gforge.inria.fr/">Tiptop&lt;/a>&lt;/li>
&lt;li>qemu&lt;/li>
&lt;li>visual studio的cpu counter&lt;/li>
&lt;li>intel performance counter monitor&lt;/li>
&lt;li>vtunes&lt;/li>
&lt;/ul>
&lt;p>profile的方法很多，选一个易用性与正确性达到平衡就可以。反正我是哪个也不会_(:з」∠)_&lt;/p>
&lt;h2 id="参考链接">参考链接 &lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="http://yoursunny.com/study/EI209/?topic=cache">cache映射功能、命中率计算&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://blog.focus-linux.net/?p=391">使用valgrind检查cache命中率，提高程序性能&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://valgrind.org/docs/manual/cg-manual.html">Cachegrind: a cache and branch-prediction profiler&lt;/a> （官方文档）&lt;/li>
&lt;li>&lt;a href="https://access.redhat.com/documentation/zh-CN/Red_Hat_Enterprise_Linux/6/html/Performance_Tuning_Guide/ch05s03s02.html">使用 Cachegrind 简要概述缓存使用&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://wwwcdf.pd.infn.it/valgrind/cg_main.html">Cachegrind: a cache-miss profiler&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ibm.com/developerworks/cn/linux/l-cn-perf">Perf &amp;ndash; Linux下的系统性能调优工具，第 1 部分&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://coolshell.cn/articles/10249.html">7个示例科普CPU Cache（扩展阅读）&lt;/a>&lt;/li>
&lt;/ul></description></item></channel></rss>