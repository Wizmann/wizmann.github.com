<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Lock-Less on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/lock-less/</link><description>Recent content in Lock-Less on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Thu, 28 Nov 2013 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/lock-less/index.xml" rel="self" type="application/rss+xml"/><item><title>Linux内核中的少锁链表</title><link>https://wizmann.top/posts/linux-lockless-llist/</link><pubDate>Thu, 28 Nov 2013 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/linux-lockless-llist/</guid><description>&lt;h1 id="前言">前言 &lt;a href="#%e5%89%8d%e8%a8%80" class="anchor">🔗&lt;/a>&lt;/h1>&lt;p>最近在stackexchange上看到一个问答，讨论我们常用的数据结构与算法在实际工程中的应用。(&lt;a href="http://cstheory.stackexchange.com/questions/19759/core-algorithms-deployed/19773#19773">戳我&lt;/a>)&lt;/p>
&lt;p>我打算借助这个问答中的内容，以我比较熟悉的数据结构与算法为索引来阅读开源代码。&lt;/p>
&lt;h1 id="正文">正文 &lt;a href="#%e6%ad%a3%e6%96%87" class="anchor">🔗&lt;/a>&lt;/h1>&lt;h2 id="talk-is-cheap">Talk is cheap &lt;a href="#talk-is-cheap" class="anchor">🔗&lt;/a>&lt;/h2>&lt;blockquote>
&lt;p>Lock-less NULL terminated single linked list&lt;/p>&lt;/blockquote>
&lt;p>&lt;a href="https://github.com/mirrors/linux-2.6/blob/master/include/linux/llist.h">linux-2.6/include/linux/llist.h&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://github.com/mirrors/linux-2.6/blob/master/lib/llist.c">linux-2.6/lib/llist.c&lt;/a>&lt;/p>
&lt;h2 id="知识准备">知识准备 &lt;a href="#%e7%9f%a5%e8%af%86%e5%87%86%e5%a4%87" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="volatile">volatile &lt;a href="#volatile" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>volatile关键字声明的变量或对象通常拥有和优化和（或）多线程相关的特殊属性。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>通常，volatile关键字用来阻止（伪）编译器对那些它认为变量的值不能“被代码本身”改变的代码上执行任何优化。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>如果不使用volatile关键字，编译器将假设当前程序是系统中唯一能改变这个值部分。 为了阻止编译器像上面那样优化代码，需要使用volatile关键字。&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>From: &lt;a href="http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F">http://zh.wikipedia.org/wiki/Volatile%E5%8F%98%E9%87%8F&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h3 id="typeof">typeof &lt;a href="#typeof" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>Another way to refer to the type of an expression is with typeof. The syntax of using of this keyword looks like sizeof, but the construct acts semantically like a type name defined with typedef.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>From: &lt;a href="http://gcc.gnu.org/onlinedocs/gcc/Typeof.html">http://gcc.gnu.org/onlinedocs/gcc/Typeof.html&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;code>typeof&lt;/code>和&lt;code>sizeof&lt;/code>类似，sizeof求的是变量/类型的大小，而typeof是求变量/类型的&lt;strong>数据类型&lt;/strong>。&lt;/p>
&lt;p>typeof在#define中的应用很多，例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define max(a,b) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> ({ typeof (a) _a = (a); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> typeof (b) _b = (b); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> _a &amp;gt; _b ? _a : _b; })
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>typeof(a)&lt;/code>获得了&lt;code>a&lt;/code>的类型，声明了一个同类型的&lt;code>_a&lt;/code>变量。&lt;/p>
&lt;p>p.s. 上面是一个安全的用&lt;code>#define&lt;/code>实现的&lt;code>max&lt;/code>函数。&lt;/p>
&lt;h3 id="access_once">ACCESS_ONCE &lt;a href="#access_once" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;amp;(x))；
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ACCESS_ONCE&lt;/code>使用了一个类型转换，使用&lt;code>volatile&lt;/code>修饰 &lt;code>x&lt;/code>。避免编译器优化带来的潜在岐义。&lt;/p>
&lt;h3 id="cmpxchg">cmpxchg &lt;a href="#cmpxchg" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>compare-and-swap (CAS) is an atomic instruction used in multithreading to achieve synchronization.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>It compares the contents of a memory location to a given value and, only if they are the same, modifies the contents of that memory location to a given new value.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>This is done as a single atomic operation. The atomicity guarantees that the new value is calculated based on up-to-date information; if the value had been updated by another thread in the meantime, the write would fail.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>The result of the operation must indicate whether it performed the substitution; this can be done either with a simple Boolean response (this variant is often called compare-and-set), or by returning the value read from the memory location (not the value written to it).&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>&amp;hellip;&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>In the x86 (since 80486) and Itanium architectures this is implemented as the compare and exchange (CMPXCHG) instruction, though here the LOCK prefix should be there to make it really atomic.&lt;/p>&lt;/blockquote>
&lt;blockquote>
&lt;p>From: &lt;a href="http://en.wikipedia.org/wiki/Compare-and-swap">http://en.wikipedia.org/wiki/Compare-and-swap&lt;/a>&lt;/p>&lt;/blockquote>
&lt;p>&lt;code>cmpxchg&lt;/code>是在Intel平台上&lt;code>atomic compare-and-swap&lt;/code>操作的实现。&lt;/p>
&lt;p>&lt;code>cmpxchg&lt;/code>还被用来实现&lt;code>spinlock&lt;/code>，&lt;a href="http://stackoverflow.com/questions/6935442/x86-spinlock-using-cmpxchg">戳我&lt;/a>。&lt;/p>
&lt;h2 id="show-me-the-code">Show me the code &lt;a href="#show-me-the-code" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="数据类型">数据类型 &lt;a href="#%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> llist_head {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> llist_node {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个简单的类型包裹。&lt;/p>
&lt;p>&lt;code>llist_head&lt;/code>是链表头，而&lt;code>llist_node&lt;/code>是链表中&lt;strong>链&lt;/strong>的部分。&lt;/p>
&lt;h3 id="初始化">初始化 &lt;a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define LLIST_HEAD_INIT(name) { NULL }
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define LLIST_HEAD(name) struct llist_head name = LLIST_HEAD_INIT(name)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * init_llist_head - initialize lock-less list head
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the head for your lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">init_llist_head&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>list)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链表的遍历">链表的遍历 &lt;a href="#%e9%93%be%e8%a1%a8%e7%9a%84%e9%81%8d%e5%8e%86" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="llist_entry">llist_entry &lt;a href="#llist_entry" class="anchor">🔗&lt;/a>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_entry - get the struct of this entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @ptr: the &amp;amp;struct llist_node pointer.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @type: the type of the struct this is embedded in.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @member: the name of the llist_node within the struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define llist_entry(ptr, type, member) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> container_of(ptr, type, member)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>声明一个链表时，我们需要把&lt;code>llist_node&lt;/code>包含在链表节点中，&lt;code>llist_head&lt;/code>是链表头。&lt;/p>
&lt;p>&lt;code>llist_entry&lt;/code>是从链表节点中的&lt;code>llist_node&lt;/code>成员变量获得链表节点的地址。&lt;/p>
&lt;p>&lt;code>llist_entry&lt;/code>宏是从&lt;code>container_of&lt;/code>宏继承而来的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * container_of - cast a member of a structure out to the containing structure
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @ptr: the pointer to the member.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @type: the type of the container struct this is embedded in.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @member: the name of the member within the struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define container_of(ptr, type, member) ({ \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> const typeof( ((type *)0)-&amp;gt;member ) *__mptr = (ptr); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> (type *)( (char *)__mptr - offsetof(type,member) );})
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>具体原理可以小小参考一下&lt;a href="http://hi.baidu.com/holinux/item/af2e32c9dcbd3953ac00ef49">这里&lt;/a>。&lt;/p>
&lt;h4 id="for_each">for_each &lt;a href="#for_each" class="anchor">🔗&lt;/a>&lt;/h4>&lt;h5 id="llist_for_each">llist_for_each &lt;a href="#llist_for_each" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_for_each - iterate over some deleted entries of a lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @pos: the &amp;amp;struct llist_node to use as a loop cursor
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @node: the first entry of deleted list entries
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * In general, some entries of the lock-less list can be traversed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * safely only after being deleted from list, so start with an entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * instead of list head.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * If being used on entries deleted from lock-less list directly, the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * traverse order is from the newest to the oldest added entry. If
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * you want to traverse from the oldest to the newest, you must
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * reverse the order by yourself before traversing.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define llist_for_each(pos, node) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> for ((pos) = (node); pos; (pos) = (pos)-&amp;gt;next)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一个&lt;code>for循环&lt;/code>。简单的宏。&lt;/p>
&lt;h5 id="llist_for_each_entry">llist_for_each_entry &lt;a href="#llist_for_each_entry" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_for_each_entry - iterate over some deleted entries of lock-less list of given type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @pos: the type * to use as a loop cursor.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @node: the fist entry of deleted list entries.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @member: the name of the llist_node with the struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * In general, some entries of the lock-less list can be traversed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * safely only after being removed from list, so start with an entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * instead of list head.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * If being used on entries deleted from lock-less list directly, the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * traverse order is from the newest to the oldest added entry. If
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * you want to traverse from the oldest to the newest, you must
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * reverse the order by yourself before traversing.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define llist_for_each_entry(pos, node, member) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> for ((pos) = llist_entry((node), typeof(*(pos)), member); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;amp;(pos)-&amp;gt;member != NULL; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> (pos) = llist_entry((pos)-&amp;gt;member.next, typeof(*(pos)), member))
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>遍历链表的类。
用伪代码来表述一下就是。&lt;/p>
&lt;pre tabindex="0">&lt;code>for ((pos) = 链表节点;
&amp;amp;(pos)-&amp;gt;next指针 != NULL;
(pos) = 链表下一个节点) {
// 遍历操作
pos.foo = bar;
}
&lt;/code>&lt;/pre>&lt;h5 id="llist_for_each_entry_safe">llist_for_each_entry_safe &lt;a href="#llist_for_each_entry_safe" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_for_each_entry_safe - iterate over some deleted entries of lock-less list of given type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * safe against removal of list entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @pos: the type * to use as a loop cursor.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @n: another type * to use as temporary storage
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @node: the first entry of deleted list entries.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @member: the name of the llist_node with the struct.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * In general, some entries of the lock-less list can be traversed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * safely only after being removed from list, so start with an entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * instead of list head.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * If being used on entries deleted from lock-less list directly, the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * traverse order is from the newest to the oldest added entry. If
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * you want to traverse from the oldest to the newest, you must
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * reverse the order by yourself before traversing.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define llist_for_each_entry_safe(pos, n, node, member) \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> for (pos = llist_entry((node), typeof(*pos), member); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> &amp;amp;pos-&amp;gt;member != NULL &amp;amp;&amp;amp; \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> (n = llist_entry(pos-&amp;gt;member.next, typeof(*n), member), true); \
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> pos = n)
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>safe&lt;/code>表示单链表中的节点有可能被增加/删除。&lt;/p>
&lt;p>使用&lt;code>(n = llist_entry(pos-&amp;gt;member.next, typeof(*n), member), true)&lt;/code>可以保持遍历的安全性。&lt;/p>
&lt;h6 id="llist_next">llist_next &lt;a href="#llist_next" class="anchor">🔗&lt;/a>&lt;/h6>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">llist_next&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>node)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> node&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="链表元素的操作">链表元素的操作 &lt;a href="#%e9%93%be%e8%a1%a8%e5%85%83%e7%b4%a0%e7%9a%84%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h5 id="llist_add_batch">llist_add_batch &lt;a href="#llist_add_batch" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_add_batch - add several linked entries in batch
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @new_first: first entry in batch to be added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @new_last: last entry in batch to be added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the head for your lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Return whether list is empty before adding.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">llist_add_batch&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>new_first, &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>new_last,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_last&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ACCESS_ONCE&lt;/span>(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#a6e22e">cmpxchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, first, new_first) &lt;span style="color:#f92672">!=&lt;/span> first);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">!&lt;/span>first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>批量增加命令，使用&lt;code>cmpxchg&lt;/code>保持线程安全。&lt;/p>
&lt;h5 id="llist_add">llist_add &lt;a href="#llist_add" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_add - add a new entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @new: new entry to be added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the head for your lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Returns true if the list was empty prior to adding this entry.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">llist_add&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>new, &lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">llist_add_batch&lt;/span>(new, new, head);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="llist_empty">llist_empty &lt;a href="#llist_empty" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_empty - tests whether a lock-less list is empty
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the list to test
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Not guaranteed to be accurate or up to date. Just a quick way to
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * test whether the list is empty without deleting something from the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * list.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">llist_empty&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">ACCESS_ONCE&lt;/span>(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first) &lt;span style="color:#f92672">==&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用&lt;code>ACCESS_ONCE&lt;/code>避免编译器优化，保持线程安全性。&lt;/p>
&lt;h5 id="llist_del_all">llist_del_all &lt;a href="#llist_del_all" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_del_all - delete all entries from lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the head of lock-less list to delete all entries
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * If list is empty, return NULL, otherwise, delete all entries and
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * return the pointer to the first entry. The order of entries
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * deleted is from the newest to the oldest added one.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">llist_del_all&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">xchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h5 id="llist_del_first">llist_del_first &lt;a href="#llist_del_first" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_del_first - delete the first entry of lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: the head for your lock-less list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * If list is empty, return NULL, otherwise, return the first entry
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * deleted, this is the newest added one.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Only one llist_del_first user can be used simultaneously with
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * multiple llist_add users without lock. Because otherwise
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_del_first, llist_add, llist_add (or llist_del_all, llist_add,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_add) sequence in another user may change @head-&amp;gt;first-&amp;gt;next,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * but keep @head-&amp;gt;first. If multiple consumers are needed, please
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * use llist_del_all or use lock between consumers.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">llist_del_first&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_head &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>entry, &lt;span style="color:#f92672">*&lt;/span>old_entry, &lt;span style="color:#f92672">*&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (entry &lt;span style="color:#f92672">==&lt;/span> NULL)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> old_entry &lt;span style="color:#f92672">=&lt;/span> entry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next &lt;span style="color:#f92672">=&lt;/span> entry&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cmpxchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, old_entry, next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (entry &lt;span style="color:#f92672">==&lt;/span> old_entry)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> entry;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>删除第一个值。同样的无锁操作。&lt;/p>
&lt;h5 id="llist_reverse_order">llist_reverse_order &lt;a href="#llist_reverse_order" class="anchor">🔗&lt;/a>&lt;/h5>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * llist_reverse_order - reverse order of a llist chain
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * @head: first item of the list to be reversed
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> *
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * Reverse the order of a chain of llist entries and return the
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * new first entry.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">llist_reverse_order&lt;/span>(&lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>head)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>new_head &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (head) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> llist_node &lt;span style="color:#f92672">*&lt;/span>tmp &lt;span style="color:#f92672">=&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> new_head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_head &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> new_head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">EXPORT_SYMBOL_GPL&lt;/span>(llist_reverse_order);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如何反转一个单链表&lt;/p>
&lt;h2 id="少锁链表是如何实现的">少锁链表是如何实现的 &lt;a href="#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="add函数中的原子操作">add函数中的原子操作 &lt;a href="#add%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> new_last&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> first &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">ACCESS_ONCE&lt;/span>(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#a6e22e">cmpxchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, first, new_first) &lt;span style="color:#f92672">!=&lt;/span> first);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中&lt;code>cmpxchg&lt;/code>的性质类似于锁。保证赋值是成功的且是是原子的。&lt;/p>
&lt;h3 id="del_first中的原子操作">del_first中的原子操作 &lt;a href="#del_first%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>entry &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#a6e22e">cmpxchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, old_entry, next);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="del_all中的原子操作">del_all中的原子操作 &lt;a href="#del_all%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">xchg&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>first, NULL);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="少锁链表如何处理并发">少锁链表如何处理并发 &lt;a href="#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e5%b9%b6%e5%8f%91" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在llist.h中有如下的注释表明如果两种操作并发执行，是否需要加额外的锁。&lt;/p>
&lt;pre tabindex="0">&lt;code> /*
* | add | del_first | del_all
* add | - | - | -
* del_first | | L | L
* del_all | | | -
*/
&lt;/code>&lt;/pre>&lt;p>&lt;code>add&lt;/code>操作和头指针没有关系，所以它可以和其它操作并行。
&lt;code>del_first&lt;/code>依赖于&lt;code>list-&amp;gt;first-&amp;gt;next&lt;/code>在操作时不变化。
而&lt;code>del_all&lt;/code>只对&lt;code>list-&amp;gt;first&lt;/code>的指针进行操作。所以是可以并行的。&lt;/p>
&lt;h3 id="少锁链表如何处理遍历">少锁链表如何处理遍历 &lt;a href="#%e5%b0%91%e9%94%81%e9%93%be%e8%a1%a8%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86%e9%81%8d%e5%8e%86" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/*
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The list entries deleted via llist_del_all can be traversed with
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * traversing function such as llist_for_each etc. But the list
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * entries can not be traversed safely before deleted from the list.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * The order of deleted entries is from the newest to the oldest added
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * one. If you want to traverse from the oldest to the newest, you
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> * must reverse the order by yourself before traversing.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"> */&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>大概意思是说只有从列表上删除下来的元素才可以安全的遍历。（这点理解的不深入）&lt;/p>
&lt;h2 id="后记">后记 &lt;a href="#%e5%90%8e%e8%ae%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>本来是想把这llist的代码看明白的。但是，大概只看懂了60%。。。&lt;/p>
&lt;p>以后如果有新的想法，看到了新的东西，也许会有不少有用的update吧。。&lt;/p></description></item></channel></rss>