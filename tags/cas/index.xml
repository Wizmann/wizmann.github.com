<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CAS on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/cas/</link><description>Recent content in CAS on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/cas/index.xml" rel="self" type="application/rss+xml"/><item><title>实现一个无锁消息队列（续与勘误）</title><link>https://wizmann.top/posts/implement-non-blocking-queue-2/</link><pubDate>Sun, 14 Apr 2024 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/implement-non-blocking-queue-2/</guid><description>&lt;ul>
&lt;li>本文内容主要参考自&lt;a href="https://people.cs.pitt.edu/~jacklange/teaching/cs2510-f17/implementing_lock_free.pdf">Implementing Lock-Free Queue&lt;/a>一文（以下简称“原论文”）&lt;/li>
&lt;li>是对&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">实现一个无锁消息队列&lt;/a>一文的内容进行补充&lt;/li>
&lt;li>
&lt;h2 id="tldr">TL；DR &lt;a href="#tldr" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>尽管&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">实现一个无锁消息队列&lt;/a>一文中的实现是正确的，但是忽略了“非阻塞性”
&lt;ul>
&lt;li>例如，当任一插入操作被阻塞，则其它插入操作均会陷入忙等待&lt;/li>
&lt;li>此实现与&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>的实现基本一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于一个支持并发的数据结构，理应同时具备非阻塞性和无等待性
&lt;ul>
&lt;li>非阻塞性（non-blocking）：无论是由于CPU调度或其他外部因素，数据结构的操作不能被中断或延迟&lt;/li>
&lt;li>无等待性（wait-free)：保证没有任何线程会遭受饥饿状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>前一篇博文对其它实现的质疑，主要在于ABA问题，但这个问题是Compare&amp;amp;Swap所特有的，需要特定的实现来规避&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="理论基础">理论基础 &lt;a href="#%e7%90%86%e8%ae%ba%e5%9f%ba%e7%a1%80" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>我们的目标是实现一个支持并发enqueue/deque的队列&lt;/li>
&lt;li>对于这样的数据结构，有两个重要的特性
&lt;ul>
&lt;li>非阻塞性（non-blocking）
&lt;ul>
&lt;li>对于每一个执行线程，所有的操作将会在有限的次数内完成&lt;/li>
&lt;li>无论本线程或其它线程在执行过程中因其它原因（如CPU调度）执行过缓，或者被中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无等待性（wait-free)
&lt;ul>
&lt;li>没有线程会饥饿&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于锁的数据结构不符合上述特性，因为持有锁的线程可能会无限期地阻塞所有操作&lt;/li>
&lt;li>“线性一致性”(Linearizability) —— 更强的正确性
&lt;ul>
&lt;li>非并发操作应当按照它们的逻辑顺序执行，以保证操作的正确性，而并发操作则可以按任意顺序进行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ldquo;Fetch&amp;amp;Add&amp;rdquo; 与 &amp;ldquo;Compare&amp;amp;Swap&amp;rdquo;
&lt;ul>
&lt;li>常用的原子操作，这里不做赘述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="基于链表的无锁队列实现">基于链表的无锁队列实现 &lt;a href="#%e5%9f%ba%e4%ba%8e%e9%93%be%e8%a1%a8%e7%9a%84%e6%97%a0%e9%94%81%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>略，参考原论文与&lt;a href="https://coolshell.cn/articles/8239.html">无锁队列的实现&lt;/a>一文&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="基于数组的无锁队列实现">基于数组的无锁队列实现 &lt;a href="#%e5%9f%ba%e4%ba%8e%e6%95%b0%e7%bb%84%e7%9a%84%e6%97%a0%e9%94%81%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>略，参考原论文与&lt;a href="https://coolshell.cn/articles/8239.html">无锁队列的实现&lt;/a>一文&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="aba问题">ABA问题 &lt;a href="#aba%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>Compare&amp;amp;Swap操作确保了值修改的原子性。指针作为值的一种，代表着某个内存地址，但Compare&amp;amp;Swap对指针的操作无法保证其指向的内存内容不被修改&lt;/li>
&lt;li>考虑到可能释放旧内存后再申请新内存，这两块内存虽逻辑不同却可能拥有同一地址，这对Compare&amp;amp;Swap操作造成了困扰&lt;/li>
&lt;li>解决方案是为指针加入引用计数（ref count），以确保内存在可访问时不会被释放或重用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="性能对比">性能对比 &lt;a href="#%e6%80%a7%e8%83%bd%e5%af%b9%e6%af%94" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>上面我们已经提到，&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>一文中的方法缺少了“非阻塞性”，，但其性能与原论文中的实现十分接近&lt;/li>
&lt;li>但是在原理上，“非阻塞性”实现可以避免意外的线程停止或延迟&lt;/li>
&lt;li>疑问：是否会在P99级别的Latency上才会体现出明显的差异？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="参考链接">参考链接 &lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://people.cs.pitt.edu/~jacklange/teaching/cs2510-f17/implementing_lock_free.pdf">Implementing Lock-Free Queue&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cs.nyu.edu/~wies/teaching/cso-fa19/class27_concurrency.pdf">Concurrency – Correctness of Concurrent Objects&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="后续">后续 &lt;a href="#%e5%90%8e%e7%bb%ad" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/690872647">C++ 单生产者&amp;amp;单消费者 无锁队列&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=K3P_Lmq6pw0&amp;amp;ab_channel=CppCon">Single Producer Single Consumer Lock-free FIFO From the Ground Up - Charles Frasch - CppCon 2023&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>在SPIN/Promela中模拟CAS（Compare-and-Swap）</title><link>https://wizmann.top/posts/simple-cas-model-in-spin-promela/</link><pubDate>Fri, 15 Dec 2023 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/simple-cas-model-in-spin-promela/</guid><description>&lt;p>CAS（Compare-And-Swap）是一种在多线程编程中常用的数据同步方法，它通过比较和交换操作来保证数据的一致性。然而，在SPIN/Promela中没有直接的CAS对应实现。&lt;/p>
&lt;p>让我们来看一个例子。考虑以下Promela代码，它模拟了两个工作线程 worker0 和 worker1 使用CAS机制交替修改共享变量 x 的场景：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-promela" data-lang="promela">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> running &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">proctype&lt;/span> worker0() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (true) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">proctype&lt;/span> worker1() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>end:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (true) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> { x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">::&lt;/span> else &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">skip&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">od&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">init&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">atomic&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span> worker0()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">run&lt;/span> worker1();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> running &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">ltl&lt;/span> not_always_0 { &lt;span style="color:#f92672">[]&lt;/span>(running &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>(x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)); };
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从直观上理解，LTL表达式 not_always_0 应该被满足，因为 worker0 和 worker1 应该会交替执行，从而在未来的某个时刻使 x == 1 成立。&lt;/p>
&lt;p>然而，在SPIN的实际运行中，我们可能会遇到一个问题：如果 worker0 在任何点停止执行，worker1 就会陷入死循环，这种情况被称为“饥饿”（starvation）。&lt;/p>
&lt;p>为了解决这一问题，我们可以在SPIN中使用 -f 选项来保证弱公平性（weak fairness）。弱公平性意味着，如果一个可执行的动作在无限长的执行序列中有无限次的执行机会，那么它最终必须得到执行。这确保了即使一个动作暂时无法执行，它最终也会有机会执行。&lt;/p>
&lt;p>在这个模型中，应用弱公平性可以确保 worker0 和 worker1 最终都有机会交替执行。这使得模型能够模拟现实的多线程CPU执行场景，从而验证了LTL属性 not_always_0 的正确性。&lt;/p>
&lt;ul>
&lt;li>详细命令&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>spin -a simple-cas.pml
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>./pan -m10000 -a -f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>参考链接
&lt;ul>
&lt;li>&lt;a href="https://spinroot.com/spin/Man/Quick.html">Concise Promela Reference &amp;gt; Executing a Promela system&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>实现一个无锁消息队列</title><link>https://wizmann.top/posts/implement-non-blocking-queue/</link><pubDate>Wed, 02 May 2018 00:39:00 +0000</pubDate><guid>https://wizmann.top/posts/implement-non-blocking-queue/</guid><description>&lt;blockquote>
&lt;p>240414更新：后续补充了一篇勘误文章，见&lt;a href="https://wizmann.top/implement-non-blocking-queue-2.html">这里&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="目标">目标 &lt;a href="#%e7%9b%ae%e6%a0%87" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>实现一个多读多写的无锁消息队列。&lt;/p>
&lt;h2 id="cmpxchg---比较并替换">cmpxchg - 比较并替换 &lt;a href="#cmpxchg---%e6%af%94%e8%be%83%e5%b9%b6%e6%9b%bf%e6%8d%a2" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>比较并替换（compare-and-swap, CAS）是一个用于多线程同步的原子操作。&lt;/p>
&lt;p>其工作流程是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">cmpxchg&lt;/span>(val, oldval, newval):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> val &lt;span style="color:#f92672">==&lt;/span> oldval:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> val &lt;span style="color:#f92672">=&lt;/span> newval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，只有当&lt;code>val&lt;/code>等于&lt;code>oldval&lt;/code>时，我们才会将&lt;code>val&lt;/code>的值替换成&lt;code>newval&lt;/code>。在多线程的场景下，cmpxchg用来保证多线程写的原子性。&lt;/p>
&lt;p>例如，线程1和线程2都要写入&lt;code>val&lt;/code>变量，但是我们需要保证只有一个线程能写成功。使用cmpxchg，能保证只有一个线程能成功的将&lt;code>val&lt;/code>变量替换成新值，写失败的线程会得到&lt;code>False&lt;/code>的返回值。&lt;/p>
&lt;h2 id="access_once---消除优化歧义">ACCESS_ONCE - 消除优化歧义 &lt;a href="#access_once---%e6%b6%88%e9%99%a4%e4%bc%98%e5%8c%96%e6%ad%a7%e4%b9%89" class="anchor">🔗&lt;/a>&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ACCESS_ONCE(x) (*(volatile typeof(x) *)&amp;amp;(x))；
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>ACCESS_ONCE&lt;/code>的作用是将一个指针转化成&lt;code>volatile&lt;/code>指针，使得读取操作“真的”去读取指针的值而不被编译器优化掉。&lt;/p>
&lt;h2 id="实现">实现 &lt;a href="#%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="原子操作与nullable">原子操作与Nullable &lt;a href="#%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c%e4%b8%8enullable" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>说到多线程，我们就不能不谈原子操作。对于一个队列来说，我们可以在其中存储任意复杂的数据结构，但是这些数据结构大部分都不支持原子操作。&lt;/p>
&lt;p>同样，我们也没有一种有效的手段来标识一个值是“不存在的”。是的，我们可以自己实现一个&lt;code>Nullable&amp;lt;T&amp;gt;&lt;/code>的模板，但是带来的额外成本就是对于任意&lt;code>Nullable&amp;lt;T&amp;gt;&lt;/code>的赋值都要经过两步以上的中间步骤，这简直就是竞态bug产生的温床。&lt;/p>
&lt;p>不过，在C++中自带着一个有着&amp;quot;Nullable&amp;quot;语意的数据结构 —— 指针。当指针为NULL时，意味着值是不存在的，而指针不为NULL时，它代表着它所指向的值。更重要的是，指针的赋值、读取、拷贝都是原子的，这给我们的代码实现提供了非常大的便利。&lt;/p>
&lt;h3 id="数据结构">数据结构 &lt;a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/18-5-1/40471673.jpg" alt="">&lt;/p>
&lt;p>我们使用单链表做为基础数据结构，链表的头代表着队列的头，链表的尾对应着队列的尾。这样添加数据时，我们在TAIL节点处写入，弹出数据时从HEAD节点处弹出。&lt;/p>
&lt;p>那么问题来了，在单线程下，维护头尾节点是非常容易的操作。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">维护头节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>cur &lt;span style="color:#f92672">=&lt;/span> HEAD&lt;span style="color:#f92672">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HEAD&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> HEAD&lt;span style="color:#f92672">.&lt;/span>next&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#75715e"># 操作链表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">维护尾节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>newnode &lt;span style="color:#f92672">=&lt;/span> Node(value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TAIL&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> newnode &lt;span style="color:#75715e"># 操作链表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>TAIL &lt;span style="color:#f92672">=&lt;/span> TAIL&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#75715e"># 操作链表&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是在多线程环境下，维护尾节点需要对链表进行两次操作，我们很难把它做为原子的。这大概是实现无锁队列最大的难点之一。&lt;/p>
&lt;h3 id="框架代码">框架代码 &lt;a href="#%e6%a1%86%e6%9e%b6%e4%bb%a3%e7%a0%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>无锁队列中，&lt;code>push&lt;/code>和&lt;code>pop&lt;/code>两个函数是核心代码。但是我们需要先把框架代码先搭好。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">NonBlockingQueue&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NonBlockingQueue() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> head &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>dummy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InnerNode();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dummy.next &lt;span style="color:#f92672">=&lt;/span> tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// pass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>(T&lt;span style="color:#f92672">*&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// pass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">InnerNode&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> value_ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode dummy;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> head;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> tail;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的&lt;code>dummy&lt;/code>是一个假的头节点，是为了方便节点的插入的，可以替换成一个头节点指针。&lt;code>tail&lt;/code>是尾节点，在构造函数里，我们也将其置为一个假的尾节点，注意这里尾节点的设计，后文会再次提到。&lt;/p>
&lt;h3 id="出队操作">出队操作 &lt;a href="#%e5%87%ba%e9%98%9f%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们先从最简单的出队操作开始&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">pop&lt;/span>(T&lt;span style="color:#f92672">*&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">do&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> ACCESS_ONCE(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (cur &lt;span style="color:#f92672">==&lt;/span> tail) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#f92672">!&lt;/span>__sync_bool_compare_and_swap(&lt;span style="color:#f92672">&amp;amp;&lt;/span>(head&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next), cur, cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> item &lt;span style="color:#f92672">=&lt;/span> cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value_ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// delete(cur); &amp;lt;- why?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码中的&lt;code>__sync_bool_compare_and_swap&lt;/code>即上文所说的&lt;code>cmpxchg&lt;/code>函数，保证了赋值的原子性。&lt;/p>
&lt;p>操作过程非常简单，我们先找到位于队列头的值（HEAD节点后面的第一个）。然后使用CAS操作将其换出链表。&lt;/p>
&lt;p>由于tail节点是假的尾节点，所以在&lt;code>head-&amp;gt;next == tail&lt;/code>时，我们认为队列为空，返回false。&lt;/p>
&lt;p>这里有一点需要注意，&lt;code>cur&lt;/code>指针在while循环外看似已经脱离了链表，可以放心的删除了。但是由于其它线程仍有可能持有该指针，所以我们并不能在这里对它进行删除操作。&lt;/p>
&lt;p>在实际工程中，我们可以将其放置于一个回收队列中，待一小段时间后（如500ms），所有的线程都不持有该指针时，就可以安全的将其回收了。这里由于篇幅原因（注释：懒），就不实现了。&lt;/p>
&lt;h3 id="入队操作">入队操作 &lt;a href="#%e5%85%a5%e9%98%9f%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">push&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert (item &lt;span style="color:#f92672">!=&lt;/span> NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> cur &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> InnerNode&lt;span style="color:#f92672">*&lt;/span> newNode &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> InnerNode();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> ACCESS_ONCE(tail);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (__sync_bool_compare_and_swap(&lt;span style="color:#f92672">&amp;amp;&lt;/span>(cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>value_ptr), NULL, item)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> newNode;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tail &lt;span style="color:#f92672">=&lt;/span> tail&lt;span style="color:#f92672">-&amp;gt;&lt;/span>next;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的&lt;code>push&lt;/code>操作有一个trick，我们将&lt;code>tail-&amp;gt;value_ptr&lt;/code>做为“一把锁”。当&lt;code>value_ptr&lt;/code>为空时，tail指针代表着一个“假尾节点”。当我们向尾部追加数据时，先将数据写入&lt;code>value_ptr&lt;/code>，代表这个节点已经被“占领”。然后再向它的后面追加新的“假尾节点”，最后将指针移动过去。&lt;/p>
&lt;p>这样一来，进入&lt;code>if&lt;/code>代码块的线程一定是写入&lt;code>tail-&amp;gt;value_ptr&lt;/code>成功的那一个，后面的指针移动也是单线程的了。&lt;/p>
&lt;h2 id="感悟与可能的改进">感悟与可能的改进 &lt;a href="#%e6%84%9f%e6%82%9f%e4%b8%8e%e5%8f%af%e8%83%bd%e7%9a%84%e6%94%b9%e8%bf%9b" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>最近确实好久不写这么底层的代码，手生的厉害，对于多线程状态的分析也不是很灵光。确实需要多努力了。本文中的代码也许还有一些问题，所以欢迎大家指正。&lt;/p>
&lt;p>在写这段代码的过程中，感觉有如下需要注意的地方：&lt;/p>
&lt;ul>
&lt;li>析构一块内存是否是安全的，会不会别的线程仍在持有这块内存的指针&lt;/li>
&lt;li>编译器会不会给我们捣乱，比如重排指令等&lt;/li>
&lt;li>利用CAS的特性，我们可以实现一个锁的结构，但是以哪个变量/指针做为锁可以获得最好的效果&lt;/li>
&lt;/ul>
&lt;p>除了用链表实现队列之外，还可以使用环型数组。感觉上来说比使用链表更优雅一点。关键在于环型数组中隐含着前驱指针和后继节点的信息，所以不需要进行复杂的内存管理工作。&lt;/p>
&lt;p>完整实现请参考&lt;a href="https://paste.ubuntu.com/p/vYD6h5sm9n/">链接&lt;/a>，亲测在Ubuntu 16.04下使用&lt;code>g++ main.cc -lpthread&lt;/code>编译运行成功。（p.s. 不要加C++11标签，编不过的）&lt;/p>
&lt;h2 id="相关链接">相关链接 &lt;a href="#%e7%9b%b8%e5%85%b3%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://coolshell.cn/articles/8239.html">无锁队列的实现 - 酷壳&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>弱弱感觉文章里说的实现有问题（240414更新：其实是没有问题的，见勘误文章）&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1006241">共享内存无锁队列的实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>指出了实现上面可能踩到的坑&lt;/p>&lt;/blockquote>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1071029">一种高效无锁内存队列的实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>环形数组的实现&lt;/p>&lt;/blockquote></description></item></channel></rss>