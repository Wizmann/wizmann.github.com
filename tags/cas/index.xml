<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>CAS on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/cas/</link><description>Recent content in CAS on Maerlyn's Rainbow</description><generator>Hugo -- 0.146.0</generator><language>zh-CN</language><lastBuildDate>Sun, 14 Apr 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/cas/index.xml" rel="self" type="application/rss+xml"/><item><title>实现一个无锁消息队列（续与勘误）</title><link>https://wizmann.top/posts/implement-non-blocking-queue-2/</link><pubDate>Sun, 14 Apr 2024 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/implement-non-blocking-queue-2/</guid><description>&lt;ul>
&lt;li>本文内容主要参考自&lt;a href="https://people.cs.pitt.edu/~jacklange/teaching/cs2510-f17/implementing_lock_free.pdf">Implementing Lock-Free Queue&lt;/a>一文（以下简称“原论文”）&lt;/li>
&lt;li>是对&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">实现一个无锁消息队列&lt;/a>一文的内容进行补充&lt;/li>
&lt;li>
&lt;h2 id="tldr">TL；DR&lt;/h2>
&lt;ul>
&lt;li>尽管&lt;a href="https://wizmann.top/implement-non-blocking-queue.html">实现一个无锁消息队列&lt;/a>一文中的实现是正确的，但是忽略了“非阻塞性”
&lt;ul>
&lt;li>例如，当任一插入操作被阻塞，则其它插入操作均会陷入忙等待&lt;/li>
&lt;li>此实现与&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>的实现基本一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>对于一个支持并发的数据结构，理应同时具备非阻塞性和无等待性
&lt;ul>
&lt;li>非阻塞性（non-blocking）：无论是由于CPU调度或其他外部因素，数据结构的操作不能被中断或延迟&lt;/li>
&lt;li>无等待性（wait-free)：保证没有任何线程会遭受饥饿状态&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>前一篇博文对其它实现的质疑，主要在于ABA问题，但这个问题是Compare&amp;amp;Swap所特有的，需要特定的实现来规避&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="理论基础">理论基础&lt;/h2>
&lt;ul>
&lt;li>我们的目标是实现一个支持并发enqueue/deque的队列&lt;/li>
&lt;li>对于这样的数据结构，有两个重要的特性
&lt;ul>
&lt;li>非阻塞性（non-blocking）
&lt;ul>
&lt;li>对于每一个执行线程，所有的操作将会在有限的次数内完成&lt;/li>
&lt;li>无论本线程或其它线程在执行过程中因其它原因（如CPU调度）执行过缓，或者被中断&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无等待性（wait-free)
&lt;ul>
&lt;li>没有线程会饥饿&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>基于锁的数据结构不符合上述特性，因为持有锁的线程可能会无限期地阻塞所有操作&lt;/li>
&lt;li>“线性一致性”(Linearizability) —— 更强的正确性
&lt;ul>
&lt;li>非并发操作应当按照它们的逻辑顺序执行，以保证操作的正确性，而并发操作则可以按任意顺序进行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&amp;ldquo;Fetch&amp;amp;Add&amp;rdquo; 与 &amp;ldquo;Compare&amp;amp;Swap&amp;rdquo;
&lt;ul>
&lt;li>常用的原子操作，这里不做赘述&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="基于链表的无锁队列实现">基于链表的无锁队列实现&lt;/h2>
&lt;ul>
&lt;li>略，参考原论文与&lt;a href="https://coolshell.cn/articles/8239.html">无锁队列的实现&lt;/a>一文&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="基于数组的无锁队列实现">基于数组的无锁队列实现&lt;/h2>
&lt;ul>
&lt;li>略，参考原论文与&lt;a href="https://coolshell.cn/articles/8239.html">无锁队列的实现&lt;/a>一文&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="aba问题">ABA问题&lt;/h2>
&lt;ul>
&lt;li>Compare&amp;amp;Swap操作确保了值修改的原子性。指针作为值的一种，代表着某个内存地址，但Compare&amp;amp;Swap对指针的操作无法保证其指向的内存内容不被修改&lt;/li>
&lt;li>考虑到可能释放旧内存后再申请新内存，这两块内存虽逻辑不同却可能拥有同一地址，这对Compare&amp;amp;Swap操作造成了困扰&lt;/li>
&lt;li>解决方案是为指针加入引用计数（ref count），以确保内存在可访问时不会被释放或重用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="性能对比">性能对比&lt;/h2>
&lt;ul>
&lt;li>上面我们已经提到，&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>一文中的方法缺少了“非阻塞性”，，但其性能与原论文中的实现十分接近&lt;/li>
&lt;li>但是在原理上，“非阻塞性”实现可以避免意外的线程停止或延迟&lt;/li>
&lt;li>疑问：是否会在P99级别的Latency上才会体现出明显的差异？&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://people.cs.pitt.edu/~jacklange/teaching/cs2510-f17/implementing_lock_free.pdf">Implementing Lock-Free Queue&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dl.acm.org/doi/pdf/10.5555/110382.110466">A simple and correct shared-queue algorithm using Compare-and-Swap&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cs.nyu.edu/~wies/teaching/cso-fa19/class27_concurrency.pdf">Concurrency – Correctness of Concurrent Objects&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;h2 id="后续">后续&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.cs.rochester.edu/~scott/papers/1996_PODC_queues.pdf">Simple, Fast, and Practical Non-Blocking and Blocking Concurrent Queue Algorithms&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/690872647">C++ 单生产者&amp;amp;单消费者 无锁队列&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=K3P_Lmq6pw0&amp;amp;ab_channel=CppCon">Single Producer Single Consumer Lock-free FIFO From the Ground Up - Charles Frasch - CppCon 2023&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>在SPIN/Promela中模拟CAS（Compare-and-Swap）</title><link>https://wizmann.top/posts/simple-cas-model-in-spin-promela/</link><pubDate>Fri, 15 Dec 2023 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/simple-cas-model-in-spin-promela/</guid><description>&lt;p>CAS（Compare-And-Swap）是一种在多线程编程中常用的数据同步方法，它通过比较和交换操作来保证数据的一致性。然而，在SPIN/Promela中没有直接的CAS对应实现。&lt;/p></description></item><item><title>实现一个无锁消息队列</title><link>https://wizmann.top/posts/implement-non-blocking-queue/</link><pubDate>Wed, 02 May 2018 00:39:00 +0000</pubDate><guid>https://wizmann.top/posts/implement-non-blocking-queue/</guid><description>&lt;blockquote>
&lt;p>240414更新：后续补充了一篇勘误文章，见&lt;a href="https://wizmann.top/implement-non-blocking-queue-2.html">这里&lt;/a>&lt;/p>&lt;/blockquote>
&lt;h2 id="目标">目标&lt;/h2>
&lt;p>实现一个多读多写的无锁消息队列。&lt;/p>
&lt;h2 id="cmpxchg---比较并替换">cmpxchg - 比较并替换&lt;/h2>
&lt;p>比较并替换（compare-and-swap, CAS）是一个用于多线程同步的原子操作。&lt;/p></description></item></channel></rss>