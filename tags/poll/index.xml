<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Poll on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/poll/</link><description>Recent content in Poll on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Mon, 03 Oct 2016 22:22:14 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/poll/index.xml" rel="self" type="application/rss+xml"/><item><title>阻塞TCP流 - phxrpc代码阅读(3)</title><link>https://wizmann.top/posts/phxrpc-3/</link><pubDate>Mon, 03 Oct 2016 22:22:14 +0000</pubDate><guid>https://wizmann.top/posts/phxrpc-3/</guid><description>&lt;h2 id="写在前面">写在前面 &lt;a href="#%e5%86%99%e5%9c%a8%e5%89%8d%e9%9d%a2" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>phxrpc的流（&lt;code>stream&lt;/code>和&lt;code>streambuf&lt;/code>）与网络访问其实是耦合在一起的，所以本文可以结合着第一篇笔记一起来看。虽然我非常想吐槽这种强耦合性的设计，但是我决定还是好好理解phxrpc的设计之后。。。攒一波大的：）&lt;/p>
&lt;h2 id="blocktcpstreambuf">BlockTcpStreamBuf &lt;a href="#blocktcpstreambuf" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;code>class BlockTcpStreamBuf&lt;/code>继承自&lt;code>BaseTcpStreamBuf&lt;/code>。其中重写了&lt;code>precv&lt;/code>和&lt;code>psend&lt;/code>两个函数，并且持有了一个文件描述符(file descriptor)：&lt;code>socket_&lt;/code>。&lt;/p>
&lt;p>&lt;code>precv&lt;/code>和&lt;code>psend&lt;/code>直接调用了&lt;code>&amp;lt;sys/socket.h&amp;gt;&lt;/code>中的&lt;code>recv(2)&lt;/code>和&lt;code>send(2)&lt;/code>，并没有其它操作。&lt;/p>
&lt;p>网络相关的操作，则由&lt;code>class BlockTcpStream&lt;/code>来负责。&lt;code>BlockTcpStreamBuf&lt;/code>只负责IO部分。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (BaseTcpUtils&lt;span style="color:#f92672">::&lt;/span>SetNonBlock(sockfd, false)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> BaseTcpUtils&lt;span style="color:#f92672">::&lt;/span>SetNoDelay(sockfd, true)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stream&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Attach(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>} &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> phxrpc&lt;span style="color:#f92672">::&lt;/span>log(LOG_ERR, &lt;span style="color:#e6db74">&amp;#34;set nonblock fail&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> error &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> close(sockfd);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在&lt;code>BlockTcpStream&lt;/code>把fd传递给&lt;code>BlockTcpStreambuf&lt;/code>之前，需要把fd设置为&lt;code>block&lt;/code>的。而这段代码最大的槽点就是这个&lt;code>SetNonBlock&lt;/code>函数，和下面的&lt;code>set nonblock fail&lt;/code>日志（想一想）。完全让人摸不到头脑，达到一脸懵逼的最高境界。&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/87163832.jpg" alt="">&lt;/p>
&lt;p>由于&lt;code>recv&lt;/code>和&lt;code>send&lt;/code>函数是&lt;code>block&lt;/code>的，所以在读取、写入缓冲区时，如果没有足够的数据可读或没有足够的空间可写，则读取写入操作会阻塞住。&lt;/p>
&lt;h2 id="blocktcpstream">BlockTcpStream &lt;a href="#blocktcpstream" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在这里我又想吐个槽了，为啥在这里把TCP Server和Client的工作流混为一谈。我觉得至少应该从命名上区分一下，否则极容易误用。&lt;/p>
&lt;h3 id="tcp的工作流程">TCP的工作流程 &lt;a href="#tcp%e7%9a%84%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/92621506.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：UNIX网络编程卷一：套接字编程 4.2节&lt;/p>&lt;/blockquote>
&lt;p>从图中我们可以看到，TCP的服务端与客户端的工作流程是不同的，相对来说，客户端的程序要简单一些。&lt;/p>
&lt;p>&lt;code>BlockTcpStream&lt;/code>中，客户端应用的函数只有&lt;code>BlockTcpUtils::Open&lt;/code>，而服务端的&lt;code>BlockTCPUtils::Listen&lt;/code>函数包括了&lt;code>bind()&lt;/code>和&lt;code>listen()&lt;/code>两个操作，而&lt;code>accept()&lt;/code>则需要开发者手动调用。&lt;/p>
&lt;h3 id="so_reuseaddr">SO_REUSEADDR &lt;a href="#so_reuseaddr" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在服务端的&lt;code>Listen()&lt;/code>函数中，phxrpc使用了&lt;code>SO_REUSEADDR&lt;/code>选项，这个选项的意在通知内核：如果端口忙，但是TCP状态位于&lt;code>TIME_WAIT&lt;/code>时，可以重用端口。&lt;/p>
&lt;p>一个套接字其实是一个&lt;code>（协议，源地址，源端口，目标地址，目标端口）&lt;/code>五元组。&lt;code>SO_REUSEADDR&lt;/code>意味着我们可以重用源地址和源端口。当然此时的风险在于如果该原套接字发送了一些错误的数据，此时我们的应用程序的TCP工作流就会产生错乱。但是由于TCP的实现中，通过随机的消息序号规避了这个问题，所以这里的风险可以忽略不计。&lt;/p>
&lt;p>使用&lt;code>SO_REUSEADDR&lt;/code>的好处是，在服务端程序崩溃和退出时（对于一般的服务端程序来说，崩溃和退出是没有区别的），可以立即重启，而不需要等待2MSL时间。&lt;/p>
&lt;p>那么我们要问了，为什么在这里我们需要等待2MSL时间呢。&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/33186679.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：Effective TCP/IP 3.8节&lt;/p>&lt;/blockquote>
&lt;p>TCP拆除连接使用了四次握手的机制，而主动关闭连接的一方在发送完最后一个ACK之后，需要等待2MSL的时间。这就是上面所说的，当服务器重启后，出现&lt;code>Address already in use&lt;/code>的报错信息，需要额外等待大约1~4分钟的原因。&lt;/p>
&lt;p>究其原因，TIME-WAIT状态的意图在于避免主动关闭连接的一端最后一个ACK发送失败。此时，主机1已经完全关闭，而主机2因为没有收到FIN包的ACK，处于半关闭状态。此时主机2向主机1发送的任何信息（如延迟的ACK包等）都只会收到RST，导致连接的异常关闭。&lt;/p>
&lt;p>为了规避这个问题，主动关闭端需要等待2MSL时间。一个MSL是给最后的ACK包，而另外一个MSL，是为了等待被动关闭端重新发送FIN包。如果在TIME_WAIT期间收到了对端的数据包，会刷新TIME_WAIT状态的时间。&lt;/p>
&lt;blockquote>
&lt;p>参考：Effective TCP/IP 3.8 3.9节&lt;/p>&lt;/blockquote>
&lt;h3 id="io复用poll">IO复用：Poll &lt;a href="#io%e5%a4%8d%e7%94%a8poll" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/84501111.jpg" alt="">&lt;/p>
&lt;blockquote>
&lt;p>图片来源：UNIX网络编程卷一：套接字编程 6.2节&lt;/p>&lt;/blockquote>
&lt;p>IO复用是指内核在发现进程指定的一个或多个IO条件就绪，内核就通知进程。通常来讲，常用的IO复用函数有&lt;code>select()&lt;/code>和&lt;code>poll()&lt;/code>。&lt;/p>
&lt;p>当&lt;code>poll()&lt;/code>返回后，我们需要遍历其中的fd数组找到可操作的fd。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">pollfd&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> fd; &lt;span style="color:#75715e">/* file descriptor */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">short&lt;/span> events; &lt;span style="color:#75715e">/* requested events */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">short&lt;/span> revents; &lt;span style="color:#75715e">/* returned events */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以从&lt;code>events&lt;/code>和&lt;code>revents&lt;/code>获得该fd的状态，从而判别可读、可写、超时或出错。&lt;/p>
&lt;p>在这里，我们并没有使用poll函数的IO复用能力，而是把它做为另一个阻塞IO调用来使用。&lt;/p>
&lt;p>&lt;code>BlockTcpUtils::Open&lt;/code>函数中，我们使用了poll，用来监视相应的（一个）fd是否可读。这样一来，我们就隐式（为什么说隐式呢，因为他们一不写文档，二不写注释，一切都是潜规则）规定了C/S交互的基本工作流程：当C/S连接建立后，Server端要先说话，Client端接收到消息之后，才可以进行下面的流程。&lt;/p>
&lt;blockquote>
&lt;p>Client：“不管你们信不信，是Server先动的手。”&lt;/p>&lt;/blockquote>
&lt;p>具体为什么先用poll，再把fd设为&lt;code>blocking&lt;/code>的，我表示二脸懵逼。在我的实验中，即使把poll删掉，测试代码也是可以work的。可能在后面的代码阅读中，这个问题可以获得解释吧。&lt;/p>
&lt;p>和select一样，poll也存在被中断的情况，在phxrpc的代码里，我们给了中断“a second chance”。当poll被中断后，会重新再poll一次；如果这次再被中断，则直接返回TIMEOUT。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// retry again for EINTR
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">::&lt;/span>poll(&lt;span style="color:#f92672">&amp;amp;&lt;/span>pfd, &lt;span style="color:#ae81ff">1&lt;/span>, timeout_ms);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">==&lt;/span> ret &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> EINTR &lt;span style="color:#f92672">==&lt;/span> errno)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">==&lt;/span> ret)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> errno &lt;span style="color:#f92672">=&lt;/span> ETIMEDOUT;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="写在最后">写在最后 &lt;a href="#%e5%86%99%e5%9c%a8%e6%9c%80%e5%90%8e" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>由于这篇文章中的知识点比较杂，写作的顺序也是随机的。所以连贯性不是那么强。如果有什么问题，忍着点吧您就。&lt;/p>
&lt;p>忍不了的话。。。那就留言交流吧~&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-pic/16-10-3/42112021.jpg" alt="">&lt;/p></description></item></channel></rss>