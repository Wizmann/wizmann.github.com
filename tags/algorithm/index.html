<!doctype html><html lang=zh-cn dir=auto><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Algorithm</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>2020 计蒜之道 线上决赛 - C. 攀登山峰</h2></header><div class=entry-content><p>本文使用了一种概率算法，不是正解，只求骗分。
题意 原题
给一个长度为n的数组A[1…n]。
现在有q个查询请求（q &lt;= 1e5），每个请求给定一个长度为m的子数组A[i…j]和一个整数t。问在子数组中出现次数超过m/t的数字中（t &lt;= 20），最大的数是多少。
...</p></div><footer class=entry-footer><span title='2020-10-26 00:00:00 +0000 UTC'>October 26, 2020</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 2020 计蒜之道 线上决赛 - C. 攀登山峰" href=https://wizmann.top/posts/jisuanke-climb-the-hill/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>容斥原理以及一些题目</h2></header><div class=entry-content><p>什么是容斥原理 容斥原理是一种计数手段。例如在下图中，我们想不重复、不遗漏的求出包含在ABC三个集合中所包含的元素的个数，应该使用怎么样的方法呢？
这个问题对于我们来说并不陌生，当然也并不困难。直观的方法是把所有的元素计数，再把重复的元素排除出去。这种计数的方法，有“容”有“斥”，我们讲其称做“容斥原理”。
...</p></div><footer class=entry-footer><span title='2018-10-14 00:00:00 +0000 UTC'>October 14, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 容斥原理以及一些题目" href=https://wizmann.top/posts/inclusive-exclusive-principle/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>一种区间交问题的奇怪姿势</h2></header><div class=entry-content><p>Update[220504]: 原来这种数据结构叫珂朵莉树啊，真神奇。。。
我们要解决什么问题 区间交问题，是我们在做题中经常遇到的问题。
例如，Insert Interval一题，就是比较直白的区间交问题：
给定一系列的整数区间，再插入一个新的区间，问合并后的整数区间是什么
...</p></div><footer class=entry-footer><span title='2018-02-20 22:59:47 +0000 UTC'>February 20, 2018</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 一种区间交问题的奇怪姿势" href=https://wizmann.top/posts/range-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Beauty-of-Programming 2015 Qualification Round Tutorial</h2></header><div class=entry-content><p>A. 2月29日 (Feb. 29th) Description Given a starting date and an ending date. Count how many Feb. 29th are between the given dates.
Solution The easiest way, of course, the brute force, which is quite simple with Python using the datetime lib.
However, it’s not an effective way for the problem.
Let simplify the problem. “How many Feb. 29th from year A to year B?” Actually, it’t not a hard one. But there is a pitfall. Loot at this.
...</p></div><footer class=entry-footer><span title='2015-04-25 00:54:08 +0000 UTC'>April 25, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Beauty-of-Programming 2015 Qualification Round Tutorial" href=https://wizmann.top/posts/beauty-of-programming-2015-qualification-round/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>GCJ Qualification Round 2015 题解</h2></header><div class=entry-content><p>前言 这篇日志用中文写是因为想省点时间打游戏。。。（请鄙视我吧。。。
A. Standing Ovation 题意 这是一个骗掌声的故事。
当演出结束后，观众们要站起来鼓掌。但是有些观众比较羞涩，只有在k个人站起来鼓掌后才会故障。
...</p></div><footer class=entry-footer><span title='2015-04-12 00:00:00 +0000 UTC'>April 12, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to GCJ Qualification Round 2015 题解" href=https://wizmann.top/posts/gcj-qualification-round-2015-tutorial/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #290 (Div. 2) Tutorial</h2></header><div class=entry-content><p>A. Fox And Snake Implementation
(n, m) = map(int, raw_input().split()) res = [] for i in xrange(n): if i % 2 == 0: res.append('#' * m) elif (i / 2) % 2 == 0: res.append('.' * (m - 1) + '#') else: res.append('#' + '.' * (m - 1)) for line in res: print line B. Fox And Two Dots DFS
A A A A B A A C A A A A We start at arbitrary point, and traverse the neighbour point with the same color to see if there is a circle.
...</p></div><footer class=entry-footer><span title='2015-02-18 00:30:24 +0000 UTC'>February 18, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #290 (Div. 2) Tutorial" href=https://wizmann.top/posts/cf-290-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #289 (Div. 2) Tutorial</h2></header><div class=entry-content><p>A. Maximum in Table Simulation.
n = int(raw_input()) g = [[1 for i in xrange(n)] for j in xrange(n)] for i in xrange(1, n): for j in xrange(1, n): g[i][j] = g[i - 1][j] + g[i][j - 1] print g[n - 1][n - 1] B. Painting Pebbles Reading comperhension & Constructive.
The key point of this problem is abs(b(i, c) - b(j, c)) &lt;= 1.
First of all, it’s safe to paint k pebbles of every pile with the same color, when k = min(piles). At this moment, every b(i, c) - b(j, c) == 0.
...</p></div><footer class=entry-footer><span title='2015-02-16 21:16:31 +0000 UTC'>February 16, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #289 (Div. 2) Tutorial" href=https://wizmann.top/posts/cf-289-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #288 (Div. 2)</h2></header><div class=entry-content><p>A. Pasha and Pixels Brute force.
There are multiple ways to form a 2*2 square at one single step.
So at every step, we have to check the neighbours of pixel that is colored black.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;vector> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x const int SIZE = 1024 + 123; const int mx[] = {0, 1, 0, 1}; const int my[] = {0, 0, 1, 1}; const int MOVE = 4; int mp[SIZE][SIZE]; int n, m, k; bool isBlackBlock(int y, int x) { int cnt = 0; for (int i = 0; i &lt; MOVE; i++) { int ny = y + my[i]; int nx = x + mx[i]; if (ny >= 0 && ny &lt; n && nx >= 0 && nx &lt; m && mp[ny][nx]) { cnt++; } } return cnt == MOVE; } int main() { int y, x; input(n >> m >> k); memset(mp, 0, sizeof(mp)); int ans = 0; for (int i = 0; i &lt; k; i++) { input(y >> x); x--; y--; mp[y][x] = 1; bool flag = false; for (int j = 0; j &lt; MOVE; j++) { flag |= isBlackBlock(y - my[j], x - mx[j]); } if (flag) { ans = i + 1; break; } } print(ans); return 0; } B. Anton and currency you all know At first, you have to understand the questions accurately.
...</p></div><footer class=entry-footer><span title='2015-02-16 21:16:30 +0000 UTC'>February 16, 2015</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #288 (Div. 2)" href=https://wizmann.top/posts/cf-288-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Snake Problem</h2></header><div class=entry-content><p>题目 在一个平面上，有n+m条蛇，其中n条蛇沿水平方向（y轴方向）移动，m条蛇沿竖直方向（x轴方向）移动。
现给出这些蛇头和尾所在的坐标点，求出这n+m条蛇在此时共有多少个交点。在同一个方向移动的蛇不会有交点。
...</p></div><footer class=entry-footer><span title='2014-10-20 09:11:27 +0000 UTC'>October 20, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Snake Problem" href=https://wizmann.top/posts/snake-problem/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>思维训练 - Thinkin' in induction 2</h2></header><div class=entry-content><p>最大导出子图（maximal induced graph） 你现在在组织一个学术会议。现在你有一份人员名单。假定名单中的每一个人都同意到达，并且有充足的时间交流意见。同时，每一个科学家都写下了他愿意与其进行交流的科学家的名字。
...</p></div><footer class=entry-footer><span title='2014-10-01 00:05:29 +0000 UTC'>October 1, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 思维训练 - Thinkin' in induction 2" href=https://wizmann.top/posts/thinking-in-induction-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>最小表示法及其证明</h2></header><div class=entry-content><p>问题 对于一个字符串S，求S的循环的同构字符串S’中字典序最小的一个。
我们举例说明，字符串"abcd"的循环同构字符串有：["abcd", "bcda", "cdab", "dabc"]。
...</p></div><footer class=entry-footer><span title='2014-09-17 00:46:16 +0000 UTC'>September 17, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 最小表示法及其证明" href=https://wizmann.top/posts/minimal-round-string/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Single Number Problem</h2></header><div class=entry-content><p>Introduction There are a lot of interview problem based on the 1D-array, which is the one of the easiest “data structure”.
But the problem about that simple data structure might not be that simple. Here is the summary of the problem about 1D-array.
Of course, most of them come from Leetcode.
All Twice Excpet One Given an array of integers, every element appears twice except for one. Find that single one.
...</p></div><footer class=entry-footer><span title='2014-08-05 23:07:02 +0000 UTC'>August 5, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Single Number Problem" href=https://wizmann.top/posts/single-number-in-the-array/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces 447D DZY Loves Modification</h2></header><div class=entry-content><p>题意 给你一个n * m的矩阵，让你做K次操作，使得最后得到的值最大。
操作有两种：
一是在任意一行上操作，最终的结果值加上这一行数的和，然后这一行每一个数都要减去p。
...</p></div><footer class=entry-footer><span title='2014-07-24 23:44:44 +0000 UTC'>July 24, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces 447D DZY Loves Modification" href=https://wizmann.top/posts/cf-447d/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>玩玩算法题1：Sherlock and Queries</h2></header><div class=entry-content><p>题目大意 给你三个数组:A[N], B[M], C[M]。让你按如下pseudo-code给出的规则计算，求出最终A[N]每一项的值。
f e o n r d i f e d o n o = r d 1 j i e d f n o t = d o j i 1 A f M % [ t j d o B ] o [ N i = ] d A o = [ = j ] 0 t h C e [ n i ] 数据范围 1≤ N,M ≤ 10^5
...</p></div><footer class=entry-footer><span title='2014-07-19 11:00:38 +0000 UTC'>July 19, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 玩玩算法题1：Sherlock and Queries" href=https://wizmann.top/posts/interview-problem-1-sherlock-and-queries/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #253 Tutorial</h2></header><div class=entry-content><p>443A - Anton and Letters Simple and easy, solved by two lines of python code.
ls = filter(lambda y: y, map(lambda x: x.strip(), raw_input()[1:-1].split(","))) print len(set(ls)) 443B - Kolya and Tandem Repeat Brute force. Just enumerate the beginning and the end of the substring, and check if that substring is tandem repeat.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;algorithm> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x string str; int k; int main() { freopen("input.txt", "r", stdin); input(str >> k); for (int i = 0; i &lt; k; i++) { str += '?'; } int len = str.length(); int ans = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == '?') { break; } for (int j = 1; i + j &lt; len; j += 2) { int slip = (j + 1) / 2; for (int k = 0; k &lt; slip; k++) { if (str[i + k] == str[i + k + slip] || str[i + k + slip] == '?') { /* pass */; } else { goto fail; } } ans = max(ans, j + 1); fail: /*pass*/; } } print(ans); return 0; } 442A - Borya and Hanabig Because Borya knows about the color and value of all his cards, he just need to distinguish each card from the others.
...</p></div><footer class=entry-footer><span title='2014-06-21 19:24:37 +0000 UTC'>June 21, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #253 Tutorial" href=https://wizmann.top/posts/cf-253/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>A simple problem - World at War</h2></header><div class=entry-content><p>Background This problem is from the book “Algorithm 4th edition” (Exersise 4.1.10)
There are N cities and M undirected roads between those cities. People can travel to any city along the roads.
One day, a war breaks out. Our cities are under attack! As we can’t defend all these N cities, the commander wants you to find the least important city, which means that if this city fell to the enemy, the traffic among other cities would not be affected.
...</p></div><footer class=entry-footer><span title='2014-06-12 17:42:51 +0000 UTC'>June 12, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to A simple problem - World at War" href=https://wizmann.top/posts/world-at-war/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>How to implement a queue with stack(s)?</h2></header><div class=entry-content><p>This problem is from the book Algorithms, 4th Edition.
Queue with three stacks. Implement a queue with three stacks so that each queue operation takes a constant (worst-case) number of stack operations.
Warning : high degree of difficulty.
When I search the Internet to find a solution, I find varieties of this problem, such as “implement a queue with ONE stack”, “implement a queue with TWO stack”, etc.
It is fun, indeed. I spent the whole morning to finding the solution of these problems. So, let’s rock.
...</p></div><footer class=entry-footer><span title='2014-05-20 13:23:03 +0000 UTC'>May 20, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to How to implement a queue with stack(s)?" href=https://wizmann.top/posts/implement-queue-with-stacks/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #242 (Div. 2) Tutorials and Solutions</h2></header><div class=entry-content><p>A. Squats Trun x => X or X => x to make the number of ‘x’ is equal to the number of ‘X’.
n = int(raw_input()) hamsters = [c for c in raw_input()] sits = hamsters.count('x') stands = hamsters.count('X') if sits == stands: print 0 print ''.join(hamsters) else: if sits > stands: num = sits - n/2 key = 'x' else: num = stands - n/2 key = 'X' print num for i, c in enumerate(hamsters): if c == key: hamsters[i] = c.swapcase() num -= 1 if not num: break print ''.join(hamsters) B. Megacity Binary search.
...</p></div><footer class=entry-footer><span title='2014-04-30 17:39:00 +0000 UTC'>April 30, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #242 (Div. 2) Tutorials and Solutions" href=https://wizmann.top/posts/cf-242-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)</h2></header><div class=entry-content><p>Overview It has been months that I didn’t participate in the contest on CF, now I’m back. :)
This round of contest makes me confused that the problem B and C is a little bit too twisted, if you can’t catch the vital point, you will get a lot of WAs in the end.
Additionally, the problem D is too easy, just a simple DP and the time limit is too long for an unoptimized solution.
...</p></div><footer class=entry-footer><span title='2014-04-08 14:39:11 +0000 UTC'>April 8, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect)" href=https://wizmann.top/posts/cf-240-div-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>Codeforces Round #223 (Div. 2) 不完全不正确题解</h2></header><div class=entry-content><p>由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱
事情一直很多，所以题解落后了好久才发。
A. Sereja and Dima 纯模拟，Python随便搞
...</p></div><footer class=entry-footer><span title='2014-01-18 14:47:00 +0000 UTC'>January 18, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to Codeforces Round #223 (Div. 2) 不完全不正确题解" href=https://wizmann.top/posts/cf-223-div-2/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wizmann.top/tags/algorithm/page/2/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>