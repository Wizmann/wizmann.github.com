<!doctype html><html lang=zh-CN dir=ltr><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=notransition><div id=container><header id=main-header><div role=navigation aria-label=Main><div class=nav-left><a href=https://wizmann.top/ style=color:inherit>Maerlyn's Rainbow</a></div><div class=nav-right><div style=position:absolute;width:0;height:0><div id=nav-dropdown-menu class=hidden href=#><div class=nav-item><a href=/posts/>Posts</a></div></div></div><a id=nav-dropdown-button href=#><svg width="20" height="20" viewBox="0 0 24 24" fill="none"><path d="M4 6H20M4 12H20M4 18H20" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a><div id=nav-menu><div class=nav-item><a href=/posts/>Posts</a></div></div><a id=theme-switcher href=#><svg class="light-icon" viewBox="0 0 24 24" fill="none"><path d="M12 3V4m0 16v1M4 12H3M6.31412 6.31412 5.5 5.5m12.1859.81412L18.5 5.5M6.31412 17.69 5.5 18.5001M17.6859 17.69 18.5 18.5001M21 12H20m-4 0c0 2.2091-1.7909 4-4 4-2.20914.0-4-1.7909-4-4 0-2.20914 1.79086-4 4-4 2.2091.0 4 1.79086 4 4z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg><svg class="dark-icon" viewBox="0 0 24 24" fill="none"><path d="M3.32031 11.6835c0 4.9706 4.02944 9 8.99999 9 3.7872.0 7.028-2.3392 8.3565-5.6515C19.6402 15.4486 18.5059 15.6834 17.3203 15.6834c-4.9706.0-8.99999-4.0294-8.99999-8.99998C8.32031 5.50338 8.55165 4.36259 8.96453 3.32996 5.65605 4.66028 3.32031 7.89912 3.32031 11.6835z" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg></a></div></div></header><div class="flex grow"><div id=main-pane><main id=main-content><h1>Cpp</h1><div class=list-group-key>2025</div><div class=list-group-heading><a href=/posts/std-smart-ptrs-cpp-for-the-antiquated-4/>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Jan 21</time></div><div class="list-group-summary content-font">智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。</div><div class=list-group-heading><a href=/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/>std::visit实现运行时多态 - C++ for the Antiquated（之三）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Jan 4</time></div><div class="list-group-summary content-font">在传统的 C++ 中，运行时多态 通常依赖于 “接口 - 虚函数” 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 子类型多态（Subtype Polymorphism）。</div><div class=list-group-heading><a href=/posts/std-visit-cpp-for-the-antiquated-2/>动手实现std::visit - C++ for the Antiquated（之二）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Jan 1</time></div><div class="list-group-summary content-font">std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。</div><div class=list-group-key>2024</div><div class=list-group-heading><a href=/posts/constexpr-cpp-for-the-antiquated-1/>constexpr详解 - C++ for the Antiquated（之一）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Dec 28</time></div><div class="list-group-summary content-font">在这篇文章中，我们将深入讨论 C++ 中的常量表达式（constexpr）及其与传统的const常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨constexpr函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。</div><div class=list-group-heading><a href=/posts/cache-coherence-and-memory-order-2/>CPU缓存一致性与内存一致性（第二部分-内存一致性）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Sep 1</time></div><div class="list-group-summary content-font">缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。</div><div class=list-group-heading><a href=/posts/cache-coherence-and-memory-order/>CPU缓存一致性与内存一致性（第一部分-MESI协议）</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>Mar 18</time></div><div class="list-group-summary content-font">缓存一致性是指在一个多处理器系统中，确保当某个处理器修改了存储在共享资源（如主内存或缓存中的数据）时，其他处理器能够访问到最新的数据版本，从而保证数据的一致性。</div><div class=list-group-key>2014</div><div class=list-group-heading><a href=/posts/read-paper-barrier/>内存屏障初探</a>
<time class=dim style=float:right datetime=2023-05-02T00:00:00Z>May 8</time></div><div class="list-group-summary content-font">Barrier February 17th, 2007</div><ul class="pagination pagination-default"><li class="page-item disabled"><a aria-disabled=true aria-label=First class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;&#171;</span></a></li><li class="page-item disabled"><a aria-disabled=true aria-label=Previous class=page-link role=button tabindex=-1><span aria-hidden=true>&#171;</span></a></li><li class="page-item active"><a aria-current=page aria-label="Page 1" class=page-link role=button>1</a></li><li class=page-item><a href=/tags/cpp/page/2/ aria-label="Page 2" class=page-link role=button>2</a></li><li class=page-item><a href=/tags/cpp/page/2/ aria-label=Next class=page-link role=button><span aria-hidden=true>&#187;</span></a></li><li class=page-item><a href=/tags/cpp/page/2/ aria-label=Last class=page-link role=button><span aria-hidden=true>&#187;&#187;</span></a></li></ul></main><footer id=main-footer><div class=footer><a href=#></a><div class=footer-copyright><div class=dim>© 2025</div><div></div></div></div></footer></div></div></div></body></html>