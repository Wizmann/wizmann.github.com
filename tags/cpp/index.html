<!doctype html><html lang=zh-cn dir=auto><head><script>window.MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]]},svg:{fontCache:"global"}}</script><script defer src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><header class=page-header><h1>Cpp</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</h2></header><div class=entry-content><p>智能指针（如 std::shared_ptr 和 std::weak_ptr）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 boost::shared_ptr 和 boost::weak_ptr，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。
...</p></div><footer class=entry-footer><span title='2025-01-21 00:00:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 动手实现智能指针 （上篇） - C++ for the Antiquated（之四）" href=https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>std::visit实现运行时多态 - C++ for the Antiquated（之三）</h2></header><div class=entry-content><p>在传统的 C++ 中，运行时多态 通常依赖于 “接口 - 虚函数” 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 子类型多态（Subtype Polymorphism）。
...</p></div><footer class=entry-footer><span title='2025-01-04 00:00:00 +0000 UTC'>January 4, 2025</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to std::visit实现运行时多态 - C++ for the Antiquated（之三）" href=https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>动手实现std::visit - C++ for the Antiquated（之二）</h2></header><div class=entry-content><p>std::variant 与 std::visit std::variant std::variant 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 union 不同，std::variant 能够在运行时安全地检查当前存储的类型，避免未定义行为。
...</p></div><footer class=entry-footer><span title='2025-01-01 00:00:00 +0000 UTC'>January 1, 2025</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 动手实现std::visit - C++ for the Antiquated（之二）" href=https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>constexpr详解 - C++ for the Antiquated（之一）</h2></header><div class=entry-content><p>在这篇文章中，我们将深入讨论 C++ 中的常量表达式（constexpr）及其与传统的const常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨constexpr函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。
...</p></div><footer class=entry-footer><span title='2024-12-28 00:00:00 +0000 UTC'>December 28, 2024</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to constexpr详解 - C++ for the Antiquated（之一）" href=https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CPU缓存一致性与内存一致性（第二部分-内存一致性）</h2></header><div class=entry-content><p>缓存一致性与内存一致性 缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。
缓存一致性协议（如 MESI 协议）用于解决多个处理器对相同内存位置进行访问和修改时的数据一致性问题。它确保各处理器的缓存中针对同一内存地址的副本保持一致，避免因缓存不同步而导致的数据错误。
...</p></div><footer class=entry-footer><span title='2024-09-01 00:24:00 +0000 UTC'>September 1, 2024</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to CPU缓存一致性与内存一致性（第二部分-内存一致性）" href=https://wizmann.top/posts/cache-coherence-and-memory-order-2/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>CPU缓存一致性与内存一致性（第一部分-MESI协议）</h2></header><div class=entry-content><p>在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。 然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。
...</p></div><footer class=entry-footer><span title='2024-03-18 23:21:35 +0000 UTC'>March 18, 2024</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to CPU缓存一致性与内存一致性（第一部分-MESI协议）" href=https://wizmann.top/posts/cache-coherence-and-memory-order/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>内存屏障初探</h2></header><div class=entry-content><p>原文地址 Barrier February 17th, 2007
前言：多核时代的挑战 尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。
...</p></div><footer class=entry-footer><span title='2014-05-08 19:05:26 +0000 UTC'>May 8, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 内存屏障初探" href=https://wizmann.top/posts/read-paper-barrier/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>alloca vs placement new</h2></header><div class=entry-content><p>WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.
...</p></div><footer class=entry-footer><span title='2014-04-07 21:08:59 +0000 UTC'>April 7, 2014</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to alloca vs placement new" href=https://wizmann.top/posts/alloca-vs-placement-new/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2 class=entry-hint-parent>使用新类型创建更人性化的代码</h2></header><div class=entry-content><p>啥？ 这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。
关键词：
RAII 智能指针 接口友好 模板 模板特化 依赖编译器的缺省行为 对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。
...</p></div><footer class=entry-footer><span title='2013-12-09 15:01:00 +0000 UTC'>December 9, 2013</span>&nbsp;·&nbsp;wizmann</footer><a class=entry-link aria-label="post link to 使用新类型创建更人性化的代码" href=https://wizmann.top/posts/humanity-code-with-new-classes/></a></article></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>