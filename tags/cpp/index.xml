<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cpp on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/cpp/</link><description>Recent content in Cpp on Maerlyn's Rainbow</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Tue, 21 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</title><link>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</guid><description>&lt;p>智能指针（如 &lt;code>std::shared_ptr&lt;/code> 和 &lt;code>std::weak_ptr&lt;/code>）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 &lt;code>boost::shared_ptr&lt;/code> 和 &lt;code>boost::weak_ptr&lt;/code>，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。&lt;/p>
&lt;p>本文将围绕以下主题展开讨论：&lt;/p>
&lt;ul>
&lt;li>C++ 智能指针的实现原理&lt;/li>
&lt;li>非侵入式智能指针与侵入式智能指针的区别&lt;/li>
&lt;li>利用 &lt;code>atomic&lt;/code> 避免多线程竞态条件&lt;/li>
&lt;li>如何实现侵入式版本的 &lt;code>shared_ptr&lt;/code> 和 &lt;code>weak_ptr&lt;/code>&lt;/li>
&lt;li>采用 &lt;code>concept&lt;/code> 约束模板类型&lt;/li>
&lt;li>探讨完美转发（&lt;code>std::forward&amp;lt;T&amp;gt;&lt;/code>）在智能指针中的应用&lt;/li>
&lt;/ul>
&lt;h2 id="c-中的智能指针">C++ 中的智能指针 &lt;a href="#c-%e4%b8%ad%e7%9a%84%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="stdshared_ptr的实现">&lt;code>std::shared_ptr&lt;/code>的实现 &lt;a href="#stdshared_ptr%e7%9a%84%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>std::shared_ptr&lt;/code> 是一种智能指针，能够自动管理对象的生命周期。它通过引用计数的方式来跟踪有多少个 &lt;code>shared_ptr&lt;/code> 实例指向同一个对象，确保当最后一个 &lt;code>shared_ptr&lt;/code> 被销毁时，对象的内存能够自动释放。&lt;/p>
&lt;h4 id="引用计数与原子操作">引用计数与原子操作 &lt;a href="#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e4%b8%8e%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>&lt;code>std::shared_ptr&lt;/code> 的核心机制是引用计数。每个 &lt;code>shared_ptr&lt;/code> 会维护一个引用计数。当多个 &lt;code>shared_ptr&lt;/code> 指向同一个对象时，计数器会增加；当一个 &lt;code>shared_ptr&lt;/code> 被销毁时，计数器会减少。如果计数器归零，表明没有任何 &lt;code>shared_ptr&lt;/code> 再指向该对象，这时对象会被删除。&lt;/p>
&lt;p>引用计数通常由一个控制块（control block）管理。控制块不仅保存引用计数，还会保存对象本身以及与对象生命周期相关的其他信息。&lt;code>std::shared_ptr&lt;/code> 的实现一般使用“非侵入式引用计数”（即不嵌入对象本身）。&lt;/p>
&lt;p>示例代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">control_block&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block(T&lt;span style="color:#f92672">*&lt;/span> ptr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ref_count(&lt;span style="color:#ae81ff">1&lt;/span>), obj(ptr) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_ref&lt;/span>() { &lt;span style="color:#f92672">++&lt;/span>ref_count; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 减少引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>ref_count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj; &lt;span style="color:#75715e">// 删除对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// 删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> obj; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ref_count; &lt;span style="color:#75715e">// 引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> obj; &lt;span style="color:#75715e">// 实际对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="简化版-shared_ptr-实现">简化版 &lt;code>shared_ptr&lt;/code> 实现 &lt;a href="#%e7%ae%80%e5%8c%96%e7%89%88-shared_ptr-%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>下面是一个简化版的 &lt;code>shared_ptr&lt;/code> 实现示例。这个版本仍然有一些重要细节需要注意，比如原子操作和异常安全等问题，但可以帮助理解 &lt;code>shared_ptr&lt;/code> 的基本原理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">my_shared_ptr&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;*&lt;/span> ctrl_block;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> my_shared_ptr(T&lt;span style="color:#f92672">*&lt;/span> p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">nullptr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ptr(p), ctrl_block(&lt;span style="color:#66d9ef">new&lt;/span> control_block&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(p)) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 拷贝构造函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> my_shared_ptr(&lt;span style="color:#66d9ef">const&lt;/span> my_shared_ptr&lt;span style="color:#f92672">&amp;amp;&lt;/span> other)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ptr(other.ptr), ctrl_block(other.ctrl_block) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ctrl_block) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl_block&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 析构函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">~&lt;/span>my_shared_ptr() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ctrl_block) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl_block&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> ptr; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">*&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>ptr; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="stdweak_ptr的实现">&lt;code>std::weak_ptr&lt;/code>的实现 &lt;a href="#stdweak_ptr%e7%9a%84%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>std::weak_ptr&lt;/code> 是与 &lt;code>std::shared_ptr&lt;/code> 配合使用的智能指针，它解决了 &lt;code>shared_ptr&lt;/code> 在某些场景下的循环引用问题。&lt;/p>
&lt;p>循环引用问题发生在两个或多个对象通过 &lt;code>shared_ptr&lt;/code> 相互引用时，导致引用计数永远不为零，从而引发内存泄漏。为了避免这个问题，我们引入了 &lt;code>weak_ptr&lt;/code>。&lt;/p>
&lt;h4 id="为什么需要-weak_ptr">为什么需要 &lt;code>weak_ptr&lt;/code> &lt;a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81-weak_ptr" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>&lt;code>std::weak_ptr&lt;/code> 不增加引用计数，因此它不会影响对象的生命周期。当一个对象的所有 &lt;code>shared_ptr&lt;/code> 被销毁后，&lt;code>weak_ptr&lt;/code> 将变为“悬挂”状态。这与普通指针的“空悬指针”（dangling pointer）不同，空悬的 &lt;code>weak_ptr&lt;/code> 会返回空指针 &lt;code>nullptr&lt;/code>，表明该对象的生命周期已经结束。&lt;/p>
&lt;p>&lt;code>weak_ptr&lt;/code> 提供了一种访问 &lt;code>shared_ptr&lt;/code> 的方式，但并不控制对象的销毁，因此它可以有效避免循环引用问题。&lt;/p>
&lt;p>通过 &lt;code>weak_ptr&lt;/code>，我们可以在不延长对象生命周期的前提下，检查对象是否仍然存在，并访问它。具体来说，&lt;code>weak_ptr&lt;/code> 可以通过调用 &lt;code>lock()&lt;/code> 方法来创建一个 &lt;code>shared_ptr&lt;/code>，如果对象还存在（即引用计数大于零），则返回一个有效的 &lt;code>shared_ptr&lt;/code>，否则返回空指针。&lt;/p>
&lt;h4 id="控制块的扩展">控制块的扩展 &lt;a href="#%e6%8e%a7%e5%88%b6%e5%9d%97%e7%9a%84%e6%89%a9%e5%b1%95" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>为了支持&lt;code>std::weak_ptr&lt;/code>， 我们需要扩展控制块的功能 ，使其能同时管理对象的引用计数（&lt;code>ref_count&lt;/code>）和弱引用计数（&lt;code>weak_count&lt;/code>），从而保持对对象的生命周期的正确管理。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">control_block&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block(T&lt;span style="color:#f92672">*&lt;/span> ptr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ref_count(&lt;span style="color:#ae81ff">1&lt;/span>), weak_count(&lt;span style="color:#ae81ff">1&lt;/span>), obj(ptr) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_ref&lt;/span>() { &lt;span style="color:#f92672">++&lt;/span>ref_count; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> prev &lt;span style="color:#f92672">=&lt;/span> ref_count.load(); &lt;span style="color:#75715e">// 使用加载当前值，避免重复读取
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">while&lt;/span> (prev &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#f92672">!&lt;/span>ref_count.compare_exchange_weak(prev, prev &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> prev &lt;span style="color:#f92672">=&lt;/span> ref_count.load(); &lt;span style="color:#75715e">// 如果失败，重新加载当前值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> prev &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 如果 prev &amp;gt; 0，表示锁定成功
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 减少引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--&lt;/span>ref_count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj; &lt;span style="color:#75715e">// 删除对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> release_control_block(); &lt;span style="color:#75715e">// 尝试删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_weak_ref&lt;/span>() { &lt;span style="color:#f92672">++&lt;/span>weak_count; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 减少弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release_weak_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (weak_count.fetch_sub(&lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// 删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> obj; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除控制块，只有在弱引用计数为0时才删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> release_control_block() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (weak_count &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// 删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ref_count; &lt;span style="color:#75715e">// 强引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> weak_count; &lt;span style="color:#75715e">// 弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> obj; &lt;span style="color:#75715e">// 实际对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="weak_ptr-的简化版实现">&lt;code>weak_ptr&lt;/code> 的简化版实现 &lt;a href="#weak_ptr-%e7%9a%84%e7%ae%80%e5%8c%96%e7%89%88%e5%ae%9e%e7%8e%b0" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>下面是一个简化版的 &lt;code>weak_ptr&lt;/code> 实现，它与 &lt;code>shared_ptr&lt;/code> 共享相同的控制块。&lt;code>weak_ptr&lt;/code> 本身不增加引用计数，因此不会影响对象的生命周期。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">my_weak_ptr&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> my_weak_ptr() &lt;span style="color:#f92672">:&lt;/span> ctrl_block(&lt;span style="color:#66d9ef">nullptr&lt;/span>) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 从 shared_ptr 构造 my_weak_ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> my_weak_ptr(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> shared)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ctrl_block(shared.ctrl_block) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl_block&lt;span style="color:#f92672">-&amp;gt;&lt;/span>add_weak_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>my_weak_ptr() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ctrl_block) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl_block&lt;span style="color:#f92672">-&amp;gt;&lt;/span>release_weak_ref();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 尝试获取指向对象的 shared_ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> lock() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>shared_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;*&lt;/span> ctrl_block; &lt;span style="color:#75715e">// 控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">my_shared_ptr&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;*&lt;/span> ctrl_block;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> my_shared_ptr(&lt;span style="color:#66d9ef">const&lt;/span> my_weak_ptr&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> weak_ptr) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (weak_ptr.ctrl_block &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> weak_ptr.ctrl_block&lt;span style="color:#f92672">-&amp;gt;&lt;/span>lock()) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ptr &lt;span style="color:#f92672">=&lt;/span> weak_ptr.ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl_block &lt;span style="color:#f92672">=&lt;/span> weak_ptr.ctrl_block();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> &lt;span style="color:#a6e22e">exception&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;bad weak ptr&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="理解并优化stdatomict操作">理解并优化&lt;code>std::atomic&amp;lt;T&amp;gt;&lt;/code>操作 &lt;a href="#%e7%90%86%e8%a7%a3%e5%b9%b6%e4%bc%98%e5%8c%96stdatomict%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在上面的代码示例中，我们使用了&lt;code>std::atomic&amp;lt;int&amp;gt;&lt;/code>作为智能指针的引用计数。与直接使用&lt;code>int&lt;/code>变量不同，&lt;code>std::atomic&amp;lt;int&amp;gt;&lt;/code>可以在多线程环境中正确地管理对同一智能指针的引用计数。&lt;/p>
&lt;p>然而，在上述代码中，我们仅使用了&lt;code>std::atomic&amp;lt;int&amp;gt;&lt;/code>的基本操作（如自增、自减和赋值等），这些操作默认使用&lt;code>memory_order_seq_cst&lt;/code>内存序（稍后会讨论）。在多线程编程中，&lt;code>std::atomic&amp;lt;T&amp;gt;&lt;/code>提供了多种内存序（memory ordering）选项，用以控制操作的可见性和执行顺序，以确保数据一致性。不同的内存序策略决定了编译器和CPU对指令的重排序程度。&lt;/p>
&lt;p>开发者的目标是选择合适的内存序，优化程序性能，同时确保程序的正确性。&lt;/p>
&lt;h3 id="内存序的核心概念">内存序的核心概念 &lt;a href="#%e5%86%85%e5%ad%98%e5%ba%8f%e7%9a%84%e6%a0%b8%e5%bf%83%e6%a6%82%e5%bf%b5" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>理解内存序的关键在于&lt;strong>重排序&lt;/strong>和&lt;strong>跨线程可见性&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>重排序（Reordering）&lt;/strong>&lt;br>
编译器和CPU可能会重排指令，以优化性能。例如，它们可能会提前执行某些计算，或者将存储操作推迟执行。正确使用&lt;code>std::atomic&lt;/code>可以防止某些关键操作被错误地重排序。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>可见性（Visibility）&lt;/strong>&lt;br>
在多线程环境中，一个线程对变量的修改可能不会立即被其他线程看到，或者多个线程对同一变量的操作顺序可能不确定。原子操作的内存序决定了其他线程何时能看到这些修改。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="不同内存序的作用及使用场景">不同内存序的作用及使用场景 &lt;a href="#%e4%b8%8d%e5%90%8c%e5%86%85%e5%ad%98%e5%ba%8f%e7%9a%84%e4%bd%9c%e7%94%a8%e5%8f%8a%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="memory_order_relaxed松散顺序最低开销">&lt;code>memory_order_relaxed&lt;/code>（松散顺序，最低开销） &lt;a href="#memory_order_relaxed%e6%9d%be%e6%95%a3%e9%a1%ba%e5%ba%8f%e6%9c%80%e4%bd%8e%e5%bc%80%e9%94%80" class="anchor">🔗&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>特点&lt;/strong>：不保证顺序，仅保证操作是&lt;strong>原子的&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>作用&lt;/strong>：确保同一&lt;code>std::atomic&amp;lt;T&amp;gt;&lt;/code>变量的读写操作是原子的，但不提供线程间的同步，不影响可见性或顺序。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：适用于&lt;strong>数据竞争不影响程序正确性&lt;/strong>的场景，如&lt;strong>无依赖的计数&lt;/strong>（统计线程数、事件计数等）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> counter{&lt;span style="color:#ae81ff">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>counter.fetch_add(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_relaxed); &lt;span style="color:#75715e">// 仅保证原子性，不保证可见性
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里，&lt;code>fetch_add&lt;/code>确保&lt;code>counter&lt;/code>自增操作不会丢失，但不同线程的修改可能会被延迟看到。&lt;/p>
&lt;h4 id="memory_order_acquire获取防止重排序到前">&lt;code>memory_order_acquire&lt;/code>（获取，防止重排序到前） &lt;a href="#memory_order_acquire%e8%8e%b7%e5%8f%96%e9%98%b2%e6%ad%a2%e9%87%8d%e6%8e%92%e5%ba%8f%e5%88%b0%e5%89%8d" class="anchor">🔗&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>特点&lt;/strong>：保证&lt;strong>当前线程&lt;/strong>在&lt;code>acquire&lt;/code>之后的所有操作不会被重排序到&lt;code>acquire&lt;/code>之前，因此，其他线程中相同原子变量的释放操作（release operation）之前的写入对当前线程是可见的。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：用于&lt;strong>读取&lt;/strong>共享数据，确保当前线程能够看到其他线程之前对该变量的修改。&lt;/li>
&lt;/ul>
&lt;h4 id="memory_order_release释放防止重排序到后">&lt;code>memory_order_release&lt;/code>（释放，防止重排序到后） &lt;a href="#memory_order_release%e9%87%8a%e6%94%be%e9%98%b2%e6%ad%a2%e9%87%8d%e6%8e%92%e5%ba%8f%e5%88%b0%e5%90%8e" class="anchor">🔗&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>特点&lt;/strong>：确保&lt;strong>当前线程&lt;/strong>在&lt;code>release&lt;/code>之前的所有操作不会被重排序到&lt;code>release&lt;/code>之后，因此，当前操作所在线程之前的写入，在其他线程施加占有操作（acquire operation）之后是可见的。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：用于&lt;strong>写入&lt;/strong>共享数据，确保其他线程能在&lt;code>acquire&lt;/code>读取时看到修改。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> flag{&lt;span style="color:#ae81ff">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">producer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> data &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flag.store(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_release); &lt;span style="color:#75715e">// 让消费者可以看到 data=42
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">consumer&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (flag.load(std&lt;span style="color:#f92672">::&lt;/span>memory_order_acquire) &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>); &lt;span style="color:#75715e">// 确保 data=42 可见
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> data &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 确保 data 的修改对本线程可见
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>store(release)&lt;/code>确保&lt;code>data=42&lt;/code>发生在&lt;code>flag=1&lt;/code>之前。&lt;/li>
&lt;li>&lt;code>load(acquire)&lt;/code>确保&lt;code>flag=1&lt;/code>之后，&lt;code>data=42&lt;/code>对消费者线程可见。&lt;/li>
&lt;li>通过&lt;code>acquire-release&lt;/code>，消费者线程能够正确看到生产者线程的&lt;code>data&lt;/code>修改。&lt;/li>
&lt;/ul>
&lt;h4 id="memory_order_acq_rel获取-释放双向同步">&lt;code>memory_order_acq_rel&lt;/code>（获取-释放，双向同步） &lt;a href="#memory_order_acq_rel%e8%8e%b7%e5%8f%96-%e9%87%8a%e6%94%be%e5%8f%8c%e5%90%91%e5%90%8c%e6%ad%a5" class="anchor">🔗&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>特点&lt;/strong>：结合&lt;code>acquire&lt;/code>和&lt;code>release&lt;/code>，用于**读-改-写（Read-Modify-Write, RMW）**操作，确保：
&lt;ul>
&lt;li>读取时使用&lt;code>acquire&lt;/code>语义，保证之前的修改对当前线程可见。&lt;/li>
&lt;li>写入时使用&lt;code>release&lt;/code>语义，保证当前修改对后续线程可见。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：用于&lt;strong>读-改-写&lt;/strong>（如&lt;code>fetch_add()&lt;/code>、&lt;code>exchange()&lt;/code>）操作，确保多个线程能够正确协调。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>示例&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> value{&lt;span style="color:#ae81ff">0&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>value.fetch_add(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_acq_rel); &lt;span style="color:#75715e">// 读写都保证可见性
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这里，&lt;code>fetch_add&lt;/code>同时读取旧值并写入新值：&lt;/p>
&lt;ul>
&lt;li>读取时使用&lt;code>acquire&lt;/code>语义，确保它能看到其他线程的修改。&lt;/li>
&lt;li>写入时使用&lt;code>release&lt;/code>语义，确保它的修改能被其他线程看到。&lt;/li>
&lt;/ul>
&lt;h4 id="memory_order_seq_cst顺序一致性最严格">&lt;code>memory_order_seq_cst&lt;/code>（顺序一致性，最严格） &lt;a href="#memory_order_seq_cst%e9%a1%ba%e5%ba%8f%e4%b8%80%e8%87%b4%e6%80%a7%e6%9c%80%e4%b8%a5%e6%a0%bc" class="anchor">🔗&lt;/a>&lt;/h4>&lt;ul>
&lt;li>&lt;strong>特点&lt;/strong>：所有使用&lt;code>memory_order_seq_cst&lt;/code>的原子操作在&lt;strong>所有线程看来&lt;/strong>都是按照相同的顺序执行的，即全局一致的时序。&lt;/li>
&lt;li>&lt;strong>适用场景&lt;/strong>：
&lt;ul>
&lt;li>需要严格同步的场景，如&lt;strong>锁&lt;/strong>、&lt;strong>同步变量&lt;/strong>、&lt;strong>临界区保护&lt;/strong>等。&lt;/li>
&lt;li>适用于&lt;strong>多线程交互复杂&lt;/strong>、难以管理依赖关系的情况。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>保证&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;code>seq_cst&lt;/code>确保所有操作严格按照全局统一顺序执行，避免乱序问题。&lt;/li>
&lt;/ul>
&lt;h3 id="直观比喻">直观比喻 &lt;a href="#%e7%9b%b4%e8%a7%82%e6%af%94%e5%96%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;code>relaxed&lt;/code>：随意写笔记，但不保证别人能看到。&lt;/li>
&lt;li>&lt;code>acquire&lt;/code>：&lt;strong>进门检查公告栏&lt;/strong>，确保看到之前的通知。&lt;/li>
&lt;li>&lt;code>release&lt;/code>：&lt;strong>离开时更新公告栏&lt;/strong>，让后来的人看到。&lt;/li>
&lt;li>&lt;code>acq_rel&lt;/code>：&lt;strong>进门看公告 + 走前更新公告&lt;/strong>。&lt;/li>
&lt;li>&lt;code>seq_cst&lt;/code>：&lt;strong>所有人按同样顺序写、看公告&lt;/strong>，保证一致性。&lt;/li>
&lt;/ul>
&lt;p>根据不同场景合理选择内存序，可以提高并发程序的正确性和性能。&lt;/p>
&lt;h3 id="优化控制块中的原子变量">优化控制块中的原子变量 &lt;a href="#%e4%bc%98%e5%8c%96%e6%8e%a7%e5%88%b6%e5%9d%97%e4%b8%ad%e7%9a%84%e5%8e%9f%e5%ad%90%e5%8f%98%e9%87%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;atomic&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">control_block&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> control_block(T&lt;span style="color:#f92672">*&lt;/span> ptr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> ref_count(&lt;span style="color:#ae81ff">1&lt;/span>), weak_count(&lt;span style="color:#ae81ff">1&lt;/span>), obj(ptr) {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ref_count.fetch_add(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_relaxed);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 尝试增加强引用计数（仅当对象仍然存活时）
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> prev &lt;span style="color:#f92672">=&lt;/span> ref_count.load(std&lt;span style="color:#f92672">::&lt;/span>memory_order_acquire);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (prev &lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ref_count.compare_exchange_weak(prev, prev &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>memory_order_acquire, std&lt;span style="color:#f92672">::&lt;/span>memory_order_relaxed)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> true; &lt;span style="color:#75715e">// 成功锁定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> false; &lt;span style="color:#75715e">// 对象已被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 释放强引用
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (ref_count.fetch_sub(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_acq_rel) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> obj; &lt;span style="color:#75715e">// 删除对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> release_control_block(); &lt;span style="color:#75715e">// 尝试删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 增加弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">add_weak_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> weak_count.fetch_add(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_relaxed);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 释放弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">release_weak_ref&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (weak_count.fetch_sub(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_acq_rel) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// 删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#a6e22e">get&lt;/span>() { &lt;span style="color:#66d9ef">return&lt;/span> obj; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 删除控制块，仅当弱引用计数也归零时
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> release_control_block() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (weak_count.fetch_sub(&lt;span style="color:#ae81ff">1&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>memory_order_acq_rel) &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">delete&lt;/span> &lt;span style="color:#66d9ef">this&lt;/span>; &lt;span style="color:#75715e">// 删除控制块
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> ref_count; &lt;span style="color:#75715e">// 强引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>atomic&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> weak_count; &lt;span style="color:#75715e">// 弱引用计数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> obj; &lt;span style="color:#75715e">// 实际对象
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="参考">参考 &lt;a href="#%e5%8f%82%e8%80%83" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://zhuanlan.zhihu.com/p/532215950">C++内存管理：shared_ptr/weak_ptr源码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/Solstice/archive/2010/02/10/dtor_meets_threads.html">当析构函数遇到多线程 ── C++ 中线程安全的对象回调&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://liam.page/2021/12/11/memory-order-cpp-02/">程序员的自我修养（⑫）：C++ 的内存顺序&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>std::visit实现运行时多态 - C++ for the Antiquated（之三）</title><link>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</guid><description>&lt;p>在传统的 &lt;strong>C++&lt;/strong> 中，&lt;strong>运行时多态&lt;/strong> 通常依赖于 &lt;strong>“接口 - 虚函数”&lt;/strong> 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 &lt;strong>子类型多态&lt;/strong>（&lt;em>Subtype Polymorphism&lt;/em>）。&lt;/p>
&lt;p>在之前的文章中，我们介绍了现代 C++ 引入的 &lt;code>std::variant&lt;/code> —— 一种类型安全的联合体，以及如何借助 &lt;code>std::visit&lt;/code> 在类型安全的前提下，动态地访问联合体中的不同类型，并执行相应的逻辑。这种多态方式被称为 &lt;strong>临时多态&lt;/strong>（&lt;em>Ad-hoc Polymorphism&lt;/em>）。&lt;/p>
&lt;p>除此之外，还有一种被称为 &lt;strong>参数化多态&lt;/strong>（&lt;em>Parametric Polymorphism&lt;/em>），即我们熟知的 &lt;strong>C++ 模板&lt;/strong>。它允许我们编写与类型无关的代码，提供更强的泛型编程能力。由于本篇文章的重点并不在此，我们暂且不展开。&lt;/p>
&lt;p>在本篇文章中，我们将重点对比 &lt;strong>子类型多态&lt;/strong> 和 &lt;strong>临时多态&lt;/strong> 的优劣，分析它们在实际场景中的应用与权衡，希望能更好地理解和选择合适的多态机制。&lt;/p>
&lt;h2 id="临时多态的实现原理">&lt;strong>临时多态的实现原理&lt;/strong> &lt;a href="#%e4%b8%b4%e6%97%b6%e5%a4%9a%e6%80%81%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;strong>临时多态&lt;/strong>（&lt;em>Ad-hoc Polymorphism&lt;/em>）与 &lt;strong>子类型多态&lt;/strong>（&lt;em>Subtype Polymorphism&lt;/em>）在实现原理上有一定的相似性：它们都依赖于在类型中引入额外的信息来决定不同类型应执行的函数逻辑。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>子类型多态&lt;/strong>：依赖于&lt;strong>虚表（vtable）&lt;/strong> 和 &lt;strong>虚指针（vptr）&lt;/strong>，通过运行时的动态分派来确定调用哪个派生类的成员函数。&lt;/li>
&lt;li>&lt;strong>临时多态&lt;/strong>：依赖一个 &lt;strong>枚举值（enum）&lt;/strong> 来表示类型信息，通过显式的 &lt;code>switch-case&lt;/code> 或 &lt;code>if-else&lt;/code> 语句来选择不同的逻辑分支。&lt;/li>
&lt;/ul>
&lt;h3 id="简单示例模拟-stdvisit">&lt;strong>简单示例：模拟 std::visit&lt;/strong> &lt;a href="#%e7%ae%80%e5%8d%95%e7%a4%ba%e4%be%8b%e6%a8%a1%e6%8b%9f-stdvisit" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>这里只使用了传统C++的实现，关于&lt;code>std::visit&lt;/code>的更详细的解读，可以参考本系列的“动手实现std::visit”一文。&lt;/p>&lt;/blockquote>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cassert&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">enum&lt;/span> &lt;span style="color:#a6e22e">EType&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">uint8_t&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_Int &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_Float &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> TYPE_String &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">MyVariant&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> EType type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span> obj;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">MyVisitor&lt;/span>(MyVariant&lt;span style="color:#f92672">&amp;amp;&lt;/span> var) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">switch&lt;/span> (var.type) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TYPE_Int:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Int: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)var.obj &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TYPE_Float:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Float: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)var.obj &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">case&lt;/span> TYPE_String:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;String: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#f92672">*&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">*&lt;/span>)var.obj &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">default&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert(false &lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Unknown type!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">42&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">float&lt;/span> f &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">3.14f&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>string s &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVariant var1 &lt;span style="color:#f92672">=&lt;/span> {TYPE_Int, &lt;span style="color:#f92672">&amp;amp;&lt;/span>i};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVariant var2 &lt;span style="color:#f92672">=&lt;/span> {TYPE_Float, &lt;span style="color:#f92672">&amp;amp;&lt;/span>f};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVariant var3 &lt;span style="color:#f92672">=&lt;/span> {TYPE_String, &lt;span style="color:#f92672">&amp;amp;&lt;/span>s};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVisitor(var1);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVisitor(var2);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVisitor(var3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="原理解析">&lt;strong>原理解析&lt;/strong> &lt;a href="#%e5%8e%9f%e7%90%86%e8%a7%a3%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>EType 枚举&lt;/strong>
&lt;ul>
&lt;li>定义了一个枚举类型 &lt;code>EType&lt;/code>，用于标识 &lt;code>MyVariant&lt;/code> 当前存储的具体类型。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MyVariant 结构体&lt;/strong>
&lt;ul>
&lt;li>&lt;code>type&lt;/code> 字段保存当前对象的类型信息。&lt;/li>
&lt;li>&lt;code>obj&lt;/code> 字段是一个通用指针，指向实际存储的数据对象。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>MyVisitor 函数&lt;/strong>
&lt;ul>
&lt;li>通过 &lt;code>switch-case&lt;/code> 语句，基于 &lt;code>type&lt;/code> 字段选择不同的分支逻辑来访问和打印不同类型的数据。&lt;/li>
&lt;li>如果遇到未知类型，程序会触发 &lt;code>assert&lt;/code> 以防止未定义行为。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="性能优化思考">&lt;strong>性能优化思考&lt;/strong> &lt;a href="#%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e6%80%9d%e8%80%83" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在实际应用中，&lt;code>switch-case&lt;/code> 语句可能随着类型数量的增加而导致性能开销。可以通过二分查找（Binary Search）方法进行优化，减少 &lt;code>switch-case&lt;/code> 的分支深度。&lt;/p>
&lt;h2 id="临时多态的性能分析">临时多态的性能分析 &lt;a href="#%e4%b8%b4%e6%97%b6%e5%a4%9a%e6%80%81%e7%9a%84%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>虚函数常因其较低的性能而受到批评。为了更好地了解这一点，我们将对比使用虚函数实现的“子类型多态”和通过 &lt;code>std::visit&lt;/code> 实现的“临时多态”在性能上的差异。&lt;/p>
&lt;ul>
&lt;li>使用虚函数实现的&lt;a href="https://gist.github.com/Wizmann/df65af6d214c3b4ae296363839477b94">代码&lt;/a>&lt;/li>
&lt;li>使用&lt;code>std::visit&lt;/code> + &lt;code>std::variant&amp;lt;object&amp;gt;&lt;/code> 实现的&lt;a href="https://gist.github.com/Wizmann/f1494312a8e0cf30b97e9d8580fa9d6d">代码&lt;/a>&lt;/li>
&lt;li>使用&lt;code>std::visit&lt;/code> + &lt;code>std::variant&amp;lt;ptr&amp;gt;&lt;/code> 实现的&lt;a href="https://gist.github.com/Wizmann/a25708bcd732df8f6e3d158f7105b6c9">代码&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>结果如下：&lt;/p>
&lt;pre tabindex="0">&lt;code># 使用g++ --std=c++17 -O2编译运行
# 使用虚函数实现
Total Object Creation Time: 55.53 ms
Total Visit Time: 6.99 ms
# 使用std::visit + std::variant&amp;lt;object&amp;gt;实现
Total Object Creation Time: 26.88 ms
Total Visit Time: 5.93 ms
# 使用std::visit + std::variant&amp;lt;ptr&amp;gt;实现
Total Object Creation Time: 52.15 ms
Total Visit Time: 6.05 ms
&lt;/code>&lt;/pre>&lt;h3 id="结果分析">结果分析 &lt;a href="#%e7%bb%93%e6%9e%9c%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ul>
&lt;li>内存管理开销：
使用虚函数的子类型多态实现通常需要动态申请和释放内存，从而引入了额外的内存管理开销。而使用基于 &lt;code>std::variant&amp;lt;object&amp;gt;&lt;/code>的临时多态可以一次性分配所有内存，虽然可能存在一定程度的内存浪费，但避免了频繁的动态内存管理。&lt;/li>
&lt;li>性能接近，&lt;code>std::visit&lt;/code> 略优：
虽然虚函数和 &lt;code>std::visit&lt;/code> 的性能差距不大，但 &lt;code>std::visit&lt;/code> 略微优于虚函数。两者都引入了额外的开销以实现多态。&lt;/li>
&lt;/ul>
&lt;h2 id="通过临时多态实现vistor模式">通过临时多态实现Vistor模式 &lt;a href="#%e9%80%9a%e8%bf%87%e4%b8%b4%e6%97%b6%e5%a4%9a%e6%80%81%e5%ae%9e%e7%8e%b0vistor%e6%a8%a1%e5%bc%8f" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>Visitor模式是一种行为设计模式，用于将数据结构的操作与数据结构本身分离。它通常通过“子类型多态”来实现，其中每个具体类型的对象都接受一个访问者（Visitor）并对其进行相应的处理。使用虚函数和继承是实现这一模式的一种方式，但有时我们可以用更轻量的方式来实现，比如通过临时多态结合 &lt;code>std::variant&lt;/code> 和 &lt;code>std::visit&lt;/code>。&lt;/p>
&lt;h3 id="使用虚函数实现visitor模式">使用虚函数实现Visitor模式 &lt;a href="#%e4%bd%bf%e7%94%a8%e8%99%9a%e5%87%bd%e6%95%b0%e5%ae%9e%e7%8e%b0visitor%e6%a8%a1%e5%bc%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们首先来看一个传统的通过子类型多态实现Visitor模式的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">IVisitor&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">IResource&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">accept&lt;/span>(IVisitor&lt;span style="color:#f92672">*&lt;/span> visitor) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">IVisitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">visit&lt;/span>(IResource&lt;span style="color:#f92672">*&lt;/span> res) &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyResource&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IResource {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> accept(IVisitor&lt;span style="color:#f92672">*&lt;/span> visitor) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> visitor&lt;span style="color:#f92672">-&amp;gt;&lt;/span>visit(&lt;span style="color:#66d9ef">this&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyVisitor&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#66d9ef">public&lt;/span> IVisitor {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> visit(IResource&lt;span style="color:#f92672">*&lt;/span> res) &lt;span style="color:#66d9ef">override&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种实现方式虽然能很好地分离数据和操作，但它也有一些不足之处：&lt;/p>
&lt;ul>
&lt;li>每次调用 &lt;code>visit&lt;/code> 都需要通过虚函数来间接调用方法，这会引入额外的性能开销。&lt;/li>
&lt;li>&lt;code>visitor&lt;/code> 无法在 &lt;code>visit&lt;/code> 时直接获取资源对象的类型信息，通常需要额外传递类型信息或者让资源类暴露更多的接口。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-stdvisit-实现visitor模式">使用 &lt;code>std::visit&lt;/code> 实现Visitor模式 &lt;a href="#%e4%bd%bf%e7%94%a8-stdvisit-%e5%ae%9e%e7%8e%b0visitor%e6%a8%a1%e5%bc%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>通过 &lt;code>std::visit&lt;/code> 和 &lt;code>std::variant&lt;/code>，我们可以显式地通过类型信息来处理每种资源类型，避免了虚函数调用的开销，同时使得代码更加简洁和类型安全。下面是一个通过临时多态实现Visitor模式的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> ResourceUnion &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>ResourceA, ResourceB, ResourceC&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>ResourceUnion&lt;span style="color:#f92672">&amp;gt;&lt;/span> resources;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> res : resources) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>visit([](&lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> res) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>decay_t&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">decltype&lt;/span>(res)&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, ResourceA&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理类型为 ResourceA 的资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, ResourceB&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理类型为 ResourceB 的资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, ResourceC&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 处理类型为 ResourceC 的资源
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static_assert&lt;/span>(always_false_v&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Unhandled type!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, res);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="优点与分析">优点与分析 &lt;a href="#%e4%bc%98%e7%82%b9%e4%b8%8e%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>类型安全&lt;/strong>：
使用 &lt;code>std::visit&lt;/code> 时，编译器可以根据类型推断并为每种类型生成不同的代码路径，从而避免了运行时错误和类型错误，提升了类型安全性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>性能&lt;/strong>：
由于不再依赖虚函数，&lt;code>std::visit&lt;/code> 能避免每次调用 &lt;code>visit&lt;/code> 时的虚函数开销，从而提高了性能。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>简洁性&lt;/strong>：
通过 &lt;code>std::variant&lt;/code> 和 &lt;code>std::visit&lt;/code>，代码更加简洁且不需要繁琐的继承结构。每个资源类型只需关注其自身的实现，而无需处理不同访问者的逻辑。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>扩展性&lt;/strong>：
如果要新增资源类型，只需在 &lt;code>std::variant&lt;/code> 中添加新类型，并在 &lt;code>std::visit&lt;/code> 的 lambda 表达式中添加对应的分支，避免了修改现有代码的风险。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="临时多态的优点与缺点">临时多态的优点与缺点 &lt;a href="#%e4%b8%b4%e6%97%b6%e5%a4%9a%e6%80%81%e7%9a%84%e4%bc%98%e7%82%b9%e4%b8%8e%e7%bc%ba%e7%82%b9" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="优点">优点： &lt;a href="#%e4%bc%98%e7%82%b9" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>类型安全&lt;/strong>：&lt;code>std::variant&lt;/code> 与 &lt;code>std::visit&lt;/code> 确保了类型安全，避免了许多传统多态机制中的错误。&lt;/li>
&lt;li>&lt;strong>性能优化&lt;/strong>：相较于虚函数，&lt;code>std::visit&lt;/code> 通过类型折叠和编译时分支优化，通常表现出更好的性能，尤其在没有动态内存管理时。&lt;/li>
&lt;li>&lt;strong>自由组织功能函数&lt;/strong>：你可以灵活地将功能函数组织在一个地方，而无需修改每个具体类型。&lt;/li>
&lt;/ol>
&lt;h3 id="缺点">缺点： &lt;a href="#%e7%bc%ba%e7%82%b9" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ol>
&lt;li>&lt;strong>职责分散&lt;/strong>：每个类型的行为都可能分散到多个&lt;code>visit&lt;/code>函数中，导致代码难以维护。&lt;/li>
&lt;li>&lt;strong>高耦合风险&lt;/strong>：当新增类型时，所有访问逻辑需要修改，可能带来较高的耦合度，尤其在类型较多时。&lt;/li>
&lt;/ol>
&lt;h2 id="参考">参考 &lt;a href="#%e5%8f%82%e8%80%83" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>C++20高级编程（罗能） —— 1.6 运行时多态&lt;/li>
&lt;li>&lt;a href="https://wiyi.org/polymorphism-in-java.html">深入理解面向对象中的多态&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://refactoringguru.cn/design-patterns/visitor/cpp/example">C++ 访问者模式讲解和代码示例&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>动手实现std::visit - C++ for the Antiquated（之二）</title><link>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</link><pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</guid><description>&lt;h2 id="stdvariant-与-stdvisit">std::variant 与 std::visit &lt;a href="#stdvariant-%e4%b8%8e-stdvisit" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="stdvariant">std::variant &lt;a href="#stdvariant" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>std::variant&lt;/code> 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 &lt;code>union&lt;/code> 不同，&lt;code>std::variant&lt;/code> 能够在运行时安全地检查当前存储的类型，避免未定义行为。&lt;/p>
&lt;p>其核心特点如下：&lt;/p>
&lt;ul>
&lt;li>类型安全：访问值时进行类型检查，防止类型错误。&lt;/li>
&lt;li>固定类型集合：存储类型在编译时确定。&lt;/li>
&lt;li>异常安全：在赋值失败时会进入无效状态（std::monostate）。&lt;/li>
&lt;/ul>
&lt;h3 id="stdvisit">std::visit &lt;a href="#stdvisit" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>std::visit&lt;/code> 是一个访问器函数，用于访问 &lt;code>std::variant&lt;/code> 中当前存储的值。它通过一个可调用对象（如 Lambda 表达式）来处理存储的值，从而实现编译时多态。&lt;/p>
&lt;p>其核心特点如下：&lt;/p>
&lt;ul>
&lt;li>统一访问接口：无论存储的是哪种类型，都可以通过同一个函数进行访问。&lt;/li>
&lt;li>类型安全：确保所有可能的类型都被正确处理。&lt;/li>
&lt;/ul>
&lt;h3 id="代码示例">代码示例 &lt;a href="#%e4%bb%a3%e7%a0%81%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;variant&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;type_traits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">inline&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> always_false_v &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">float&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span> items {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">10&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">3.14f&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;foobar&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> item : items) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>visit([](&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> arg) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> T &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>decay_t&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">decltype&lt;/span>(arg)&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;int: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arg &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;float: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arg &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_same_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;std::string: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> arg &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static_assert&lt;/span>(always_false_v&lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;Unhandled type!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码分析">代码分析 &lt;a href="#%e4%bb%a3%e7%a0%81%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>std::variant&amp;lt;int, float, std::string&amp;gt;&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>这是一个类型安全的联合体，可以存储 &lt;code>int&lt;/code>、&lt;code>float&lt;/code> 或 &lt;code>std::string&lt;/code> 中的任意一种类型。&lt;/li>
&lt;li>将多个 &lt;code>std::variant&lt;/code> 存储在 &lt;code>std::vector&lt;/code> 中，形成一个统一的容器。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>std::visit&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>std::visit&lt;/code> 访问每个 &lt;code>std::variant&lt;/code> 元素。&lt;/li>
&lt;li>传入一个&lt;strong>泛型 Lambda 表达式&lt;/strong>，通过 &lt;code>if constexpr&lt;/code> 在编译时分发到不同的分支，处理不同类型的值。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>if constexpr&lt;/code> 与 &lt;code>std::is_same_v&lt;/code>&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>std::is_same_v&lt;/code> 判断存储的实际类型。&lt;/li>
&lt;li>根据类型进行不同的输出操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型安全&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>如果添加一个未处理的类型，编译器会在 &lt;code>static_assert&lt;/code> 中报错，提醒开发者补充处理逻辑。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="使用传统c实现stdvisit">使用传统C++实现std::visit &lt;a href="#%e4%bd%bf%e7%94%a8%e4%bc%a0%e7%bb%9fc%e5%ae%9e%e7%8e%b0stdvisit" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="实现stdvariant">实现std::variant &lt;a href="#%e5%ae%9e%e7%8e%b0stdvariant" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在传统 C++ 中，我们只有简单的 &lt;code>union&lt;/code> 来实现“联合体”语义。然而，&lt;code>union&lt;/code> 存在一些局限性：&lt;/p>
&lt;ul>
&lt;li>无法存储非平凡类型（例如 &lt;code>std::string&lt;/code>）。&lt;/li>
&lt;li>无法跟踪当前存储的类型。&lt;/li>
&lt;li>无法进行类型安全检查。&lt;/li>
&lt;/ul>
&lt;p>而 &lt;code>std::variant&lt;/code> 通过类型索引和类型匹配来提供类型安全，支持多种类型的存储与访问。&lt;/p>
&lt;h3 id="实现-stdvisit">实现 std::visit &lt;a href="#%e5%ae%9e%e7%8e%b0-stdvisit" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>实现 &lt;code>std::visit&lt;/code> 需要使用一个可调用对象（例如 Visitor）来访问 &lt;code>std::variant&lt;/code> 中的值。具体来说，它在编译时根据实际类型匹配相应的 &lt;code>operator()&lt;/code> 方法。&lt;/p>
&lt;p>示例代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;variant&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;type_traits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Visitor&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">operator&lt;/span>()(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;int: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> item &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">operator&lt;/span>()(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;float: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> item &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">operator&lt;/span>()(&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;string: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> item &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>variant&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, &lt;span style="color:#66d9ef">float&lt;/span>, std&lt;span style="color:#f92672">::&lt;/span>string&lt;span style="color:#f92672">&amp;gt;&lt;/span> item(&lt;span style="color:#ae81ff">114.514f&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取当前类型的索引
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> item.index() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 输出: 1 (float 的索引)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 获取当前存储的值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">float&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(item) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 输出: 114.514
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>get&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>(item) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (&lt;span style="color:#66d9ef">const&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>bad_variant_access&lt;span style="color:#f92672">&amp;amp;&lt;/span> e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> e.what() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 类型不匹配，抛出异常
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 使用 Visitor 访问值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>visit(Visitor{}, item) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 输出: 1 (float 类型返回 1)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="实现的核心要点">实现的核心要点 &lt;a href="#%e5%ae%9e%e7%8e%b0%e7%9a%84%e6%a0%b8%e5%bf%83%e8%a6%81%e7%82%b9" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>实现 &lt;code>std::visit&lt;/code> 的关键在于以下几个方面：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>类型索引 (&lt;code>index()&lt;/code>)&lt;/strong>&lt;br>
根据传入的 &lt;code>std::variant&lt;/code> 参数类型，确定其在类型集合中的索引。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型访问 (&lt;code>std::get&amp;lt;T&amp;gt;&lt;/code>)&lt;/strong>&lt;br>
根据传入的模板类型 &lt;code>T&lt;/code>，获取存储的值。如果类型不匹配，抛出异常，确保类型安全。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型分派 (&lt;code>std::visit&lt;/code>)&lt;/strong>&lt;br>
根据当前存储的类型，调用 &lt;code>Visitor&lt;/code> 中对应的 &lt;code>operator()&lt;/code> 方法。可以通过 &lt;code>switch-case&lt;/code> 或模板匹配来实现类型分发。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="代码实现0---基本框架">代码实现0 - 基本框架 &lt;a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b00---%e5%9f%ba%e6%9c%ac%e6%a1%86%e6%9e%b6" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyVariant&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyVariant(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> setValue(item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> setValue(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// TODO
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 用于存储“联合体”的数据
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">union&lt;/span> &lt;span style="color:#a6e22e">Storage&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Storage() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>Storage() {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>aligned_union_t&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>, Ts...&lt;span style="color:#f92672">&amp;gt;&lt;/span> data;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } storage;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码实现1---index函数">代码实现1 - index()函数 &lt;a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b01---index%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们使用经典的模板递归来查找类型对应的索引。同时，利用 &lt;code>constexpr&lt;/code> 来简化编译时计算的过程。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>size_t N, &lt;span style="color:#66d9ef">typename&lt;/span>... Types&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> TupleElement &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typename&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>tuple_element&lt;span style="color:#f92672">&amp;lt;&lt;/span>N, std&lt;span style="color:#f92672">::&lt;/span>tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Types...&lt;span style="color:#f92672">&amp;gt;&amp;gt;::&lt;/span>type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T, &lt;span style="color:#66d9ef">typename&lt;/span>... Types&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TypeIndex&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T, &lt;span style="color:#66d9ef">typename&lt;/span> First, &lt;span style="color:#66d9ef">typename&lt;/span>... Rest&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TypeIndex&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, First, Rest...&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>is_same&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, First&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">:&lt;/span> (TypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, Rest...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> TypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, Rest...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">TypeIndex&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T, &lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">bool&lt;/span> containsType() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> TypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">!=&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上述代码，我们实现了在编译期确定传入类型对应的类型索引。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>setValue(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> item) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> TargetType &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>decay_t&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static_assert&lt;/span>(containsType&lt;span style="color:#f92672">&amp;lt;&lt;/span>TargetType&lt;span style="color:#f92672">&amp;gt;&lt;/span>(), &lt;span style="color:#e6db74">&amp;#34;Type not supported&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">new&lt;/span> (&lt;span style="color:#f92672">&amp;amp;&lt;/span>storage.data) TargetType(item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> typeIndex &lt;span style="color:#f92672">=&lt;/span> getTypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>TargetType&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码实现2---get-函数">代码实现2 - &lt;code>get()&lt;/code> 函数 &lt;a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b02---get-%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们实现了一个函数 &lt;code>MyVariant::get()&lt;/code>，通过检查 &lt;code>typeIndex&lt;/code> 来确保获取的类型与存储类型一致。&lt;/p>
&lt;p>我们也能可以通过&lt;code>MyGet&lt;/code>函数模拟&lt;code>std::get&amp;lt;T&amp;gt;&lt;/code>函数的行为。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyVariant&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T, &lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>T&lt;span style="color:#f92672">&amp;amp;&lt;/span> MyGet(MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;&amp;amp;&lt;/span> var) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> var.&lt;span style="color:#66d9ef">template&lt;/span> get&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>T&lt;span style="color:#f92672">&amp;amp;&lt;/span> MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>get() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> TargetType &lt;span style="color:#f92672">=&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>decay_t&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (TypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>T, Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">!=&lt;/span> typeIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>runtime_error(&lt;span style="color:#e6db74">&amp;#34;Wrong type&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#66d9ef">reinterpret_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>TargetType&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>storage.data);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="代码实现3---visit函数">代码实现3 - &lt;code>visit&lt;/code>函数 &lt;a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b03---visit%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>接下来是 &lt;code>visit()&lt;/code> 函数的实现。它通过递归方式依次访问 &lt;code>std::variant&lt;/code> 中的每种类型，并调用与之对应的处理函数。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>std&lt;span style="color:#f92672">::&lt;/span>size_t N, &lt;span style="color:#66d9ef">typename&lt;/span>... Types&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> TupleElement &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">typename&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>tuple_element&lt;span style="color:#f92672">&amp;lt;&lt;/span>N, std&lt;span style="color:#f92672">::&lt;/span>tuple&lt;span style="color:#f92672">&amp;lt;&lt;/span>Types...&lt;span style="color:#f92672">&amp;gt;&amp;gt;::&lt;/span>type;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> TVisitor&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">auto&lt;/span> MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>visit(TVisitor&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> visitor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> FirstType &lt;span style="color:#f92672">=&lt;/span> TupleElement&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>, Ts...&lt;span style="color:#f92672">&amp;gt;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">using&lt;/span> RetT &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">decltype&lt;/span>(visitor(std&lt;span style="color:#f92672">::&lt;/span>declval&lt;span style="color:#f92672">&amp;lt;&lt;/span>FirstType&lt;span style="color:#f92672">&amp;gt;&lt;/span>()));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> visitImpl&lt;span style="color:#f92672">&amp;lt;&lt;/span>RetT, TVisitor, Ts...&lt;span style="color:#f92672">&amp;gt;&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>TVisitor&lt;span style="color:#f92672">&amp;gt;&lt;/span>(visitor));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> RetT, &lt;span style="color:#66d9ef">typename&lt;/span> TVisitor, &lt;span style="color:#66d9ef">typename&lt;/span> First, &lt;span style="color:#66d9ef">typename&lt;/span>... Rest&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RetT MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>visitImpl(TVisitor&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> visitor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (getTypeIndex&lt;span style="color:#f92672">&amp;lt;&lt;/span>First&lt;span style="color:#f92672">&amp;gt;&lt;/span>() &lt;span style="color:#f92672">==&lt;/span> typeIndex) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#a6e22e">visitor&lt;/span>(get&lt;span style="color:#f92672">&amp;lt;&lt;/span>First&lt;span style="color:#f92672">&amp;gt;&lt;/span>());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 递归访问剩余的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> visitImpl&lt;span style="color:#f92672">&amp;lt;&lt;/span>RetT, TVisitor, Rest...&lt;span style="color:#f92672">&amp;gt;&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>forward&lt;span style="color:#f92672">&amp;lt;&lt;/span>TVisitor&lt;span style="color:#f92672">&amp;gt;&lt;/span>(visitor));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span>... Ts&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> RetT, &lt;span style="color:#66d9ef">typename&lt;/span> TVisitor&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RetT MyVariant&lt;span style="color:#f92672">&amp;lt;&lt;/span>Ts...&lt;span style="color:#f92672">&amp;gt;::&lt;/span>visitImpl(&lt;span style="color:#a6e22e">[[maybe_unused]]&lt;/span>TVisitor&lt;span style="color:#f92672">&amp;amp;&amp;amp;&lt;/span> visitor) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 基础情况：所有类型都已检查，未找到匹配的类型
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">throw&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>runtime_error(&lt;span style="color:#e6db74">&amp;#34;Wrong type&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结 &lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在本文中，我们实现了一个简单版的 &lt;code>std::variant&lt;/code> 和 &lt;code>std::visit&lt;/code>，通过传统 C++ 实现了类型安全的联合体数据结构。我们依次通过以下步骤构建了这一系统：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>&lt;code>MyVariant&lt;/code> 类的基本框架&lt;/strong>：通过联合体 (&lt;code>union&lt;/code>) 存储不同类型的数据，并使用模板构造函数动态设置值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类型索引 (&lt;code>index()&lt;/code>) 的实现&lt;/strong>：使用模板递归技术结合 &lt;code>constexpr&lt;/code> 来实现类型的编译时索引查找，从而在运行时根据类型索引来访问对应的值。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>get()&lt;/code> 函数&lt;/strong>：实现了获取存储值的函数，并通过类型检查确保类型安全。如果访问了错误类型的数据，则抛出异常。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>&lt;code>visit()&lt;/code> 函数&lt;/strong>：实现了一个可扩展的访问机制，使得不同类型的值可以通过同一个 &lt;code>Visitor&lt;/code> 被访问和处理。通过递归的方式，系统能够动态地访问不同类型的值，并调用相应的处理函数。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>通过这些实现，我们成功模拟了 C++ 标准库中的 &lt;code>std::variant&lt;/code> 和 &lt;code>std::visit&lt;/code> 功能。同时，通过对比可以看出，现代 C++ 提供了更强大的模板元编程能力。利用这些特性，我们能够使用更直观的语法，在编译期间实现高效且类型安全的联合体访问，从而提供一种灵活、类型安全的方式来处理多类型数据。&lt;/p></description></item><item><title>constexpr详解 - C++ for the Antiquated（之一）</title><link>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</guid><description>&lt;p>在这篇文章中，我们将深入讨论 C++ 中的常量表达式（&lt;code>constexpr&lt;/code>）及其与传统的&lt;code>const&lt;/code>常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨&lt;code>constexpr&lt;/code>函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。&lt;/p>
&lt;h2 id="常量表达式constexpr">常量表达式（constexpr） &lt;a href="#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8fconstexpr" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在 C++ 中，&lt;code>const&lt;/code> 关键字通常用于修饰变量、引用和指针，使得它们在运行时不能被修改。需要注意的是，&lt;code>const&lt;/code> 并没有区分编译期常量和运行时常量，它只是保证了这些变量在运行时不可修改。&lt;/p>
&lt;p>例如，使用 &lt;code>const&lt;/code> 声明的变量在运行时其值是固定的，但并不意味着它们在编译时已知。&lt;/p>
&lt;p>下面是传统 C++ 中 &lt;code>const&lt;/code> 关键字的一些常见用法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define CONSTANT_1 114514 &lt;/span>&lt;span style="color:#75715e">// 宏也是一种常量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> helloworld1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;helloworld&amp;#34;&lt;/span>; &lt;span style="color:#75715e">// const 字符串
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 常量值
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value3 &lt;span style="color:#f92672">=&lt;/span> value1 &lt;span style="color:#f92672">+&lt;/span> value2; &lt;span style="color:#75715e">// 运行时计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value8 &lt;span style="color:#f92672">=&lt;/span> pow(value2, value3);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> arr_pow_of_2[] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>}; &lt;span style="color:#75715e">// 数组初始化
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上述代码中，虽然 const 修饰的变量在程序运行期间不能修改，但它们的值是在运行时计算的。因此，我们无法在编译时将它们视为常量。所以，&lt;code>const&lt;/code> 变量也可以有内存地址，并且在某些情况下可以使用 &lt;code>const_cast&lt;/code> 强行进行修改。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">MakeChange&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>(&lt;span style="color:#66d9ef">const_cast&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&amp;gt;&lt;/span>(&lt;span style="color:#f92672">&amp;amp;&lt;/span>x)) &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> x &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MakeChange(x);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> x &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// 输出：2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="引入-constexpr">引入 constexpr &lt;a href="#%e5%bc%95%e5%85%a5-constexpr" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>C++11 引入了 &lt;code>constexpr&lt;/code>，它的字面意思是 &lt;code>constant expression&lt;/code>（常量表达式），用于在编译时计算常量值。与 &lt;code>const&lt;/code> 不同，&lt;code>constexpr&lt;/code> 确保一个变量或者函数的值是在编译时已知的，编译器会在编译时对其进行求值。&lt;/p>
&lt;p>通过使用 &lt;code>constexpr&lt;/code>，我们可以定义编译时常量，并且 &lt;code>constexpr&lt;/code> 函数在某些情况下也能够在编译期计算结果。&lt;/p>
&lt;p>使用 &lt;code>constexpr&lt;/code> 重写上述代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">char&lt;/span>&lt;span style="color:#f92672">*&lt;/span> helloworld1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;helloworld&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value3 &lt;span style="color:#f92672">=&lt;/span> value1 &lt;span style="color:#f92672">+&lt;/span> value2; &lt;span style="color:#75715e">// 编译期计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> value8 &lt;span style="color:#f92672">=&lt;/span> pow(value2, value3); &lt;span style="color:#75715e">// 编译期计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 编译期初始化数组
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> arr_pow_of_2[] &lt;span style="color:#f92672">=&lt;/span> {&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常量表达式函数">常量表达式函数 &lt;a href="#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;code>constexpr&lt;/code> 不仅可以修饰变量，还可以修饰函数。&lt;code>constexpr&lt;/code> 函数的特性是，若输入的参数是编译时常量，那么它的返回值也是一个编译时常量。&lt;/p>
&lt;p>以下是一个计算 Fibonacci 数列的示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> MOD &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#ae81ff">1LL&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">62&lt;/span>) &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; &lt;span style="color:#75715e">// 编译时常量
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> &lt;span style="color:#a6e22e">fib&lt;/span>(&lt;span style="color:#66d9ef">uint64_t&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> a &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>, b &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> n; &lt;span style="color:#f92672">++&lt;/span>i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> a &lt;span style="color:#f92672">+&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a &lt;span style="color:#f92672">=&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b &lt;span style="color:#f92672">=&lt;/span> temp &lt;span style="color:#f92672">%&lt;/span> MOD;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> b;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 在编译期计算 Fibonacci 数列
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> result &lt;span style="color:#f92672">=&lt;/span> fib(&lt;span style="color:#ae81ff">123456&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> result &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这段代码中，&lt;code>fib&lt;/code> 函数被标记为 &lt;code>constexpr&lt;/code>，因此当传入常量参数时，编译器会在编译期间计算出 Fibonacci 数列的第 &lt;code>123456&lt;/code> 项。需要注意的是，&lt;code>constexpr&lt;/code> 函数的计算存在一些限制：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>递归深度限制&lt;/strong>：constexpr 函数的递归深度通常受到编译器的限制，如果递归过深，编译器可能会产生错误或警告。&lt;/li>
&lt;li>&lt;strong>计算效率&lt;/strong>：尽管常量表达式函数可以在编译期计算，但对于复杂的运算，可能会增加编译时间，因为编译器需要进行更多的计算。&lt;/li>
&lt;/ol>
&lt;h3 id="constexpr-vs-模板元编程">constexpr vs 模板元编程 &lt;a href="#constexpr-vs-%e6%a8%a1%e6%9d%bf%e5%85%83%e7%bc%96%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>constexpr&lt;/code> 函数的使用在某种程度上简化了模板元编程。传统的模板元编程可以实现与 &lt;code>constexpr&lt;/code> 类似的功能，但代码结构通常更加复杂。下面是使用模板元编程计算 Fibonacci 数列的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> MOD &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1999&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">uint64_t&lt;/span> N&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> (Fibonacci&lt;span style="color:#f92672">&amp;lt;&lt;/span>N &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">+&lt;/span> Fibonacci&lt;span style="color:#f92672">&amp;lt;&lt;/span>N &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value) &lt;span style="color:#f92672">%&lt;/span> MOD;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> { &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Fibonacci&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> { &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Fibonacci(40): &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> Fibonacci&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">40&lt;/span>&lt;span style="color:#f92672">&amp;gt;::&lt;/span>value &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个模板元编程示例中，Fibonacci 结构体使用递归模板计算 Fibonacci 数列的第 N 项。这与 &lt;code>constexpr&lt;/code> 函数类似，但模板元编程的语法更加繁琐。&lt;code>constexpr&lt;/code> 的优势在于它能够写出更加接近正常逻辑代码的形式，并且具有更强的表达能力&lt;/p>
&lt;h3 id="c14-对常量表达式函数的增强">C++14 对常量表达式函数的增强 &lt;a href="#c14-%e5%af%b9%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e5%87%bd%e6%95%b0%e7%9a%84%e5%a2%9e%e5%bc%ba" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在 C++14 中，常量表达式函数得到了进一步的增强。具体增强包括：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>支持局部变量&lt;/strong>：&lt;code>constexpr&lt;/code> 函数可以声明和初始化局部变量，但不能声明未初始化的变量、&lt;code>static&lt;/code> 或 &lt;code>thread_local&lt;/code> 变量。&lt;/li>
&lt;li>&lt;strong>支持 if 和 switch 语句&lt;/strong>：&lt;code>constexpr&lt;/code> 函数可以使用 &lt;code>if&lt;/code> 和 &lt;code>switch&lt;/code> 语句来控制流程，但不能使用 &lt;code>got&lt;/code>o。&lt;/li>
&lt;li>&lt;strong>支持循环语句&lt;/strong>：&lt;code>constexpr&lt;/code> 函数支持所有类型的循环语句，包括 &lt;code>for&lt;/code>、&lt;code>while&lt;/code> 和 &lt;code>do-while&lt;/code>。&lt;/li>
&lt;li>&lt;strong>修改生命周期&lt;/strong>：在 constexpr 函数内部，可以修改局部变量和非常量引用参数&lt;/li>
&lt;li>&lt;strong>返回值可以是 void&lt;/strong>：&lt;code>constexpr&lt;/code> 函数可以声明返回类型为 &lt;code>void&lt;/code>。&lt;/li>
&lt;/ul>
&lt;h2 id="常量表达式与模板函数">常量表达式与模板函数 &lt;a href="#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%8e%e6%a8%a1%e6%9d%bf%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在 C++11 引入 &lt;code>constexpr&lt;/code> 后，建议在所有需要常量语义的场景中使用 &lt;code>constexpr&lt;/code>。&lt;code>constexpr&lt;/code> 变量和函数作为编译时常量，在模板函数中具有广泛的应用场景，能够显著提升程序的效率和可读性。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> T square(T x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">uint64_t&lt;/span> square2 &lt;span style="color:#f92672">=&lt;/span> square(&lt;span style="color:#ae81ff">2&lt;/span>); &lt;span style="color:#75715e">// 计算常量的平方
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">double&lt;/span> square2_0 &lt;span style="color:#f92672">=&lt;/span> square(&lt;span style="color:#ae81ff">2.0&lt;/span>); &lt;span style="color:#75715e">// 计算浮点数的平方
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%lu&lt;/span>&lt;span style="color:#ae81ff">\t&lt;/span>&lt;span style="color:#e6db74">%.04lf&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, square2, square2_0); &lt;span style="color:#75715e">// 输出结果
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>模板函数 &lt;code>square&lt;/code> 使用了 &lt;code>constexpr&lt;/code>，确保在编译时就可以计算结果。对于不同类型的参数（如整数、浮点数），模板会自动进行实例化。&lt;/p>
&lt;p>如果模板参数不是编译期常量，&lt;code>constexpr&lt;/code> 将不会在编译期执行，但函数本身仍然是有效的。&lt;/p>
&lt;h2 id="constexpr-函数中的动态内存分配">constexpr 函数中的动态内存分配 &lt;a href="#constexpr-%e5%87%bd%e6%95%b0%e4%b8%ad%e7%9a%84%e5%8a%a8%e6%80%81%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在 C++20 中，&lt;code>constexpr&lt;/code> 函数得到了进一步增强，支持在编译期进行动态内存分配，但仍然存在一些限制。&lt;/p>
&lt;p>&lt;code>std::array&lt;/code> 的所有数据都存储在栈上，而不是堆上。严格的说，&lt;code>std::array&lt;/code>不涉及动态内存分配。所以&lt;code>std::array&lt;/code>可以在&lt;code>constexpr&lt;/code>函数中被初始化、修改并返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;array&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> maxstep&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>array&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, maxstep&lt;span style="color:#f92672">&amp;gt;&lt;/span> Collatz(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>array&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>, maxstep&lt;span style="color:#f92672">&amp;gt;&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> idx &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (true) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path[idx&lt;span style="color:#f92672">++&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (x &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">/=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#a6e22e">if&lt;/span> (x &lt;span style="color:#f92672">%&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x &lt;span style="color:#f92672">=&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> path;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> path &lt;span style="color:#f92672">=&lt;/span> Collatz(&lt;span style="color:#ae81ff">12345&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> item : path) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (item &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, item);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而对于&lt;code>std::string&lt;/code>或者&lt;code>std::vector&lt;/code>这种 需要在堆上分配内存的数据结构，我们则不可以在constexpr函数中直接返回。但是可以在constexpr函数中则用其进行计算。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;vector&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;array&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;string&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">square&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> x) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x &lt;span style="color:#f92672">*&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">CountPrimes&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> n) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> primes{&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">5&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;=&lt;/span> n; i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">bool&lt;/span> flag &lt;span style="color:#f92672">=&lt;/span> true;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">auto&lt;/span> prime : primes) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">%&lt;/span> prime &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flag &lt;span style="color:#f92672">=&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (square(prime) &lt;span style="color:#f92672">&amp;gt;=&lt;/span> i) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">break&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (flag) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> primes.push_back(i);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> primes.size();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> cnt &lt;span style="color:#f92672">=&lt;/span> CountPrimes(&lt;span style="color:#ae81ff">100&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, cnt);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="constexpr-virtual-函数">constexpr virtual 函数 &lt;a href="#constexpr-virtual-%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在 C++20 中，&lt;code>constexpr&lt;/code> 函数可以与 &lt;code>virtual&lt;/code> 关键字结合使用，实现在编译期进行多态求值。&lt;/p>
&lt;p>虚函数的 constexpr 限制：constexpr 虚函数只能在编译期求值，前提是其被调用的具体对象类型是确定的。&lt;/p>
&lt;p>在 constexpr 上下文中调用 virtual 函数时，调用将绑定到具体派生类的实现。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Base&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">virtual&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#75715e">// 虚拟 constexpr 函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Derived1&lt;/span> &lt;span style="color:#f92672">:&lt;/span> Base {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Derived2&lt;/span> &lt;span style="color:#f92672">:&lt;/span> Base {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Value&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">override&lt;/span> { &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">Calc&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Base&lt;span style="color:#f92672">*&lt;/span> d1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Derived1(); &lt;span style="color:#75715e">// constexpr 中分配内存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Base&lt;span style="color:#f92672">*&lt;/span> d2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Derived2();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> value &lt;span style="color:#f92672">=&lt;/span> d1&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Value() &lt;span style="color:#f92672">+&lt;/span> d2&lt;span style="color:#f92672">-&amp;gt;&lt;/span>Value(); &lt;span style="color:#75715e">// 调用虚函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span> d1; &lt;span style="color:#75715e">// 必须释放内存
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">delete&lt;/span> d2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> value;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">constexpr&lt;/span> &lt;span style="color:#66d9ef">auto&lt;/span> v &lt;span style="color:#f92672">=&lt;/span> Calc(); &lt;span style="color:#75715e">// 在编译期计算
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> printf(&lt;span style="color:#e6db74">&amp;#34;%d&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>, v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> v;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="常量表达式用于模板函数的类型判断">常量表达式用于模板函数的类型判断 &lt;a href="#%e5%b8%b8%e9%87%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e7%94%a8%e4%ba%8e%e6%a8%a1%e6%9d%bf%e5%87%bd%e6%95%b0%e7%9a%84%e7%b1%bb%e5%9e%8b%e5%88%a4%e6%96%ad" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在 C++17 中引入的 &lt;code>if constexpr&lt;/code> 提供了一种更加简洁和可读的方式来进行模板元编程的类型判断。根据类型特性，在编译期选择不同的分支路径。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdint&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cmath&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;type_traits&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> T&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">bool&lt;/span> equal(&lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> a, &lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> b) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_integral_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a &lt;span style="color:#f92672">==&lt;/span> b; &lt;span style="color:#75715e">// 整数类型直接比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#a6e22e">constexpr&lt;/span> (std&lt;span style="color:#f92672">::&lt;/span>is_floating_point_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> fabs(a &lt;span style="color:#f92672">-&lt;/span> b) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1e-3&lt;/span>; &lt;span style="color:#75715e">// 浮点数进行误差比较
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> } &lt;span style="color:#66d9ef">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static_assert&lt;/span>(std&lt;span style="color:#f92672">::&lt;/span>is_arithmetic_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#f92672">||&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>is_pointer_v&lt;span style="color:#f92672">&amp;lt;&lt;/span>T&lt;span style="color:#f92672">&amp;gt;&lt;/span>, &lt;span style="color:#e6db74">&amp;#34;not supported&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>boolalpha;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> equal(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> equal(&lt;span style="color:#ae81ff">1L&lt;/span>, &lt;span style="color:#ae81ff">1L&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> equal(&lt;span style="color:#ae81ff">1.0000001&lt;/span>, &lt;span style="color:#ae81ff">1.000002&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> equal(&lt;span style="color:#ae81ff">1.0000001&lt;/span>, &lt;span style="color:#ae81ff">2.000002&lt;/span>) &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl; &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在传统C++中，我们常用&lt;code>std::enable_if&lt;/code>来实现类似的功能。但是很明显，语法会显得过于笨重。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;type_traits&amp;gt;
#include &amp;lt;cmath&amp;gt;
#include &amp;lt;cstdio&amp;gt;
// 整数类型
template &amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value, bool&amp;gt;::type
equal(const T&amp;amp; a, const T&amp;amp; b) {
return a == b;
}
// 浮点类型
template &amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_floating_point&amp;lt;T&amp;gt;::value, bool&amp;gt;::type
equal(const T&amp;amp; a, const T&amp;amp; b) {
return std::fabs(a - b) &amp;lt;= 1e-3;
}
// 其他类型
template &amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;
!(std::is_integral&amp;lt;T&amp;gt;::value || std::is_floating_point&amp;lt;T&amp;gt;::value), bool&amp;gt;::type
equal(const T&amp;amp; a, const T&amp;amp; b) {
static_assert(std::is_arithmetic&amp;lt;T&amp;gt;::value || std::is_pointer&amp;lt;T&amp;gt;::value, &amp;#34;not supported&amp;#34;);
return false;
}
int main() {
puts(equal(1, 1) ? &amp;#34;true&amp;#34; : &amp;#34;false&amp;#34;); // 整数
puts(equal(1.0000001, 1.000002) ? &amp;#34;true&amp;#34; : &amp;#34;false&amp;#34;); // 浮点
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="使用consteval强制使用编译期求值">使用&lt;code>consteval&lt;/code>强制使用编译期求值 &lt;a href="#%e4%bd%bf%e7%94%a8consteval%e5%bc%ba%e5%88%b6%e4%bd%bf%e7%94%a8%e7%bc%96%e8%af%91%e6%9c%9f%e6%b1%82%e5%80%bc" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;code>consteval&lt;/code> 是在 C++20 中引入的关键字，用于声明立即函数（immediate function）。立即函数要求在编译时进行求值，不能在运行时调用。
如果调用一个&lt;code>consteval&lt;/code>。如果调用 &lt;code>consteval&lt;/code> 函数时无法在编译期计算，编译器将报错。&lt;/p>
&lt;p>&lt;code>constexpr&lt;/code> 函数在某些情况下可能会退化为运行时调用，&lt;code>consteval&lt;/code> 可以避免这种情况。&lt;/p>
&lt;p>例如：&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;iostream&amp;gt;
// consteval 强制要求在编译时进行计算
consteval int factorial(int n) {
return (n &amp;lt;= 1) ? 1 : (n * factorial(n - 1));
}
int main() {
constexpr int result = factorial(5); // OK：在编译时计算
std::cout &amp;lt;&amp;lt; &amp;#34;Factorial of 5 is: &amp;#34; &amp;lt;&amp;lt; result &amp;lt;&amp;lt; std::endl;
// int runtime = 5;
// std::cout &amp;lt;&amp;lt; &amp;#34;Factorial of runtime: &amp;#34; &amp;lt;&amp;lt; factorial(runtime) &amp;lt;&amp;lt; std::endl;
// 错误：factorial 必须在编译时调用
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="使用constinit显式要求编译时初始化">使用&lt;code>constinit&lt;/code>显式要求编译时初始化 &lt;a href="#%e4%bd%bf%e7%94%a8constinit%e6%98%be%e5%bc%8f%e8%a6%81%e6%b1%82%e7%bc%96%e8%af%91%e6%97%b6%e5%88%9d%e5%a7%8b%e5%8c%96" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;code>constinit&lt;/code> 关键字用于显式要求全局或静态变量在编译期完成初始化。
如果变量无法在编译时初始化，编译器将报错。
&lt;code>constinit&lt;/code> 不能用于局部变量。&lt;/p>
&lt;p>与 &lt;code>constexpr&lt;/code> 不同，&lt;code>constinit&lt;/code> 变量可以在运行时被修改。
线程安全性：在多线程环境中，&lt;code>constinit&lt;/code> 确保变量在编译期初始化，避免线程安全问题。&lt;/p>
&lt;pre tabindex="0">&lt;code>#include &amp;lt;array&amp;gt;
// 编译时初始化
constexpr int compute(int v) { return v * v * v; }
constinit int global = compute(10);
// 错误：constinit 变量不能依赖运行时初始化
// constinit int another = global;
int main() {
global = 100; // 允许在运行时修改
// 错误：constinit 变量不是常量，不能用作数组大小
// std::array&amp;lt;int, global&amp;gt; arr;
std::cout &amp;lt;&amp;lt; &amp;#34;Global value: &amp;#34; &amp;lt;&amp;lt; global &amp;lt;&amp;lt; std::endl;
return 0;
}
&lt;/code>&lt;/pre>&lt;h2 id="总结">总结 &lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;code>constexpr&lt;/code>在多数情况下可以替代&lt;code>const&lt;/code>以表达“编译期常量”的语义，可用于函数、变量、类等场景。constexpr 支持在编译期和运行期进行求值，但在某些情况下可能会退化为运行期求值。&lt;/li>
&lt;li>常量表达式函数 提供了一种更清晰的编译期计算方式，能够在一定程度上取代复杂且晦涩的模板元编程。随着 C++ 标准的演进，&lt;code>constexpr&lt;/code> 函数逐步支持了更复杂的语法和逻辑，例如条件语句、循环语句和局部变量。但对于极端复杂的计算场景，编译期计算可能导致显著的编译时间开销。&lt;/li>
&lt;li>&lt;code>constexpr&lt;/code>可以在模板函数中用于类型判断，通过&lt;code>if constexpr&lt;/code>语法有效地取代&lt;code>std::enable_if&lt;/code>，从而简化模板编程，提高代码的可读性和可维护性。&lt;/li>
&lt;li>&lt;code>constexpr&lt;/code>函数的隐式退化风险：在某些场景下，&lt;code>constexpr&lt;/code> 函数可能在运行时执行。若需要严格保证仅在编译期求值，可以使用 &lt;code>consteval&lt;/code> 来强制进行编译期求值，避免不必要的运行时开销。&lt;/li>
&lt;li>&lt;code>constinit&lt;/code>提供了一种显式要求变量在编译时完成初始化的机制，适用于非&lt;code>constexpr&lt;/code>变量。这在全局和静态变量的初始化中尤为有用，同时也保证了多线程环境下的初始化安全性。&lt;/li>
&lt;/ul></description></item><item><title>CPU缓存一致性与内存一致性（第二部分-内存一致性）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</link><pubDate>Sun, 01 Sep 2024 00:24:00 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</guid><description>&lt;h2 id="缓存一致性与内存一致性">缓存一致性与内存一致性 &lt;a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7%e4%b8%8e%e5%86%85%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。&lt;/p>
&lt;p>缓存一致性协议（如 MESI 协议）用于解决多个处理器对相同内存位置进行访问和修改时的数据一致性问题。它确保各处理器的缓存中针对同一内存地址的副本保持一致，避免因缓存不同步而导致的数据错误。&lt;/p>
&lt;p>而内存一致性关注的是处理器对多个不同内存地址的访问顺序问题。当不同处理器的内存访问顺序与程序代码中的预期顺序不一致时，就会引发内存一致性问题。它要求各处理器按照一定的规则访问内存，以保持程序逻辑的正确性。&lt;/p>
&lt;p>简而言之，缓存一致性解决的是同一内存位置的数据同步问题，而内存一致性则涉及多个内存位置的访问顺序问题。&lt;/p>
&lt;h2 id="内存乱序访问产生的原因">内存乱序访问产生的原因 &lt;a href="#%e5%86%85%e5%ad%98%e4%b9%b1%e5%ba%8f%e8%ae%bf%e9%97%ae%e4%ba%a7%e7%94%9f%e7%9a%84%e5%8e%9f%e5%9b%a0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>内存乱序访问的原因可以从两个方面来理解：程序顺序（Program Order, PO）和内存顺序（Memory Order, MO）。程序顺序是指程序代码中编写的内存访问序列，反映了程序员预期的指令执行顺序。按照程序顺序，指令应该依次被执行，以确保程序的逻辑正确性。然而，在实际执行中，系统中可能存在一种不同的顺序，即内存顺序。&lt;/p>
&lt;p>内存顺序是指系统中所有处理器对内存操作达成一致的访问顺序。由于现代计算机系统通常由多个处理器共同操作共享内存，为了提高整体性能，这些处理器可能会对内存操作进行重排序，从而产生与程序顺序不一致的内存顺序。&lt;/p>
&lt;p>这种内存乱序访问的现象主要是为了优化程序执行效率，通常发生在两个阶段：编译阶段和执行阶段。在编译阶段，编译器会对代码进行优化，这可能会导致指令的重排序，以提高执行效率。在执行阶段，多个 CPU 之间的交互也会引起内存访问顺序的不一致。&lt;/p>
&lt;p>在单处理器系统中，CPU 对指令的乱序执行和重排对于程序员来说是透明的，即程序的执行结果与顺序执行的结果是一致的。然而，在多处理器系统中，不同的处理器（或称为观察者）可能会观察到不同的内存执行顺序，这与指令的实际执行顺序不完全一致，从而导致潜在的同步问题和数据不一致性。&lt;/p>
&lt;h2 id="几种常见的一致性模型">几种常见的一致性模型 &lt;a href="#%e5%87%a0%e7%a7%8d%e5%b8%b8%e8%a7%81%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8b" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在多处理器系统中，内存一致性模型决定了不同处理器之间如何观察和执行内存操作的顺序。以下介绍几种常见的一致性模型：&lt;/p>
&lt;h3 id="顺序一致性模型sequential-consistency-sc">顺序一致性模型（Sequential Consistency, SC） &lt;a href="#%e9%a1%ba%e5%ba%8f%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8bsequential-consistency-sc" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>顺序一致性模型的概念最早由 Leslie Lamport 在 1979 年的论文《如何构建正确执行多处理程序的多处理计算机》中提出。按照他的定义：&lt;/p>
&lt;p>任何执行的结果都与所有处理器的操作按照某种顺序依次执行的结果相同，并且每个处理器的操作在这个顺序中出现的顺序与其程序中指定的顺序一致。满足这一条件的多处理器被称为顺序一致性系统。&lt;/p>
&lt;p>顺序一致性模型保证了每个加载（Load）和存储（Store）指令按照程序中指定的严格顺序执行，确保了“读-&amp;gt;读”、“读-&amp;gt;写”、“写-&amp;gt;写”以及“写-&amp;gt;读”四种操作的顺序。这种模型提供了最强的内存一致性保证，但代价是较低的执行效率，因为它不允许任何形式的指令重排序。&lt;/p>
&lt;h3 id="处理器一致性模型processor-consistency-pc">处理器一致性模型（Processor Consistency, PC) &lt;a href="#%e5%a4%84%e7%90%86%e5%99%a8%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8bprocessor-consistency-pc" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>处理器一致性模型是顺序一致性模型的弱化版本，它放宽了对“写-&amp;gt;读”操作顺序的要求。该模型允许处理器在读取时从存储缓冲区（Store Buffer）中获取一个尚未写入缓存的值，即使这个值还没有被其他处理器看到。x86-64 实现的全序写（Total Store Ordering, TSO）模型就是处理器一致性的一种。TSO 允许一定程度的乱序执行，提高了系统的性能，同时仍然提供了较强的一致性保证。&lt;/p>
&lt;h3 id="弱一致性模型weak-consistency-wc">弱一致性模型（Weak Consistency, WC） &lt;a href="#%e5%bc%b1%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8bweak-consistency-wc" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>弱一致性模型进一步弱化了处理器一致性模型的要求，放宽了对“读-&amp;gt;读”、“读-&amp;gt;写”、“写-&amp;gt;写”以及“写-&amp;gt;读”四种操作顺序的约束。为了确保程序执行的正确性，程序员需要在合适的地方显式添加同步操作。在这种模型中，多处理器系统的内存访问满足以下三个条件时称为弱一致性内存访问：&lt;/p>
&lt;ul>
&lt;li>对全局同步变量的访问是顺序一致的&lt;/li>
&lt;li>在一个同步操作（如内存屏障指令）执行之前，所有先前的数据访问必须完成；&lt;/li>
&lt;li>在一个正常的数据访问（如数据访问指令）执行之前，所有先前的同步操作（如内存屏障指令）必须完成。&lt;/li>
&lt;/ul>
&lt;h3 id="释放一致性模型release-consistency-rc">释放一致性模型（Release Consistency, RC） &lt;a href="#%e9%87%8a%e6%94%be%e4%b8%80%e8%87%b4%e6%80%a7%e6%a8%a1%e5%9e%8brelease-consistency-rc" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>释放一致性模型是在弱一致性模型的基础上引入了“获取”（acquire）和“释放”（release）屏障原语，用于简化共享数据的互斥访问。&lt;/p>
&lt;p>在该模型中，“获取”屏障原语后面的读写操作不能被重排到该屏障之前，“释放”屏障原语前面的读写操作不能被重排到该屏障之后。这种机制能够更高效地管理多处理器系统中的共享数据访问，提高并行性能。&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/38b192183bdefe1e658707d505a5263f12e4ba34/wizmann-pic/image_1724584827296_0.png" alt="">&lt;/p>
&lt;p>这些内存一致性模型提供了从严格到宽松的不同选择，适应不同的应用需求和性能要求。选择合适的一致性模型对多处理器系统的设计和优化至关重要。&lt;/p>
&lt;h2 id="四种内存乱序">四种内存乱序 &lt;a href="#%e5%9b%9b%e7%a7%8d%e5%86%85%e5%ad%98%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在多处理器系统中，为了优化性能，处理器可能会对内存操作进行不同类型的乱序执行。这种乱序行为包括四种主要类型，每一种都会以不同的方式影响多线程程序的正确性和一致性。&lt;/p>
&lt;h3 id="loadload-乱序">LoadLoad 乱序 &lt;a href="#loadload-%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>LoadLoad 乱序指的是后续的加载（读取）操作可以在先前的加载操作完成之前开始，或者两个加载操作的完成顺序与它们的发起顺序不同。这意味着处理器可能会优先执行后发起的加载操作。这种乱序优化可能有助于提高程序的执行速度，但如果未加以控制，可能会导致某些线程读取到不一致的数据。&lt;/p>
&lt;h3 id="loadstore-乱序">LoadStore 乱序 &lt;a href="#loadstore-%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>LoadStore 乱序表示一个存储（写入）操作可以在之前发起的加载操作完成之前开始执行，或者写操作可能“超越”读操作。尽管这种优化可以提高处理器的性能，但在多线程程序中可能导致意外的行为。例如，一个线程可能会看到数据被写入之前的状态，导致逻辑错误或数据不一致。&lt;/p>
&lt;h3 id="storeload-乱序">StoreLoad 乱序 &lt;a href="#storeload-%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>StoreLoad 乱序是四种乱序类型中对编程模型影响最大的一种。它允许一个加载操作在之前的存储操作完成之前开始，或者读取操作可能看到写操作的结果，即使这个写操作在程序中的顺序上应该发生在读操作之后。这种乱序执行可能导致一个线程读取到另一个线程的“旧”值，而不是最新写入的值，从而引发数据同步问题。&lt;/p>
&lt;h3 id="storestore-乱序">StoreStore 乱序 &lt;a href="#storestore-%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>StoreStore 乱序涉及两个连续的存储操作，其中后一个存储操作可以在第一个操作完成之前开始，或者它们的完成顺序与它们被发起的顺序不同。这意味着，后一个写操作的结果可能在前一个写操作的结果对其他处理器可见之前就已经被观察到，从而造成数据顺序的不一致。&lt;/p>
&lt;h3 id="管理内存乱序的重要性">管理内存乱序的重要性 &lt;a href="#%e7%ae%a1%e7%90%86%e5%86%85%e5%ad%98%e4%b9%b1%e5%ba%8f%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>正确管理这些乱序行为对于并发编程至关重要，特别是在设计无锁数据结构和编写多线程程序时。如果不加以控制，这些乱序可能导致数据不一致、难以重现的错误和程序崩溃。为了避免这些问题，现代处理器和编程语言提供了各种内存屏障（Memory Barriers）或内存顺序（Memory Order）指令，确保在关键的程序点上强制执行所需的内存操作顺序。这些机制帮助程序员在优化性能的同时，维护数据的一致性和正确性。&lt;/p>
&lt;h2 id="使用litmus工具分析内存乱序---以x86-tso为例">使用Litmus工具分析内存乱序 - 以x86-TSO为例 &lt;a href="#%e4%bd%bf%e7%94%a8litmus%e5%b7%a5%e5%85%b7%e5%88%86%e6%9e%90%e5%86%85%e5%ad%98%e4%b9%b1%e5%ba%8f---%e4%bb%a5x86-tso%e4%b8%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>在并发编程中，理解和验证内存模型的行为对于确保程序的正确性至关重要。以 x86 Total Store Order (x86-TSO) 为例，我们可以使用 Litmus 测试工具来分析内存乱序现象，并了解如何通过内存屏障来避免这种情况。&lt;/p>
&lt;blockquote>
&lt;p>Litmus工具可以在&lt;a href="https://developer.arm.com/herd7">这里&lt;/a>在线试用，也可以安装到本地环境&lt;/p>&lt;/blockquote>
&lt;h3 id="x86-total-store-order-x86-tso">x86 Total Store Order (x86-TSO) &lt;a href="#x86-total-store-order-x86-tso" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-09-01/1725159498577_mem-tso_1723970692408_0.png" alt="">&lt;/p>
&lt;p>在 x86 架构中，Store Buffer（存储缓冲区）用于暂时存放处理器的写操作，而不立即将其写入主存。这种机制提高了处理器的性能，因为它允许处理器在写操作尚未完成时继续执行后续指令。然而，Store Buffer 也导致了某些内存操作的可见性问题，特别是在多处理器环境中。&lt;/p>
&lt;p>x86 Total Store Order (x86-TSO) 模型的特性正是由这种 Store Buffer 机制决定的。由于写操作在 Store Buffer 中暂存，x86-TSO 模型保证了一些关键特性，同时也做出了一些基于性能的妥协：&lt;/p>
&lt;ul>
&lt;li>写操作顺序一致性：所有写操作按照程序的顺序执行，并对所有处理器可见，即写操作在 Store Buffer 刷新到主存之前，不会被其他处理器看到。&lt;/li>
&lt;li>读操作的自我可见性：处理器可以立即看到自己在 Store Buffer 中的最新写入，即本处理器的读操作可以从 Store Buffer 中读取未提交到主存的值。&lt;/li>
&lt;li>防止某些重排序：为了避免因 Store Buffer 导致的读写乱序，x86-TSO 禁止写操作与其后的读操作重排序，确保读写顺序一致。&lt;/li>
&lt;li>允许部分读操作重排序：为了进一步提升性能，处理器允许一些读操作的重排序，但仍然遵循严格的规则以保证程序的正确性。&lt;/li>
&lt;/ul>
&lt;h3 id="使用-litmus-验证-x86-的-storeload-乱序">使用 Litmus 验证 x86 的 StoreLoad 乱序 &lt;a href="#%e4%bd%bf%e7%94%a8-litmus-%e9%aa%8c%e8%af%81-x86-%e7%9a%84-storeload-%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们可以使用 Litmus 工具来验证在 x86-TSO 内存模型下的 StoreLoad 乱序行为。以下是一个示例代码：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-litmus" data-lang="litmus">X86 SB
{ x = 0; y = 0; }
P0 | P1 ;
MOV [y],$1 | MOV [x],$1 ;
MOV EAX,[x] | MOV EAX,[y] ;
exists
(0:EAX=0 /\ 1:EAX=0)
&lt;/code>&lt;/pre>&lt;p>在执行该代码后，Litmus 会生成四种可能的结果，分别对应不同的执行顺序。&lt;/p>
&lt;h4 id="结果1">结果1 &lt;a href="#%e7%bb%93%e6%9e%9c1" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-09-01/1725159921512_graph3_1725095884015_0.png" alt="">&lt;/p>
&lt;p>在结果1中，程序按照严格的顺序执行，每个处理器的内存操作顺序与程序中的顺序一致。&lt;/p>
&lt;p>图中，po（Program Order）表示程序顺序，rf（Reads-From）表示每个读操作从哪个写操作中读取的值。由于内存操作按照预期顺序执行，这种情况没有进一步的乱序行为，因此不需要进一步分析&lt;/p>
&lt;h4 id="结果2结果3">结果2/结果3 &lt;a href="#%e7%bb%93%e6%9e%9c2%e7%bb%93%e6%9e%9c3" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-09-01/1725160079968_graph1_1725098202554_0.png" alt="">
&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-09-01/1725160089725_graph2_1725098310293_0.png" alt="">&lt;/p>
&lt;p>结果2和结果3是对称的，表示在执行过程中，内存的读取发生了“乱序”，即读取操作被重排到了写入操作之前。在 Litmus 中，这种情况被标记为 fr（From-Read），表示一个写操作覆盖了一个读操作所读取的值，即这个写操作发生在读操作之后。这种“写读”操作的乱序可能是由于执行顺序的不同，也可能是内存模型的顺序造成的。&lt;/p>
&lt;h4 id="结果4">结果4 &lt;a href="#%e7%bb%93%e6%9e%9c4" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-09-01/1725160171251_graph0_1725099005660_0.png" alt="">&lt;/p>
&lt;p>结果4表示两个线程各自都发生了 fr，即每个线程的读操作都被重排到了写操作之前。这种情况展示了最复杂的乱序行为，其中两个线程的读操作分别“超越”了各自的写操作。&lt;/p>
&lt;h3 id="使用内存屏障mfence指令避免内存乱序">使用内存屏障（MFENCE）指令避免内存乱序 &lt;a href="#%e4%bd%bf%e7%94%a8%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9cmfence%e6%8c%87%e4%bb%a4%e9%81%bf%e5%85%8d%e5%86%85%e5%ad%98%e4%b9%b1%e5%ba%8f" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>为了避免这种乱序情况，可以使用 MFENCE（Memory Fence） 指令。在 x86 架构中，MFENCE 是一种强制内存屏障，确保所有在 MFENCE 之前的内存操作（无论是读还是写）在所有 MFENCE 之后的内存操作之前完成。这意味着在同一线程内，MFENCE 保证了内存操作的顺序性：MFENCE 之前的操作对其他线程可见后，才可以执行 MFENCE 之后的操作。&lt;/p>
&lt;p>我们可以将 Litmus 代码修改如下，以插入 MFENCE 指令：&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-litmus" data-lang="litmus">X86 SB
{ x = 0; y = 0; }
P0 | P1 ;
MOV [y],$1 | MOV [x],$1 ;
MFENCE | MFENCE ;
MOV EAX,[x] | MOV EAX,[y] ;
exists
(0:EAX=0 /\ 1:EAX=0)
&lt;/code>&lt;/pre>&lt;p>在加入内存屏障后，我们看到结果1到结果3依然会出现，但结果4因 MFENCE 的存在而被避免。通过 MFENCE 确保了内存操作的顺序性，从而防止了某些类型的内存乱序，保证了多线程程序的正确性和一致性。&lt;/p>
&lt;h2 id="接下来">接下来&amp;hellip; &lt;a href="#%e6%8e%a5%e4%b8%8b%e6%9d%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>下一篇文章中，我们会介绍C++的内存顺序模型，并且分析更复杂的内存乱序问题&lt;/p>
&lt;h2 id="references">References &lt;a href="#references" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://colobu.com/2021/06/30/hwmm/">硬件内存模型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://book.douban.com/subject/36240082/">RISC-V体系结构编程与实践&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.microsoft.com/en-us/research/publication/make-multiprocessor-computer-correctly-executes-multiprocess-programs/">How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dl.acm.org/doi/10.1145/285930.285991">Memory access buffering in multiprocessors&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cl.cam.ac.uk/~pes20/weakmemory/tacas11.pdf">Litmus: Running Tests Against Hardware&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.arm.com/herd7">Herd7 Simulator&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/0voice/dpdk_engineer_manual/blob/main/%E5%A4%A7%E4%BC%9APPT/NA%202021-Memory%20Model%20Simulation%20Tool%20-%20Herd7.pdf">Memory Model Simulation Tool - Herd7&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/how-to-use-the-memory-model-tool#intuitively">A working example of how to use the herd7 Memory Model Tool&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>CPU缓存一致性与内存一致性（第一部分-MESI协议）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order/</link><pubDate>Mon, 18 Mar 2024 23:21:35 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order/</guid><description>&lt;p>在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。
然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。&lt;/p>
&lt;h3 id="缓存一致性">缓存一致性 &lt;a href="#%e7%bc%93%e5%ad%98%e4%b8%80%e8%87%b4%e6%80%a7" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>缓存一致性是指在一个多处理器系统中，确保当某个处理器修改了存储在共享资源（如主内存或缓存中的数据）时，其他处理器能够访问到最新的数据版本，从而保证数据的一致性。&lt;/p>
&lt;p>为了达到这一目标，缓存一致性机制必须处理两个主要问题：写传播（Write Propagation）和事务串行化（Transaction Serialization）。&lt;/p>
&lt;p>写传播确保一个处理器核心的写操作能被传播并被其他处理器核心所见。而事务串行化则确保所有处理器核心的写操作按照一定的顺序执行，对所有处理器核心而言这个顺序是一致的。这两个机制共同工作，确保了即使多个CPU可能并发地修改同一份数据，它们也能看到一致的数据视图。&lt;/p>
&lt;h3 id="mesi协议">MESI协议 &lt;a href="#mesi%e5%8d%8f%e8%ae%ae" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>为了实现缓存一致性，多种协议和机制被设计出来，其中MESI协议是最广泛使用的一种机制。&lt;/p>
&lt;blockquote>
&lt;p>实际上，AMD处理器使用的是MOESI协议，Intel处理器使用的是MESIF协议。这两种协议都是MESI协议的变种。这里不展开讨论。&lt;/p>&lt;/blockquote>
&lt;p>MESI 协议通过定义缓存行的四种状态——修改（Modified）、独占（Exclusive）、共享（Shared）和无效（Invalid），管理多个处理器缓存之间的一致性。状态之间的转换受到缓存协议控制，以确保数据的一致性和同步。&lt;/p>
&lt;ul>
&lt;li>独占（Exclusive, E）：缓存行仅存在于当前缓存中，并且是干净的（即缓存数据与主存数据一致）。当其他缓存尝试读取该数据时，状态转变为共享；当前缓存写入数据时，转变为已修改状态&lt;/li>
&lt;li>共享（Shared, S）：缓存行同时存在于其他缓存中，并且是干净的。该缓存行可以在任意时刻被抛弃&lt;/li>
&lt;li>已修改（Modified, M）：缓存行的数据是“脏”的（即与主存的值不同）。如果其他 CPU 核心需要读取这块数据，该缓存行必须先回写到主存，然后状态转变为共享&lt;/li>
&lt;li>无效（Invalid, I）：表示该缓存行无效，即为空。上文提到的缓存策略会优先填充无效行&lt;/li>
&lt;/ul>
&lt;p>简单来说，MESI的设计目标在于：&lt;/p>
&lt;ol>
&lt;li>防止多个处理器核心同时对共享数据进行修改。任何需要修改共享数据的核心都会先发出RFO（Read For Ownership）请求来获取该缓存块的所有权，并使其他处理器核心中的相应缓存块变为无效。&lt;/li>
&lt;li>通过推迟写回操作来减少对内存的频繁修改，确保只有在必要时才将缓存中的更改写回内存。&lt;/li>
&lt;/ol>
&lt;h3 id="mesi-的状态转移">MESI 的状态转移 &lt;a href="#mesi-%e7%9a%84%e7%8a%b6%e6%80%81%e8%bd%ac%e7%a7%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>MESI 协议的状态转移如下：&lt;/p>
&lt;p>&lt;img src="https://raw.githubusercontent.com/Wizmann/assets/master/wizmann-pic/24-03-31/1711876193915_Diagrama_MESI.gif" alt="">&lt;/p>
&lt;ul>
&lt;li>从无效（I）到独占（E）：当 CPU 需要写入一个缓存行而该行当前状态为无效时，如果其他 CPU 缓存中没有该缓存行的副本，该行状态变为独占。这表明当前 CPU 缓存中的数据是最新的，且没有其他副本存在&lt;/li>
&lt;li>从无效（I）到共享（S）：当 CPU 需要读取一个缓存行而该行当前状态为无效时，如果其他 CPU 缓存中存在该缓存行的副本，则该行状态变为共享&lt;/li>
&lt;li>从共享（S）到独占（E）：当一个 CPU 想要写入一个处于共享状态的缓存行时，必须首先获取其他所有 CPU 上该缓存行的独占访问权，如果成功，该缓存行状态变为独占&lt;/li>
&lt;li>从独占（E）到修改（M）：当 CPU 对处于独占状态的缓存行进行写操作时，该缓存行状态变为修改。这表示数据已被当前 CPU 修改，且与主存不同步&lt;/li>
&lt;li>从修改（M）到共享（S）：当其他 CPU 请求读取处于修改状态的缓存行时，当前 CPU 必须将该缓存行的数据写回主存，并将缓存行状态改为共享，以便其他 CPU 可以读取最新数。&lt;/li>
&lt;li>从任何状态到无效（I）：当 CPU 接收到其他 CPU 发出的无效化请求时，如果当前 CPU 缓存中有该缓存行的副本，不论它处于何种状态，都必须将其标记为无效。这通常发生在其他 CPU 想要写入同一缓存行的情况下&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>可以使用这个&lt;a href="https://www.scss.tcd.ie/Jeremy.Jones/VivioJS/caches/MESI.htm">简单的模拟器&lt;/a>来模拟MESI协议的工作状态&lt;/p>&lt;/blockquote>
&lt;h3 id="mesi的优化">MESI的优化 &lt;a href="#mesi%e7%9a%84%e4%bc%98%e5%8c%96" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>随着多核处理器的普及和系统复杂度的增加，MESI协议面临着性能瓶颈和效率问题。因此，为了提高系统性能和缩短响应时间，对MESI协议的优化变得非常必要。&lt;/p>
&lt;h4 id="写缓冲区store-buffer机制">写缓冲区（Store Buffer）机制 &lt;a href="#%e5%86%99%e7%bc%93%e5%86%b2%e5%8c%bastore-buffer%e6%9c%ba%e5%88%b6" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在进行写入操作时，一个CPU核心（例如核心1）首先需要广播一个读取为了写入（Read For Ownership，RFO）请求，以获得对应数据的独占访问权。在等待其他核心响应此请求并发送回确认信号（ACK）期间，核心1原本需要空闲等待，这无疑是对CPU资源的一种浪费。&lt;/p>
&lt;p>为了提高效率，现代CPU设计了“写缓冲区”机制。通过这种机制，当核心1发出RFO请求并将写入操作放入写缓冲区后，它可以立即继续执行其他任务，而不需要等待ACK的到来。一旦收到ACK，CPU再从写缓冲区中取出写入操作，实际写入到缓存中。这样不仅优化了CPU的工作流程，还提升了处理器的整体效能。&lt;/p>
&lt;h4 id="失效队列invalidation-queue">失效队列（Invalidation Queue） &lt;a href="#%e5%a4%b1%e6%95%88%e9%98%9f%e5%88%97invalidation-queue" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>为了解决核心在忙碌时无法及时响应RFO请求的问题，现代CPU引入了“失效队列”机制。收到的RFO请求被放入失效队列，并立即发送回ACK，待核心完成手头上的任务后，再处理失效队列中的请求。这种设计有效地缩短了等待时间，加速了数据同步过程。&lt;/p>
&lt;h3 id="mesi的潜在问题">MESI的潜在问题 &lt;a href="#mesi%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="false-sharing">False Sharing &lt;a href="#false-sharing" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>由于CPU以64B的Cache Line为最小单位从内存中加载数据，可能会出现这样的问题：&lt;/p>
&lt;p>假设变量a和b位于同一个Cache Line中，当前CPU0和CPU1都将这个Cache Line加载到Cache，CPU0只修改变量a，CPU1只读取变量b。当CPU0修改a时，CPU1的Cache Line会变为Invalid状态，即使CPU1并没有修改b，这会导致CPU1从内存或其它核心重新加载Cache Line中的所有变量，影响性能。这就是False Sharing。&lt;/p>
&lt;p>解决False Sharing的常用方法是进行字节填充，在a和b之间填充无意义的变量，使一个变量单独占用一个Cache Line。&lt;/p>
&lt;h4 id="rmw操作">RMW操作 &lt;a href="#rmw%e6%93%8d%e4%bd%9c" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在并发编程中，读-改-写（RMW）操作，如比较并交换（CAS）和原子加（ADD），需作为单一的原子操作执行以避免数据竞争。&lt;/p>
&lt;p>尽管MESI缓存一致性协议确保了处理器核心间缓存行状态的一致性，它并不解决操作的原子性问题。在RMW操作中，由于从读取到写回的时间窗口内可能发生其他处理器的干预修改，可能导致数据竞争和状态不一致。&lt;/p>
&lt;p>在为此，&lt;code>LOCK&lt;/code>指令被用来确保RMW操作的原子性，通过锁定操作涉及的缓存行，防止在操作完成前被其他处理器访问，从而有效地解决了数据竞争问题，保障了操作的安全性和数据的一致性。&lt;/p>
&lt;h4 id="写缓冲区store-buffer优化带来的潜在问题">写缓冲区（Store Buffer）优化带来的潜在问题 &lt;a href="#%e5%86%99%e7%bc%93%e5%86%b2%e5%8c%bastore-buffer%e4%bc%98%e5%8c%96%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>写缓冲区带来的最主要的问题是与其他核心的数据一致性问题。由于写操作被延迟执行，其他核心可能在这段时间内读取到了旧的数据值，从而导致数据不一致的问题。此外，写缓冲区可能导致内存顺序的问题，即编写的程序逻辑与实际执行逻辑不符。&lt;/p>
&lt;h4 id="失效队列invalidation-queue带来的潜在问题">失效队列（Invalidation Queue）带来的潜在问题 &lt;a href="#%e5%a4%b1%e6%95%88%e9%98%9f%e5%88%97invalidation-queue%e5%b8%a6%e6%9d%a5%e7%9a%84%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>失效队列提高了响应速度，但它也可能引入新的问题。失效队列允许CPU核心在确认接收到失效请求后，延迟处理这些请求。这种延迟可能导致数据在不同核心间的一致性问题，即一个核心可能会在短时间内继续使用已经失效的数据，而这段时间内其他核心已经修改了这部分数据。&lt;/p>
&lt;h2 id="参考链接">参考链接 &lt;a href="#%e5%8f%82%e8%80%83%e9%93%be%e6%8e%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI协议&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/LeoYang90/Golang-Internal-Notes/blob/master/Go%20%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.md#go-%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B">Go 内存一致性模型&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/7158395475362578462">12 张图看懂 CPU 缓存一致性与 MESI 协议，真的一致吗？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://wudaijun.com/2019/04/cache-coherence-and-memory-consistency/">Cache一致性和内存一致性&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.chongsheng.art/post/golang/cpu-cache-memory-barrier/">CPU缓存架构到内存屏障&lt;/a>&lt;/li>
&lt;/ul>
&lt;div class="alert alert-info" role="alert">本文大（划掉）部分内容由ChatGPT4生成&lt;/div></description></item><item><title>内存屏障初探</title><link>https://wizmann.top/posts/read-paper-barrier/</link><pubDate>Thu, 08 May 2014 19:05:26 +0000</pubDate><guid>https://wizmann.top/posts/read-paper-barrier/</guid><description>&lt;h2 id="原文地址">原文地址 &lt;a href="#%e5%8e%9f%e6%96%87%e5%9c%b0%e5%9d%80" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;a href="http://ridiculousfish.com/blog/posts/barrier.html">Barrier February 17th, 2007&lt;/a>&lt;/p>
&lt;h2 id="前言多核时代的挑战">前言：多核时代的挑战 &lt;a href="#%e5%89%8d%e8%a8%80%e5%a4%9a%e6%a0%b8%e6%97%b6%e4%bb%a3%e7%9a%84%e6%8c%91%e6%88%98" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。&lt;/p>
&lt;h2 id="线程技术探讨">线程技术探讨 &lt;a href="#%e7%ba%bf%e7%a8%8b%e6%8a%80%e6%9c%af%e6%8e%a2%e8%ae%a8" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="名词解释">名词解释 &lt;a href="#%e5%90%8d%e8%af%8d%e8%a7%a3%e9%87%8a" class="anchor">🔗&lt;/a>&lt;/h3>&lt;h4 id="线程">线程 &lt;a href="#%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>线程是一种拥有共享地址空间的、能被抢占式调度的执行上下文。&lt;/p>
&lt;h4 id="多线程">多线程 &lt;a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>多线程是一种用于简化控制流、绕过阻塞系统调用的方法，并不专门用于实现程序的并行化。&lt;/p>
&lt;h4 id="并发多线程">并发多线程 &lt;a href="#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>物理上并行执行的线程，旨在通过利用多核处理器优化系统性能。&lt;/p>
&lt;h3 id="并发多线程的挑战">“并发多线程”的挑战 &lt;a href="#%e5%b9%b6%e5%8f%91%e5%a4%9a%e7%ba%bf%e7%a8%8b%e7%9a%84%e6%8c%91%e6%88%98" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>尽管并发多线程被广泛讨论，其挑战并非源自自然原因，而是我们自己的设计选择所造成的。主要问题在于，针对单线程程序的过度优化在多线程环境中不再适用。&lt;/p>
&lt;p>具体来说，由于CPU的执行速度远超内存响应速度，我们开始对内存内容进行“预测”，从而避免CPU等待内存检查。这里的“预测”实际上是CPU和编译器对内存状态做出的越来越激进的假设。&lt;/p>
&lt;h2 id="示例分析">示例分析 &lt;a href="#%e7%a4%ba%e4%be%8b%e5%88%86%e6%9e%90" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="写线程示例">写线程示例 &lt;a href="#%e5%86%99%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 初始时 variable1 = variable2 = 0;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable2&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="读线程示例">读线程示例 &lt;a href="#%e8%af%bb%e7%ba%bf%e7%a8%8b%e7%a4%ba%e4%be%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">while&lt;/span> (&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local2 &lt;span style="color:#f92672">=&lt;/span> variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (local2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> local1) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="color:#e6db74">&amp;#34;Error!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正常逻辑下，local2 应当始终小于或等于 local1，因为 variable1 总是在 variable2 之后增加。&lt;/p>
&lt;p>然而，现实是否如此？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;ctime&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;sys/time.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;unistd.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> variable1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">unsigned&lt;/span> variable2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ITERATIONS 200000000
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">writer&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1 &lt;span style="color:#f92672">=&lt;/span> variable1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable2 &lt;span style="color:#f92672">=&lt;/span> variable2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reader&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">timeval&lt;/span> start, end;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gettimeofday(&lt;span style="color:#f92672">&amp;amp;&lt;/span>start, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> i, failureCount &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> ITERATIONS; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v2 &lt;span style="color:#f92672">=&lt;/span> variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> v1) failureCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> gettimeofday(&lt;span style="color:#f92672">&amp;amp;&lt;/span>end, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">double&lt;/span> seconds &lt;span style="color:#f92672">=&lt;/span> end.tv_sec &lt;span style="color:#f92672">+&lt;/span> end.tv_usec &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">1000000.&lt;/span> &lt;span style="color:#f92672">-&lt;/span> start.tv_sec &lt;span style="color:#f92672">-&lt;/span> start.tv_usec &lt;span style="color:#f92672">/&lt;/span> &lt;span style="color:#ae81ff">1000000.&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> printf(&lt;span style="color:#e6db74">&amp;#34;%u failure%s (%2.1f percent of the time) in %2.1f seconds&lt;/span>&lt;span style="color:#ae81ff">\n&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> failureCount, failureCount &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">?&lt;/span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;s&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (&lt;span style="color:#ae81ff">100.&lt;/span> &lt;span style="color:#f92672">*&lt;/span> failureCount) &lt;span style="color:#f92672">/&lt;/span> ITERATIONS, seconds);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(&lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_t thread1, thread2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>thread1, NULL, writer, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_create(&lt;span style="color:#f92672">&amp;amp;&lt;/span>thread2, NULL, reader, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">for&lt;/span> (;;) sleep(&lt;span style="color:#ae81ff">1000000&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>输出结果：&lt;code>0 failures (0.0 percent of the time) in 1.2 seconds&lt;/code>&lt;/p>
&lt;h3 id="貌似是正确的">貌似是正确的？ &lt;a href="#%e8%b2%8c%e4%bc%bc%e6%98%af%e6%ad%a3%e7%a1%ae%e7%9a%84" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>程序运行的正如我们预期的那样，那么我们可以确信程序是一定正确的吗？&lt;/p>
&lt;p>不能。&lt;/p>
&lt;p>因为程序中的两个线程如果在同一个CPU上被调度，我们永远都会得到正确的结果。&lt;/p>
&lt;h3 id="线程与不同的cpu进行绑定">线程与不同的CPU进行绑定 &lt;a href="#%e7%ba%bf%e7%a8%8b%e4%b8%8e%e4%b8%8d%e5%90%8c%e7%9a%84cpu%e8%bf%9b%e8%a1%8c%e7%bb%91%e5%ae%9a" class="anchor">🔗&lt;/a>&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">writer&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu_set_t cpuset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sched_setaffinity(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cpuset), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">reader&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#f92672">*&lt;/span>unused) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cpu_set_t cpuset;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_ZERO(&lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CPU_SET(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sched_setaffinity(&lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#66d9ef">sizeof&lt;/span>(cpuset), &lt;span style="color:#f92672">&amp;amp;&lt;/span>cpuset);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// p.s. 我机器是i5双核四线程，所以绑在了CPU0和CPU2上
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果：&lt;code>0 failures (0.0 percent of the time) in 1.4 seconds&lt;/code>&lt;/p>
&lt;h3 id="似乎仍然是准确的">似乎仍然是准确的 &lt;a href="#%e4%bc%bc%e4%b9%8e%e4%bb%8d%e7%84%b6%e6%98%af%e5%87%86%e7%a1%ae%e7%9a%84" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>尽管如此，我们考虑到CPU对变量的操作其实是作用在寄存器上，而variable1和variable2紧密相邻，这可能导致它们位于缓存的同一行。因此，它们有可能会同时被写入缓存并一起写回内存。&lt;/p>
&lt;p>为了观察不同的效果，我们尝试将这两个变量分别放置在堆和栈上。&lt;/p>
&lt;pre tabindex="0">&lt;code>0 failures (0.0 percent of the time) in 1.2 seconds
0 failures (0.0 percent of the time) in 1.2 seconds
2000000000 failures (100.0 percent of the time) in 1.2 seconds
&lt;/code>&lt;/pre>&lt;p>&lt;strong>太感人了！&lt;/strong>&lt;/p>
&lt;h3 id="我们的敌人--编译器">我们的敌人 —— 编译器 &lt;a href="#%e6%88%91%e4%bb%ac%e7%9a%84%e6%95%8c%e4%ba%ba--%e7%bc%96%e8%af%91%e5%99%a8" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>Multithreading bugs are very delicate.&lt;/p>&lt;/blockquote>
&lt;p>并行多线程的错误总是那么的奇妙，也许你的程序运行了几天安然无恙，但是在某一天某一时突然出现了难以复现的精妙bug。&lt;/p>
&lt;p>如果多个线程调度在同一个CPU核心上，Bug会被掩盖。 &lt;br>
如果多个变量在CPU同一行Cache上，Bug会被掩盖。 &lt;br>
如果你人品足够好的话，Bug同样会被掩盖。&lt;/p>
&lt;p>但是，如果我们排除了以上的情况后，问题就浮现出来了。&lt;/p>
&lt;p>我们来看一看reader的反汇编代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>(gdb) disas reader
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Dump of assembler code &lt;span style="color:#66d9ef">for&lt;/span> function reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400950&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> push &lt;span style="color:#f92672">%&lt;/span>rbx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400951&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>eax,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400953&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x10&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400958&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">8&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x80&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040095d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">13&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040095f&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">15&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0xa0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>rsp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400966&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">22&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>rsp,&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400969&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">25&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>rsp,&lt;span style="color:#f92672">%&lt;/span>rdx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040096c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">28&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> rep stos &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>es:(&lt;span style="color:#f92672">%&lt;/span>rdi)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040096f&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">31&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>edi,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400971&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">33&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> movq &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x4&lt;/span>,(&lt;span style="color:#f92672">%&lt;/span>rsp)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400979&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">41&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400790&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>sched_setaffinity&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040097e&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">46&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> lea &lt;span style="color:#ae81ff">0x80&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400986&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">54&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>esi,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400988&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">56&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400710&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>gettimeofday&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040098d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">61&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e4&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>rax &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601078&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable2_p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400994&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">68&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e6&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>edx &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601080&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable1&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040099a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">74&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov (&lt;span style="color:#f92672">%&lt;/span>rax),&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x000000000040099c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">76&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x77359400&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009a1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">81&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> nopl &lt;span style="color:#ae81ff">0x0&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#f92672">%&lt;/span>ecx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009aa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> adc &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ad&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">93&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009b0&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">96&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> jne &lt;span style="color:#ae81ff">0x4009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009b2&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">98&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> lea &lt;span style="color:#ae81ff">0x90&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>rdi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ba&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">106&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>esi,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009bc&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">108&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400710&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>gettimeofday&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009c1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">113&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x98&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009cb&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">123&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x90&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009d5&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">133&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> movsd &lt;span style="color:#ae81ff">0x1a3&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm3 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b80&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009dd&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">141&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009df&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">143&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x88&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009e9&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">153&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009ec&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">156&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b3d&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009f1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">161&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009f6&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">166&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#f92672">%&lt;/span>xmm3,&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009fa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">170&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#f92672">%&lt;/span>ebx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x00000000004009fc&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">172&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b40&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>esi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a01&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">177&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#f92672">%&lt;/span>xmm3,&lt;span style="color:#f92672">%&lt;/span>xmm2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a05&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">181&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> addsd &lt;span style="color:#f92672">%&lt;/span>xmm0,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a09&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">185&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sdq &lt;span style="color:#ae81ff">0x80&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rsp),&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a13&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">195&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> subsd &lt;span style="color:#f92672">%&lt;/span>xmm0,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a17&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">199&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cvtsi2sd &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>xmm0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a1c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">204&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x400b3c&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a21&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">209&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmovne &lt;span style="color:#f92672">%&lt;/span>rax,&lt;span style="color:#f92672">%&lt;/span>rcx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a25&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">213&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x2&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a2a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">218&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mulsd &lt;span style="color:#ae81ff">0x156&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm0 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b88&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a32&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">226&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> subsd &lt;span style="color:#f92672">%&lt;/span>xmm2,&lt;span style="color:#f92672">%&lt;/span>xmm1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a36&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">230&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> divsd &lt;span style="color:#ae81ff">0x152&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>xmm0 &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x400b90&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a3e&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">238&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x400700&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>__printf_chk&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a43&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">243&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> xor &lt;span style="color:#f92672">%&lt;/span>edi,&lt;span style="color:#f92672">%&lt;/span>edi
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0x0000000000400a45&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">245&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> callq &lt;span style="color:#ae81ff">0x4006f0&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>exit&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>plt&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简而言之，关键在以下几句：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040098d&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">61&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e4&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>rax &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601078&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable2_p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x0000000000400994&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">68&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#ae81ff">0x2006e6&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rip),&lt;span style="color:#f92672">%&lt;/span>edx &lt;span style="color:#960050;background-color:#1e0010">#&lt;/span> &lt;span style="color:#ae81ff">0x601080&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>variable1&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040099a&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">74&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov (&lt;span style="color:#f92672">%&lt;/span>rax),&lt;span style="color:#f92672">%&lt;/span>ecx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x000000000040099c&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">76&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> mov &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x77359400&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009a1&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">81&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> nopl &lt;span style="color:#ae81ff">0x0&lt;/span>(&lt;span style="color:#f92672">%&lt;/span>rax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> cmp &lt;span style="color:#f92672">%&lt;/span>ecx,&lt;span style="color:#f92672">%&lt;/span>edx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009aa&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">90&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> adc &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x0&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>ebx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009ad&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">93&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> sub &lt;span style="color:#960050;background-color:#1e0010">$&lt;/span>&lt;span style="color:#ae81ff">0x1&lt;/span>,&lt;span style="color:#f92672">%&lt;/span>eax
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">0x00000000004009b0&lt;/span> &lt;span style="color:#f92672">&amp;lt;+&lt;/span>&lt;span style="color:#ae81ff">96&lt;/span>&lt;span style="color:#f92672">&amp;gt;:&lt;/span> jne &lt;span style="color:#ae81ff">0x4009a8&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>reader(&lt;span style="color:#66d9ef">void&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">88&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们可以看出，循环体在+88～+96行，而对variable1与variable2的取值都放在了循环以外。&lt;/p>
&lt;blockquote>
&lt;p>注：&lt;br>
adc是带进位加法，adc $0x0, %ebx =&amp;gt; %ebx = $0x0 + %ebx + CF &lt;br>
cmp的结果正是放在CF（大于表示为溢出），ZF（相等表示为0），PF（小于表示为-1,则低8位全为1,故有偶数个1）&lt;/p>&lt;/blockquote>
&lt;p>正是这个“小意外”，导致了我们的结果要不是100%正确，要不是100%错误。&lt;/p>
&lt;h4 id="使用volitile">使用volitile（？） &lt;a href="#%e4%bd%bf%e7%94%a8volitile" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>让我们修改一下代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> variable1 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">volatile&lt;/span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2_p &lt;span style="color:#f92672">=&lt;/span> NULL;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define ITERATIONS 500000000LL &lt;/span>&lt;span style="color:#75715e">// 调小一下数据规模，因为volatile太慢了_(:з」∠)_
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我得出的来的结果是：&lt;/p>
&lt;pre tabindex="0">&lt;code>0 failures (0.0 percent of the time) in 9.6 seconds
&lt;/code>&lt;/pre>&lt;p>而作者得出的结果是：
（时间上的差异不计，因为我们的数据规模不一样，我实验的次数要多一些。&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
12462711 failures (24.9 percent of the time) in 3.7 seconds
&lt;/code>&lt;/pre>&lt;p>从作者的结果来看，看起来效果好了很多，虽然慢了30多倍，但是结果并不是全对全错了。&lt;/p>
&lt;p>而从我的结果来看，volatile看似神丹妙药，解决了所有的问题。(both g++ and clang++)&lt;/p>
&lt;p>&lt;strong>这是为什么呢?&lt;/strong>&lt;/p>
&lt;p>其原因在于体系结构的差异。volatile只能保证如下两点：&lt;/p>
&lt;ul>
&lt;li>volatile变量的访问不会优化成寄存器访问，而是每次都去访问“内存”（这个引号一会再解释）&lt;/li>
&lt;li>volatile变量间的访问顺序不会被编译器乱序&lt;/li>
&lt;/ul>
&lt;p>而其他的一切，volatile和编译器都不会给出任何保证。&lt;/p>
&lt;p>例如，不同的CPU都有其内部的私有Cache，CPU的内存访问，如果命中了Cache，则不会真正的访问内存。但由于其私有Cache对于其它的CPU是不可见的，使用volatile就埋下的Bug的种子。&lt;/p>
&lt;p>虽然在我们的实验中，程序运行的很好，没有出现Bug。但是，一是由于多线程的Bug都是subtle和delicate的，我不能保证在一个需要7x24工作的服务器程序中，它不会出现任何Bug；二是至少我们的代码是** not portable **的，如果有一天，我们从x86-64平台切换到了&lt;code>PowerPC&lt;/code>？或是&lt;code>IA64&lt;/code>？我们不能保证在这些体系结构上，编译器和CPU能为我们提供同样的保障。&lt;/p>
&lt;p>于是有人高声疾呼： volatile不能用来做为多线程的同步机制！&lt;/p>
&lt;blockquote>
&lt;p>补充于20240317：在一台老旧的安卓手机上重复了实验，volatile确实无法提供相关的保障&lt;/p>&lt;/blockquote>
&lt;pre tabindex="0">&lt;code>~/tmp $ clang++ -O2 a.cc &amp;amp;&amp;amp; ./a.out
99880586 failures (49.9 percent of the time) in 3.0 seconds
&lt;/code>&lt;/pre>&lt;h4 id="小心cpu的行为">小心CPU的行为 &lt;a href="#%e5%b0%8f%e5%bf%83cpu%e7%9a%84%e8%a1%8c%e4%b8%ba" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>在先前的实验中，尽管程序的表现与预期一致，但我们无法确保CPU将始终按顺序执行代码。实际上，CPU可能会对操作顺序进行优化，例如，将var1++和var2++的执行顺序调换，这在当前主流的CPU中是常见的做法。&lt;/p>
&lt;p>值得注意的是，由于乱序执行会导致功耗增加，某些处理器如ARM和Intel Atom已经取消了这一机制。然而，我们无法预知未来代码可能会在哪种硬件架构上运行，例如ARM集群，这需要我们保持警惕。&lt;/p>
&lt;h4 id="避免使用锁">避免使用锁 &lt;a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h4>&lt;p>通常情况下，通过引入互斥锁（mutex）似乎能够解决并发问题。然而，根据作者的测试，引入互斥锁可能会导致程序速度降低至原来的1/130，而自旋锁（spinlock）也可能使得速度降低至原来的1/4。&lt;/p>
&lt;p>因此，我们应该暂缓，仔细考虑作者接下来的建议。&lt;/p>
&lt;h3 id="内存屏障的应用">内存屏障的应用 &lt;a href="#%e5%86%85%e5%ad%98%e5%b1%8f%e9%9a%9c%e7%9a%84%e5%ba%94%e7%94%a8" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>在多CPU环境中，处理器往往独立运行，不会协调彼此的操作。&lt;/p>
&lt;p>目前，我们面临两个并不理想的解决方案：一是将所有线程限制在单个CPU上运行，二是通过引入重量级锁来同步操作。这些方法都不尽人意，且效率低下。&lt;/p>
&lt;p>实际上，我们需要做的是，通过内存屏障技术，暂时阻止编译器或CPU对程序中的数据读写操作进行重排序。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (;;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> variable1 &lt;span style="color:#f92672">=&lt;/span> variable1 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> barrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>variable2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2 &lt;span style="color:#f92672">+&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样我们保证了，在var1++必然早于var2++。var2++后面也可以加一道barrier，只不过在我们的场景下，提供这种保证是不必须的。&lt;/p>
&lt;p>作者又做了一次试验。&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
260 failures (0.0 percent of the time) in 0.9 seconds
&lt;/code>&lt;/pre>&lt;p>这次且错误减少了许多。&lt;/p>
&lt;p>我们再把读线程写加上memory barrier.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">for&lt;/span> (i&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> ITERATIONS; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v2 &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#f92672">*&lt;/span>variable2;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> barrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> v1 &lt;span style="color:#f92672">=&lt;/span> variable1;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (v2 &lt;span style="color:#f92672">&amp;gt;&lt;/span> v1) failureCount&lt;span style="color:#f92672">++&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看看结果：&lt;/p>
&lt;pre tabindex="0">&lt;code>fish ) ./a.out
0 failures (0.0 percent of the time) in 4.2 seconds
&lt;/code>&lt;/pre>&lt;p>程序表现出了正确的结果。&lt;/p>
&lt;p>我们可以看出，如果你对线程A的读写顺序做出要求，必然的，你也要对线程B的顺序做要求，以此类推，线程C，线程D……&lt;/p>
&lt;p>所以，&lt;strong>Memory barriers always come in pairs, or triplets or more.&lt;/strong>&lt;/p>
&lt;p>同样的，线程锁也是这样的，自己锁自己总不是一种愉快的体验（笑&lt;/p>
&lt;h3 id="cpu的乱序执行">CPU的乱序执行 &lt;a href="#cpu%e7%9a%84%e4%b9%b1%e5%ba%8f%e6%89%a7%e8%a1%8c" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们可以看到PowerPC有三种内存屏障，而DEC Alpha平台有更多。这意味着，CPU使用更激进的策略来重排指令，而强制限制其重排的代价是非常高的。&lt;/p>
&lt;p>而x86平台则非常守序，作者猜测其原因是由于早期x86的指令技术并非完善，而在那时内存与CPU的速度不像现在这样悬殊，所以x86使用了&lt;code>strongly ordered memory&lt;/code>而非像上面几款CPU一样的采用过多的指令重排序。如今，由于x86背上了向前兼容性的包袱，看似我们的&amp;quot;好日子&amp;quot;一直不会结束。&lt;/p>
&lt;p>x86-64，做为x86的64位升级版，同样没有实现&lt;code>weakly ordered&lt;/code>，或者说，保留了实现&lt;code>weakly ordered&lt;/code>的权利。而&lt;code>IA64&lt;/code>平台，如&lt;code>Itanium&lt;/code>，则实现了&lt;code>weakly ordered&lt;/code>。&lt;/p>
&lt;p>作者猜测x86_64之所以保守，是为了与IA64平台对抗。x86_64的对于x86良好的兼容性可以让程序员多活几年，所以x86_64在市场的表现更好。&lt;/p>
&lt;p>作者还表示，而苹果放弃IA64平台转投x86-64多少有一些可惜，因为苹果并没有移植性问题，PowerPC已经逐渐衰落，为什么不试试IA64呢。&lt;/p>
&lt;p>实际上，根据Wikipedia，现在支持IA64的操作系统非常少，只有WinNT Family，Red Hat Linux，Debian/Gentoo/Suse以及其它。而从Windows Server 2008 R2之后，Microsoft也表示不再支持Itanium。所以从现在看来，IA64平台相对x86/x64来说，是失败的。&lt;/p>
&lt;h3 id="双重检查锁">双重检查锁 &lt;a href="#%e5%8f%8c%e9%87%8d%e6%a3%80%e6%9f%a5%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>让我们看一下如下的Obj-C代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-objc" data-lang="objc">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是非常经典的一种DCLP(Double Checked Lock Pattern)的实现。&lt;/p>
&lt;p>这个看起来不错，但是你已经知道这并不靠谱了。当我们初始化我们的共享单例，先要再修改类内的指针，使其指向一块声明好的内存，再初始化一个sharedObject的instance。&lt;/p>
&lt;p>不过，你是知道的，CPU和编译器会把一切都搞砸，它们会以任意的顺序执行我们的命令，同时处理器之间互相不通气，于是就会出现如下的情况：&lt;/p>
&lt;p>线程A为指针声明了一段空间，但是还没来及初始化这个instance，线程A就被挂起了。&lt;/p>
&lt;p>之后线程B接管一切，发现指针有值，结果因为访问了野指针导致程序挂掉。&lt;/p>
&lt;p>不过根据上面的文章，你们应该知道怎么处理这个问题了 —— 试试内存屏障！&lt;/p>
&lt;p>p.s. 如果大家对obj-c不熟悉的话，可以看我另外一篇文章。那篇文章是关于Scott Meyers大神写的一篇论文，专门用来讨论DCLP问题的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-objc" data-lang="objc">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">id&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而在《C++ and the Perils of Double-Checked Locking》一文中，Scott Meyers和Andrei Alexandrescu给出的解决方案如下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>instance () {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Singleton&lt;span style="color:#f92672">*&lt;/span> tmp &lt;span style="color:#f92672">=&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// insert memory barrier
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// clear the cache to flush ``pInstance``
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevents &amp;#34;downwards migration&amp;#34; of Singleton’s construction (by another thread);
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">if&lt;/span> (tmp &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Lock lock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (tmp &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// insert memory barrier
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevent optimistic that eliminate the temporary variable ``tmp``
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// prevents &amp;#34;upwards migration&amp;#34; of pInstance’s initialization
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pInstance &lt;span style="color:#f92672">=&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> tmp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>两种解决方案的memory barrier插入的位置不同。但是都不能说是错的。因为一个是传static instance，一个是传pointer。&lt;/p>
&lt;p>其实还有更“暴力”的方法。&lt;/p>
&lt;p>直接来一把大锁，哐当把整个函数锁起来，并且在每一个线程内保留一个&lt;strong>本线程专属&lt;/strong>指向单例的指针（做cache）。这样N个线程只需要调用这个函数N次，线程竞争也相对少很多。并且根据Linux下的futex技术，无竞争下的锁相对节省了不少资源。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>Singleton&lt;span style="color:#f92672">*&lt;/span> Singleton&lt;span style="color:#f92672">::&lt;/span>instance() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Lock lock;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span>(pInstance &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pInstance &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span> Singleton;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pInstance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="我们真的需要这么做吗">我们真的需要这么做吗 &lt;a href="#%e6%88%91%e4%bb%ac%e7%9c%9f%e7%9a%84%e9%9c%80%e8%a6%81%e8%bf%99%e4%b9%88%e5%81%9a%e5%90%97" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>上面的obj-c代码中，保证双重检查锁正确的，其实是第二个内存屏障。但是，在那里，我们需要的其实是一个&amp;quot;data dependency barrier&amp;quot;。&lt;/p>
&lt;p>Linux内核中给出很多经过精心优化的内存屏障，我们在这里可以使用。不过，要在使用的时候写好注释，一是为了未来的验证，二是为了记录自己当时的思路。&lt;/p>
&lt;p>毕竟多线程的操作要小心再小心，我们需要充足的理由，更多的小心来应对。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-obj-c" data-lang="obj-c">&lt;span style="display:flex;">&lt;span>+ &lt;span style="color:#a6e22e">getSharedObject&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> &lt;span style="color:#66d9ef">id&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">!&lt;/span> sharedObject) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">id&lt;/span> temp &lt;span style="color:#f92672">=&lt;/span> [[self alloc] init];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OSMemoryBarrier();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sharedObject &lt;span style="color:#f92672">=&lt;/span> temp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UNLOCK;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">/* data dependency memory barrier here */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sharedObject;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="一切都结束了吗">一切都结束了吗？ &lt;a href="#%e4%b8%80%e5%88%87%e9%83%bd%e7%bb%93%e6%9d%9f%e4%ba%86%e5%90%97" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>是的。不过让我们总结一下吧。&lt;/p>
&lt;p>&lt;img src="https://github.com/Wizmann/assets/raw/master/wizmann-tk-pic/barrier_tank.png" alt="Mutex Tank">&lt;/p>
&lt;ul>
&lt;li>处理器和编译器并不能充分保证代码执行的顺序，它们会把你的代码到处移动。所以&lt;strong>Be warned and wary!&lt;/strong>&lt;/li>
&lt;li>多线程的错误是非常subtle和delicate的，所以我们很难设计测试用例&lt;/li>
&lt;li>因此，别指责QA了，他们也不是故意的。RD要对自己的代码负责&lt;/li>
&lt;li>锁很安全，但是也很重&lt;/li>
&lt;li>内存屏障是一种更快的，不阻塞的，不会死锁的一种锁的替代物。它们总要花费更多的心思，并且也不是到处可用的银弹。但是它确实很快，有更好的伸缩性。&lt;/li>
&lt;li>内存屏障往往是成对出现的。了解第二个内存屏障要出现在哪里，有助于你理解你的代码，即使你所使用的体系结构不需要第二个内存屏障。&lt;/li>
&lt;/ul>
&lt;h3 id="扩展阅读">扩展阅读 &lt;a href="#%e6%89%a9%e5%b1%95%e9%98%85%e8%af%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;a href="https://www.kernel.org/doc/Documentation/memory-barriers.txt">LINUX KERNEL MEMORY BARRIERS&lt;/a>&lt;/p>
&lt;p>&lt;a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.17.8112">Memory Consistency and Event Ordering in Scalable Shared-Memory Multiprocessors&lt;/a>&lt;/p></description></item><item><title>alloca vs placement new</title><link>https://wizmann.top/posts/alloca-vs-placement-new/</link><pubDate>Mon, 07 Apr 2014 21:08:59 +0000</pubDate><guid>https://wizmann.top/posts/alloca-vs-placement-new/</guid><description>&lt;h2 id="what">WHAT?! &lt;a href="#what" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>For most time, we use &lt;code>malloc&lt;/code> or &lt;code>new&lt;/code> for memory allocation, which will get it on &lt;em>heap&lt;/em>.&lt;/p>
&lt;p>However, access memory on &lt;em>heap&lt;/em> is not as effective as the memory on &lt;em>stack&lt;/em>, because the heap is &amp;ldquo;free-floating region of memory&amp;rdquo;. To the contrary, memory on &lt;em>stack&lt;/em> is managed by CPU automacitally and tightly. As a result, the further of the &lt;em>stack&lt;/em> compared to &lt;em>heap&lt;/em> is that we can have a faster read/write speed due to the fact that &lt;em>stack&lt;/em> memory is more likely to optimized by &lt;strong>CPU cache&lt;/strong>, in addition, it only uses a single instruction to allocate or deallocate &lt;em>stack&lt;/em> memory. Just like this.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>sub esp, &lt;span style="color:#ae81ff">0x10&lt;/span>; &lt;span style="color:#f92672">=&amp;gt;&lt;/span> allocate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>add esp, &lt;span style="color:#ae81ff">0x10&lt;/span>; &lt;span style="color:#f92672">=&amp;gt;&lt;/span> deallocate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="alloca">alloca &lt;a href="#alloca" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>The &lt;code>alloca()&lt;/code> function allocates memory from the &lt;em>stack&lt;/em>.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)alloca(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> size);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It&amp;rsquo;s quite the same as the &lt;code>malloc&lt;/code> way. But we shouldn&amp;rsquo;t free the memory allocated on the &lt;em>stack&lt;/em>; these memory will be automatically deallocated when you leave the function(&lt;strong>not the code block&lt;/strong>).&lt;/p>
&lt;h2 id="placement-new">placement new &lt;a href="#placement-new" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>The placement new is one of the overloads of the &lt;code>new&lt;/code> functions; this new syntax can do something as the &lt;code>alloca()&lt;/code> function.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">char&lt;/span> buffer[&lt;span style="color:#ae81ff">1024&lt;/span>];
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">new&lt;/span>(buffer) &lt;span style="color:#66d9ef">int&lt;/span>[&lt;span style="color:#ae81ff">64&lt;/span>];
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>The placement new can be also used in some other scenarios but won&amp;rsquo;t be mentioned here.&lt;/p>
&lt;h2 id="variable-length-array">variable-length array &lt;a href="#variable-length-array" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>C90 and C++ both support the variable-length array which will be allocated on &lt;em>stack&lt;/em>, and it will be deallocted whhen you leave the &lt;strong>clode block&lt;/strong>, such as &amp;ldquo;if&amp;rdquo;, &amp;ldquo;while&amp;rdquo;, etc.&lt;/p>
&lt;p>This is much simplified, but be ware if you use both variable-length array and &lt;code>alloca()&lt;/code> in the same function, the deallocation of the array will also free anything more recenly allocated by alloca.&lt;/p>
&lt;h2 id="defects">Defects &lt;a href="#defects" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>&lt;em>Stack&lt;/em> has its limitation. If the allocation on &lt;em>stack&lt;/em> causes &lt;strong>stack overflow&lt;/strong> error, then the behavior of the program is undefined.&lt;/p>
&lt;p>Further, the variable-length array and &lt;code>alloca()&lt;/code> are not included in &lt;em>ANSI-C&lt;/em> standard and therefore could limit portability.&lt;/p>
&lt;p>The Google C++ style guide encourage developers to use &lt;code>scoped_ptr&lt;/code> or &lt;code>scopted_array&lt;/code> instead of variable-length array and &lt;code>alloca()&lt;/code>.&lt;/p>
&lt;h2 id="some-experiment">Some experiment &lt;a href="#some-experiment" class="anchor">🔗&lt;/a>&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// compile with: g++ -std=c++0x -O2 -Wall -g -o &amp;#34;foo.cc&amp;#34; &amp;#34;foo&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdio&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstdlib&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;cstring&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;iostream&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;algorithm&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">using&lt;/span> &lt;span style="color:#66d9ef">namespace&lt;/span> std;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define print(x) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; endl
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#define input(x) cin &amp;gt;&amp;gt; x
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#if defined(__i386__)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> __inline__ &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">rdtsc&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __asm__ &lt;span style="color:#66d9ef">volatile&lt;/span> (&lt;span style="color:#e6db74">&amp;#34;.byte 0x0f, 0x31&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;=A&amp;#34;&lt;/span> (x));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> x;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#elif defined(__x86_64__)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">static&lt;/span> __inline__ &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#a6e22e">rdtsc&lt;/span>(&lt;span style="color:#66d9ef">void&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> hi, lo;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __asm__ __volatile__ (&lt;span style="color:#e6db74">&amp;#34;rdtsc&amp;#34;&lt;/span> &lt;span style="color:#f92672">:&lt;/span> &lt;span style="color:#e6db74">&amp;#34;=a&amp;#34;&lt;/span>(lo), &lt;span style="color:#e6db74">&amp;#34;=d&amp;#34;&lt;/span>(hi));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ( (&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)lo)&lt;span style="color:#f92672">|&lt;/span>( ((&lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span>)hi)&lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">32&lt;/span> );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//#define MEMORY_ON_HEAP
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">//#define MEMORY_ON_STACK
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">const&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> SIZE &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">102400&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#f92672">*&lt;/span>array[SIZE] &lt;span style="color:#f92672">=&lt;/span> {NULL};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> start &lt;span style="color:#f92672">=&lt;/span> rdtsc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#ifdef MEMORY_ON_HEAP &lt;/span>&lt;span style="color:#75715e">// RDSTC: 20586280
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> SIZE; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> array[i] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)malloc(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>array[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#ifdef MEMORY_ON_STACK &lt;/span>&lt;span style="color:#75715e">// RDSTC: 3660502
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">for&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; i &lt;span style="color:#f92672">&amp;lt;&lt;/span> SIZE; i&lt;span style="color:#f92672">++&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> array[i] &lt;span style="color:#f92672">=&lt;/span> (&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">*&lt;/span>)alloca(&lt;span style="color:#66d9ef">sizeof&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">*&lt;/span>array[i] &lt;span style="color:#f92672">=&lt;/span> i;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">#endif
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">unsigned&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> &lt;span style="color:#66d9ef">long&lt;/span> end &lt;span style="color:#f92672">=&lt;/span> rdtsc();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(end &lt;span style="color:#f92672">-&lt;/span> start);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You can use &lt;code>info register esp&lt;/code> in gdb to inspect the &lt;em>stack&lt;/em> pointer before and after you call the allocation function or declare a variable-length array.&lt;/p></description></item><item><title>使用新类型创建更人性化的代码</title><link>https://wizmann.top/posts/humanity-code-with-new-classes/</link><pubDate>Mon, 09 Dec 2013 15:01:00 +0000</pubDate><guid>https://wizmann.top/posts/humanity-code-with-new-classes/</guid><description>&lt;h2 id="啥">啥？ &lt;a href="#%e5%95%a5" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。&lt;/p>
&lt;p>关键词：&lt;/p>
&lt;ul>
&lt;li>RAII&lt;/li>
&lt;li>智能指针&lt;/li>
&lt;li>接口友好&lt;/li>
&lt;li>模板&lt;/li>
&lt;li>模板特化&lt;/li>
&lt;li>依赖编译器的缺省行为&lt;/li>
&lt;/ul>
&lt;p>对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。&lt;/p>
&lt;h2 id="一个友好的互斥锁">一个友好的互斥锁 &lt;a href="#%e4%b8%80%e4%b8%aa%e5%8f%8b%e5%a5%bd%e7%9a%84%e4%ba%92%e6%96%a5%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h2>&lt;h3 id="互斥锁的定义">互斥锁的定义 &lt;a href="#%e4%ba%92%e6%96%a5%e9%94%81%e7%9a%84%e5%ae%9a%e4%b9%89" class="anchor">🔗&lt;/a>&lt;/h3>&lt;blockquote>
&lt;p>互斥锁（英语：英语：Mutual exclusion，缩写 Mutex）是一种用于多线程编程中，防止两条线程同时对同一公共资源（比如全局变量）进行读写的机制。该目的通过将代码切片成一个一个的临界区域（critical section）达成。临界区域指的是一块对公共资源进行访问的代码，并非一种机制或是算法。一个程序、进程、线程可以拥有多个临界区域，但是并不一定会应用互斥锁。&lt;/p>&lt;/blockquote>
&lt;h3 id="如何使用互斥锁">如何使用互斥锁 &lt;a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8%e4%ba%92%e6%96%a5%e9%94%81" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>这里只做最简单的示范。具体的使用方法和原理不在本文的讨论范围之内。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">MyIntArray&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 一个假想的数组类型，支持多线程下的Append Only操作。
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MyIntArray()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _vec.clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_init(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_mutex, NULL);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">push_back&lt;/span>(&lt;span style="color:#66d9ef">int&lt;/span> v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_lock(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// 在这里做一些工作, 例如打Log，抽风等
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> vec.push_back(v);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_unlock(&lt;span style="color:#f92672">&amp;amp;&lt;/span>_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_t _mutex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> vector&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> _vec;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码不需要多解释，通过一个锁来保证多线程push_back函数的可重入性。&lt;/p>
&lt;p>但是我们需要对代码的安全性做一些评估。&lt;/p>
&lt;p>例如，我们如何处理，函数在unlock mutex之前异常结束的情况。&lt;/p>
&lt;p>这并不是不可能的，例如&lt;code>vec.push_back(v)&lt;/code>抛出了一个&lt;code>std::bad_alloc&lt;/code>异常。或者在这之前因为一些原因，函数做出了&lt;code>return -1&lt;/code>的行为。&lt;/p>
&lt;p>也许我们在逻辑上可以接受这些错误（比如做出一些失败处理）。但是，对于因为我们没有unlock我们的同步锁，于是死锁就产生了。&lt;/p>
&lt;p>这是一个极大的隐患，死锁的危害我也不用多说。&lt;/p>
&lt;p>那么我们有什么方法可以避免这种局面。&lt;/p>
&lt;h3 id="一个新的mutex类型">一个新的Mutex类型 &lt;a href="#%e4%b8%80%e4%b8%aa%e6%96%b0%e7%9a%84mutex%e7%b1%bb%e5%9e%8b" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>我们可以使用&lt;strong>析构函数&lt;/strong>的特性来编写如下的类。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#include&lt;/span> &lt;span style="color:#75715e">&amp;lt;pthread.h&amp;gt;&lt;/span>&lt;span style="color:#75715e">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Mutex&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Mutex(&lt;span style="color:#66d9ef">explicit&lt;/span> pthread_mutex_t&lt;span style="color:#f92672">*&lt;/span> i_mutex_ptr)&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _mutex(i_mutex_ptr){}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">lock&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_lock(_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>Mutex()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pthread_mutex_unlock(_mutex);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Mutex(); &lt;span style="color:#75715e">// disable the empty construct funtion
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> pthread_mutex_t &lt;span style="color:#f92672">*&lt;/span>_mutex;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>OK，如果我们使用这个类做为同步锁的管理类，那么，如果函数中出现了非预期的情况而跳出的时候。&lt;code>Mutex&lt;/code>类就会自动调用自身的析构函数来解锁。避免了死锁的发生。&lt;/p>
&lt;h3 id="总结">总结 &lt;a href="#%e6%80%bb%e7%bb%93" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>&lt;code>pthread_mutex_t&lt;/code>是一个类型，但是我们在这个类型之上又新建了一个新的类型来进行资源管理。以此来获得更人性化，更安全以及更可读的代码。&lt;/p>
&lt;h3 id="拓展阅读">拓展阅读 &lt;a href="#%e6%8b%93%e5%b1%95%e9%98%85%e8%af%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ul>
&lt;li>&lt;a href="http://www.searchtb.com/2011/01/pthreads-mutex-vs-pthread-spinlock.html">Pthreads mutex vs Pthreads spinlock&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>对于mutex和spinlock有一个详细的介绍，并且对比了这两种锁的性能。&lt;/p>
&lt;ul>
&lt;li>Effective C++ 条款14&lt;/li>
&lt;/ul>
&lt;p>以上的例子来源于此，并且做了一些简化。&lt;/p>
&lt;h2 id="句柄类">句柄类 &lt;a href="#%e5%8f%a5%e6%9f%84%e7%b1%bb" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>我们都知道，由于C++没有自动内存回收机制，所以内存操作都需要代码编写者手动完成。&lt;/p>
&lt;p>这就造成了潜在的内存泄露问题 ———— 不小心手贱怎么办？&lt;/p>
&lt;p>于是我们就引入了句柄类，一种使用&lt;strong>引用计数法&lt;/strong>来管理内存的方法。&lt;/p>
&lt;h3 id="一个泛型句柄类">一个泛型句柄类 &lt;a href="#%e4%b8%80%e4%b8%aa%e6%b3%9b%e5%9e%8b%e5%8f%a5%e6%9f%84%e7%b1%bb" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>代码来自《C++ Primer 第4版》，有小小的格式上的改动。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">/* generic handle class: Provides pointerlike behavior. Although
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">access through
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* an unbound Handle is checked and throws a runtime_error exception.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* The object to which the Handle points is deleted when the last
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">Handle goes away.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Users should allocate new objects of type T and bind them to a
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">Handle.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">* Once an object is bound to a Handle,, the user must not delete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">that object.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">*/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">T&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Handle&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// unbound handle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Handle(T &lt;span style="color:#f92672">*&lt;/span>p &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>)&lt;span style="color:#f92672">:&lt;/span> ptr(p), use(&lt;span style="color:#66d9ef">new&lt;/span> size_t(&lt;span style="color:#ae81ff">1&lt;/span>)) { }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// overloaded operators to support pointer behavior
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">*&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">*&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">const&lt;/span> T&lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">-&amp;gt;&lt;/span>() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// copy control: normal pointer behavior, but last Handle deletes the object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Handle(&lt;span style="color:#66d9ef">const&lt;/span> Handle&lt;span style="color:#f92672">&amp;amp;&lt;/span> h)&lt;span style="color:#f92672">:&lt;/span> ptr(h.ptr), use(h.use) { &lt;span style="color:#f92672">++*&lt;/span>use; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Handle&lt;span style="color:#f92672">&amp;amp;&lt;/span> &lt;span style="color:#66d9ef">operator&lt;/span>&lt;span style="color:#f92672">=&lt;/span>(&lt;span style="color:#66d9ef">const&lt;/span> Handle&lt;span style="color:#f92672">&amp;amp;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">~&lt;/span>Handle() { rem_ref(); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> T&lt;span style="color:#f92672">*&lt;/span> ptr;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// shared object
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> size_t &lt;span style="color:#f92672">*&lt;/span>use;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// count of how many Handle spointto *ptr
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">rem_ref&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (&lt;span style="color:#f92672">--*&lt;/span>use &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>) { &lt;span style="color:#66d9ef">delete&lt;/span> ptr; &lt;span style="color:#66d9ef">delete&lt;/span> use; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们从代码中可以看到，Handle类中使用了&lt;code>size_t *use&lt;/code>用来对于对象进行引用计数。如果计数为0，则Handle类会删除自身。也许我们会忘记释放内存，但是编译器会帮你管理好你的对象的。&lt;/p>
&lt;h3 id="句柄类的另一个优点">句柄类的另一个优点 &lt;a href="#%e5%8f%a5%e6%9f%84%e7%b1%bb%e7%9a%84%e5%8f%a6%e4%b8%80%e4%b8%aa%e4%bc%98%e7%82%b9" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>句柄类的另一个优点是可以降低文件间的编译依存关系。&lt;/p>
&lt;p>句柄类可以将接口从实现中分离，从而分离编译依赖。&lt;/p>
&lt;p>例如，我们有一个&lt;code>Person&lt;/code>类，又声明了&lt;code>PersonImpl&lt;/code>句柄类。&lt;/p>
&lt;p>则我们如果修改了&lt;code>Person&lt;/code>类的实现部分，并且保持接口部分不变。则我们只需要重新编译含入&lt;code>Person&lt;/code>类的文件。含入&lt;code>PersonImpl&lt;/code>类的文件不需要重新编译。&lt;/p>
&lt;h3 id="shared_ptr">shared_ptr &lt;a href="#shared_ptr" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>shared_ptr是boost中引入的新类型，原理和句柄类类似，但是加入了如下特性。&lt;/p>
&lt;ul>
&lt;li>线程安全&lt;/li>
&lt;li>支持自定义析构操作（删除器）&lt;/li>
&lt;li>有现成的库为啥不用&lt;/li>
&lt;/ul>
&lt;p>在《Effective C++》一书中，作者对于&lt;code>shared_ptr&lt;/code>大为推崇，用了很大篇幅来介绍它的用法，在这里就不赘述了。&lt;/p>
&lt;h3 id="潜在问题">潜在问题 &lt;a href="#%e6%bd%9c%e5%9c%a8%e9%97%ae%e9%a2%98" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>有失有得，我们在一定程度上提升了内存安全性的同时，我们也必须付出一定的代价。&lt;/p>
&lt;ul>
&lt;li>内存性能问题&lt;/li>
&lt;/ul>
&lt;p>我们的一个句柄类或智能指针中，不仅有我们的对象指针，而且还保存着引用计数。如果我们处于内存敏感的场景，那么我们必须认真的考虑收益和代价。&lt;/p>
&lt;ul>
&lt;li>计算性能问题&lt;/li>
&lt;/ul>
&lt;p>如果我们的句柄类需要线程安全性，那么我们也必须要付出相应的时间上的代价。&lt;/p>
&lt;h3 id="拓展阅读-1">拓展阅读 &lt;a href="#%e6%8b%93%e5%b1%95%e9%98%85%e8%af%bb-1" class="anchor">🔗&lt;/a>&lt;/h3>&lt;ul>
&lt;li>
&lt;p>《Effective C++》第三章 资源管理&lt;/p>
&lt;/li>
&lt;li>
&lt;p>《C++ Primer第四版》 16.5 一个泛型句柄类&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="防止接口误用">防止接口误用 &lt;a href="#%e9%98%b2%e6%ad%a2%e6%8e%a5%e5%8f%a3%e8%af%af%e7%94%a8" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>Python有一个非常好的特性（也许别的语言也有）。例如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">pass_date&lt;/span>(year, month, day):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">pass&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pass_date(year&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">1234&lt;/span>, month&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">5&lt;/span>, day&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">6&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在函数的调用中，可以明确形参与实参的对应关系。这就可以从很大程度上解决了接口误用的问题。&lt;/p>
&lt;p>而在C++中，我们可以使用新建类型来解决这个问题。&lt;/p>
&lt;p>还以&lt;code>pass_date&lt;/code>这个函数为例。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Year&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> year;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Month&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> month;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Day&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">explicit&lt;/span> &lt;span style="color:#66d9ef">int&lt;/span> day;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Date&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">void&lt;/span> pass_date(Year year, Month month, Day day) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// pass
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">void&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Date date;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> date.psss_date(Year(&lt;span style="color:#ae81ff">1234&lt;/span>), Month(&lt;span style="color:#ae81ff">5&lt;/span>), Day(&lt;span style="color:#ae81ff">6&lt;/span>));
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="偏特化类中的成员函数">偏特化类中的成员函数 &lt;a href="#%e5%81%8f%e7%89%b9%e5%8c%96%e7%b1%bb%e4%b8%ad%e7%9a%84%e6%88%90%e5%91%98%e5%87%bd%e6%95%b0" class="anchor">🔗&lt;/a>&lt;/h2>&lt;p>这个方法来源于stackoverflow上的一个&lt;a href="http://stackoverflow.com/questions/20147821/c-how-to-partial-specialization-a-template-function-in-a-template-class">问题&lt;/a>。&lt;/p>
&lt;p>我比较推崇下面这个答案，虽然它不是被顶的最多的那个。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-cpp" data-lang="cpp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Group, &lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ApplyNorm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> Group &lt;span style="color:#a6e22e">apply&lt;/span>(Group x, Group y, Group z)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> { &lt;span style="color:#66d9ef">return&lt;/span> pow( pow(x, p) &lt;span style="color:#f92672">+&lt;/span> pow(y, p) &lt;span style="color:#f92672">+&lt;/span> pow(z, p), (&lt;span style="color:#ae81ff">1.0&lt;/span> &lt;span style="color:#f92672">/&lt;/span> p) ); }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// Here specialize for 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">template&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Group&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">ApplyNorm&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>Group, &lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">static&lt;/span> Group &lt;span style="color:#a6e22e">apply&lt;/span>(Group x, Group y, Group z)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;spec: &amp;#34;&lt;/span> &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sqrt( x &lt;span style="color:#f92672">*&lt;/span> x &lt;span style="color:#f92672">+&lt;/span> y &lt;span style="color:#f92672">*&lt;/span> y &lt;span style="color:#f92672">+&lt;/span> z &lt;span style="color:#f92672">*&lt;/span> z );
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Group&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">struct&lt;/span> &lt;span style="color:#a6e22e">Vector3D&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Group x, y, z;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Vector3D(Group x, Group y, Group z) &lt;span style="color:#f92672">:&lt;/span> x(x), y(y), z(z) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">&amp;gt;&lt;/span> Group Norm() &lt;span style="color:#66d9ef">const&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">typename&lt;/span> Group&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">template&lt;/span>&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">int&lt;/span> p&lt;span style="color:#f92672">&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Group Vector3D&lt;span style="color:#f92672">&amp;lt;&lt;/span>Group&lt;span style="color:#f92672">&amp;gt;::&lt;/span>Norm() &lt;span style="color:#66d9ef">const&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> ApplyNorm&lt;span style="color:#f92672">&amp;lt;&lt;/span>Group, p&lt;span style="color:#f92672">&amp;gt;::&lt;/span>apply(x, y, z); &lt;span style="color:#75715e">// use the helper...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">int&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// your code goes here
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> Vector3D&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#66d9ef">double&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> v(&lt;span style="color:#ae81ff">1.&lt;/span>, &lt;span style="color:#ae81ff">2.&lt;/span>, &lt;span style="color:#ae81ff">3.&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v.Norm&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> std&lt;span style="color:#f92672">::&lt;/span>cout &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> v.Norm&lt;span style="color:#f92672">&amp;lt;&lt;/span>&lt;span style="color:#ae81ff">2&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span>() &lt;span style="color:#f92672">&amp;lt;&amp;lt;&lt;/span> std&lt;span style="color:#f92672">::&lt;/span>endl;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它使用一个新类&lt;code>ApplyNorm&lt;/code>实现了类成员函数的偏特化。&lt;/p>
&lt;h3 id="拓展阅读-2">拓展阅读 &lt;a href="#%e6%8b%93%e5%b1%95%e9%98%85%e8%af%bb-2" class="anchor">🔗&lt;/a>&lt;/h3>&lt;p>《C++ Primer第4版》 16.6 模板特化&lt;/p></description></item></channel></rss>