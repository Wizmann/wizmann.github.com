<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cpp on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/cpp/</link><description>Recent content in Cpp on Maerlyn's Rainbow</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Tue, 21 Jan 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/cpp/index.xml" rel="self" type="application/rss+xml"/><item><title>动手实现智能指针 （上篇） - C++ for the Antiquated（之四）</title><link>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</link><pubDate>Tue, 21 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-smart-ptrs-cpp-for-the-antiquated-4/</guid><description>&lt;p>智能指针（如 &lt;code>std::shared_ptr&lt;/code> 和 &lt;code>std::weak_ptr&lt;/code>）已经成为现代 C++ 编程的重要工具，尽管它们并不算是“新兴”的特性。在 C++11 标准之前，Boost 库就已经引入了智能指针的实现，特别是 &lt;code>boost::shared_ptr&lt;/code> 和 &lt;code>boost::weak_ptr&lt;/code>，它们为 C++11 的智能指针特性奠定了基础。因此，可以说智能指针在 C++ 中的发展历程已经有很长时间，而它们的引入极大地简化了内存管理和避免了常见的内存泄漏和悬挂指针问题。&lt;/p></description></item><item><title>std::visit实现运行时多态 - C++ for the Antiquated（之三）</title><link>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</link><pubDate>Sat, 04 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-polymorphism-cpp-for-the-antiquated-3/</guid><description>&lt;p>在传统的 &lt;strong>C++&lt;/strong> 中，&lt;strong>运行时多态&lt;/strong> 通常依赖于 &lt;strong>“接口 - 虚函数”&lt;/strong> 机制，通过抽象类、具体类与对象的设计来实现。这种多态方式通常被称为 &lt;strong>子类型多态&lt;/strong>（&lt;em>Subtype Polymorphism&lt;/em>）。&lt;/p></description></item><item><title>动手实现std::visit - C++ for the Antiquated（之二）</title><link>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</link><pubDate>Wed, 01 Jan 2025 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/std-visit-cpp-for-the-antiquated-2/</guid><description>&lt;h2 id="stdvariant-与-stdvisit">std::variant 与 std::visit&lt;/h2>
&lt;h3 id="stdvariant">std::variant&lt;/h3>
&lt;p>&lt;code>std::variant&lt;/code> 是 C++17 引入的类型安全的联合体（type-safe union），可以在多个预定义类型中存储任意一个值。与传统的 &lt;code>union&lt;/code> 不同，&lt;code>std::variant&lt;/code> 能够在运行时安全地检查当前存储的类型，避免未定义行为。&lt;/p></description></item><item><title>constexpr详解 - C++ for the Antiquated（之一）</title><link>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</link><pubDate>Sat, 28 Dec 2024 00:00:00 +0000</pubDate><guid>https://wizmann.top/posts/constexpr-cpp-for-the-antiquated-1/</guid><description>&lt;p>在这篇文章中，我们将深入讨论 C++ 中的常量表达式（&lt;code>constexpr&lt;/code>）及其与传统的&lt;code>const&lt;/code>常量的区别，并结合实际代码示例进行说明。同时，我们还会探讨&lt;code>constexpr&lt;/code>函数在模板编程中的应用，以及 C++11 之后对常量表达式的优化与扩展。&lt;/p></description></item><item><title>CPU缓存一致性与内存一致性（第二部分-内存一致性）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</link><pubDate>Sun, 01 Sep 2024 00:24:00 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</guid><description>&lt;h2 id="缓存一致性与内存一致性">缓存一致性与内存一致性&lt;/h2>
&lt;p>缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。&lt;/p>
&lt;p>缓存一致性协议（如 MESI 协议）用于解决多个处理器对相同内存位置进行访问和修改时的数据一致性问题。它确保各处理器的缓存中针对同一内存地址的副本保持一致，避免因缓存不同步而导致的数据错误。&lt;/p></description></item><item><title>CPU缓存一致性与内存一致性（第一部分-MESI协议）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order/</link><pubDate>Mon, 18 Mar 2024 23:21:35 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order/</guid><description>&lt;p>在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。
然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。&lt;/p></description></item><item><title>内存屏障初探</title><link>https://wizmann.top/posts/read-paper-barrier/</link><pubDate>Thu, 08 May 2014 19:05:26 +0000</pubDate><guid>https://wizmann.top/posts/read-paper-barrier/</guid><description>&lt;h2 id="原文地址">原文地址&lt;/h2>
&lt;p>&lt;a href="http://ridiculousfish.com/blog/posts/barrier.html">Barrier February 17th, 2007&lt;/a>&lt;/p>
&lt;h2 id="前言多核时代的挑战">前言：多核时代的挑战&lt;/h2>
&lt;p>尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。&lt;/p></description></item><item><title>alloca vs placement new</title><link>https://wizmann.top/posts/alloca-vs-placement-new/</link><pubDate>Mon, 07 Apr 2014 21:08:59 +0000</pubDate><guid>https://wizmann.top/posts/alloca-vs-placement-new/</guid><description>&lt;h2 id="what">WHAT?!&lt;/h2>
&lt;p>For most time, we use &lt;code>malloc&lt;/code> or &lt;code>new&lt;/code> for memory allocation, which will get it on &lt;em>heap&lt;/em>.&lt;/p>
&lt;p>However, access memory on &lt;em>heap&lt;/em> is not as effective as the memory on &lt;em>stack&lt;/em>, because the heap is &amp;ldquo;free-floating region of memory&amp;rdquo;. To the contrary, memory on &lt;em>stack&lt;/em> is managed by CPU automacitally and tightly. As a result, the further of the &lt;em>stack&lt;/em> compared to &lt;em>heap&lt;/em> is that we can have a faster read/write speed due to the fact that &lt;em>stack&lt;/em> memory is more likely to optimized by &lt;strong>CPU cache&lt;/strong>, in addition, it only uses a single instruction to allocate or deallocate &lt;em>stack&lt;/em> memory. Just like this.&lt;/p></description></item><item><title>使用新类型创建更人性化的代码</title><link>https://wizmann.top/posts/humanity-code-with-new-classes/</link><pubDate>Mon, 09 Dec 2013 15:01:00 +0000</pubDate><guid>https://wizmann.top/posts/humanity-code-with-new-classes/</guid><description>&lt;h2 id="啥">啥？&lt;/h2>
&lt;p>这篇文章讨论了如何通过新建并非”必要“的新类型，来产生更人性化的C++代码。&lt;/p>
&lt;p>关键词：&lt;/p>
&lt;ul>
&lt;li>RAII&lt;/li>
&lt;li>智能指针&lt;/li>
&lt;li>接口友好&lt;/li>
&lt;li>模板&lt;/li>
&lt;li>模板特化&lt;/li>
&lt;li>依赖编译器的缺省行为&lt;/li>
&lt;/ul>
&lt;p>对于C++的艺术，我只是个入门者。如果文章中有什么问题，欢迎大家指出，我会及时进行修改。&lt;/p></description></item></channel></rss>