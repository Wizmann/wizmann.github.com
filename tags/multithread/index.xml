<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Multithread on Maerlyn's Rainbow</title><link>https://wizmann.top/tags/multithread/</link><description>Recent content in Multithread on Maerlyn's Rainbow</description><generator>Hugo -- 0.146.0</generator><language>zh-CN</language><lastBuildDate>Sun, 01 Sep 2024 00:24:00 +0000</lastBuildDate><atom:link href="https://wizmann.top/tags/multithread/index.xml" rel="self" type="application/rss+xml"/><item><title>CPU缓存一致性与内存一致性（第二部分-内存一致性）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</link><pubDate>Sun, 01 Sep 2024 00:24:00 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order-2/</guid><description>&lt;h2 id="缓存一致性与内存一致性">缓存一致性与内存一致性&lt;/h2>
&lt;p>缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。&lt;/p>
&lt;p>缓存一致性协议（如 MESI 协议）用于解决多个处理器对相同内存位置进行访问和修改时的数据一致性问题。它确保各处理器的缓存中针对同一内存地址的副本保持一致，避免因缓存不同步而导致的数据错误。&lt;/p></description></item><item><title>CPU缓存一致性与内存一致性（第一部分-MESI协议）</title><link>https://wizmann.top/posts/cache-coherence-and-memory-order/</link><pubDate>Mon, 18 Mar 2024 23:21:35 +0000</pubDate><guid>https://wizmann.top/posts/cache-coherence-and-memory-order/</guid><description>&lt;p>在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。
然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。&lt;/p></description></item><item><title>内存屏障初探</title><link>https://wizmann.top/posts/read-paper-barrier/</link><pubDate>Thu, 08 May 2014 19:05:26 +0000</pubDate><guid>https://wizmann.top/posts/read-paper-barrier/</guid><description>&lt;h2 id="原文地址">原文地址&lt;/h2>
&lt;p>&lt;a href="http://ridiculousfish.com/blog/posts/barrier.html">Barrier February 17th, 2007&lt;/a>&lt;/p>
&lt;h2 id="前言多核时代的挑战">前言：多核时代的挑战&lt;/h2>
&lt;p>尽管80核心的浮点运算巨兽仍然遥不可及，多核处理器的时代已经到来。多核处理器的概念并非新鲜事物，在Power Macintosh 9500中就已经采用了多核处理器技术。现在，让我们深入理解多核处理器的内在机制。&lt;/p></description></item></channel></rss>