<!doctype html><html lang=zh-cn dir=auto><head><meta name=generator content="Hugo 0.146.0"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Maerlyn's Rainbow</title>
<meta name=description content><meta name=author content="wizmann"><link rel=canonical href=https://wizmann.top/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://wizmann.top/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wizmann.top/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wizmann.top/favicon-32x32.png><link rel=apple-touch-icon href=https://wizmann.top/apple-touch-icon.png><link rel=mask-icon href=https://wizmann.top/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://wizmann.top/index.xml><link rel=alternate hreflang=zh-cn href=https://wizmann.top/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://wizmann.top/"><meta property="og:site_name" content="Maerlyn's Rainbow"><meta property="og:title" content="Maerlyn's Rainbow"><meta property="og:locale" content="zh-CN"><meta property="og:type" content="website"><meta name=twitter:card content="summary"><meta name=twitter:title content="Maerlyn's Rainbow"><meta name=twitter:description content><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"Maerlyn's Rainbow","url":"https://wizmann.top/","description":"","logo":"https://wizmann.top/favicon.ico","sameAs":[]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wizmann.top/ accesskey=h title="Maerlyn's Rainbow (Alt + H)">Maerlyn's Rainbow</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=first-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2015-04-25 11:17:01 Title: 用C++实现一个通用的sort函数 Tags: C++, sort Slug: a-common-sorting-function-with-cpp
问题 用C++实现一个尽可能通用的sort函数
分析 一个通用的sort函数应该包含以下要点：
确实可以排序(LOL) 可以应对C-style array和C++-style container的排序需求 可以应用于任意random access container 可以使用用户自定义的排序函数 / 仿函数 / lambda函数 实现 为了与std中的通用函数做区别，这里的命名规则，包括类型与函数，都在前面加了"my"以示区别。可能与标准的命名法有出入，所以仅做示例用。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/a-common-sorting-function-with-cpp/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2021-11-18 Title: A2B Game Solutions Tags: game, a2b, solution Slug: A2B
A2B is a “zach-like” programming game, which let you to use a very simple “programming language” to solve different problems for strings.
Personally, I highly recommand this game along with “Shenzhen IO” and “Factorio” as an beginner tutorial for anyone who wants to be a software engineer.
Spoiler Alert ** The following article includes huge spoilers for A=B Game. **
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/a2b/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-04-07 21:08:59 Title: “alloca” vs “placement new” Tags: cpp, memory, stack, heap, allocate, alloca, c++ Slug: alloca-vs-placement-new
WHAT?! For most time, we use malloc or new for memory allocation, which will get it on heap.
However, access memory on heap is not as effective as the memory on stack, because the heap is “free-floating region of memory”. To the contrary, memory on stack is managed by CPU automacitally and tightly. As a result, the further of the stack compared to heap is that we can have a faster read/write speed due to the fact that stack memory is more likely to optimized by CPU cache, in addition, it only uses a single instruction to allocate or deallocate stack memory. Just like this.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/alloca-vs-placement-new/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2021-04-08 Title: 利用Arduino制作脚踏板Fn层开关 Tags: Arduino, ahk, autohotkey, fn-layer, keyboard Slug: Arduino-foot-pedal-for-fn-layer status: draft
背景 之前焊了两个客制化键盘，一个是ErgoDone，一个是仿minila配列的60键盘。这两个键盘的共同特点是双手大拇指各有一个额外的开关，我将其做为Fn层的开关，用来开启两个fn层：Vim和NumPad（是啥并不重要，可以理解为功能键的重映射）。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/arduino-foot-pedal-for-fn-layer/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2024-06-15 Title: 利用凸组合求解最优值（AtCoder abc356_g Freestyle 题解） Tags: AtCoder, Solution, Computational geometry, geometry Slug: AtCoder-abc356g-solution
题目大意 我们已经学会了 N 种不同的游泳技术。对于每种技术 $i$ ，每秒前进 $A_{i}$ 米，并消耗 $B_{i}$ 单位的体力。注意，我们可以任意调整每种技术的使用时长 $t_i$ ，其中 $t_i$ 是一个实数 现在，我们面临 $Q$ 次询问，每次询问指定距离终点的距离 $C_j$ 和体力限制 $D_j$ 。我们需要确定是否在体力限制下到达终点。如果可以，求出所需的最短时间。 （符号使用与原题略有差异） 数据规模： $1 &lt;= N, Q &lt;= 2 \times 10^5$ $1 &lt;= A_i, B_i, C_j, D_j &lt;= 10^9$ 题目分析 鉴于数据规模庞大，并且时间 $t_i$ 是实数，传统的动态规划方法不适用。在处理每次询问时，我们需要同时考虑距离、体力和时间三个变量。一个有效的方法是转化这些变量为单位时间内的距离（即速度）和单位时间内的体力消耗。如果单位时间内的距离大于单位时间内的体力消耗，那么理论上我们可以到达终点。接下来的目标是在所有可能的情况中找到最大的速度，作为最终答案。 以两种游泳技术（N=2）为例进行具体分析。假设在总游泳时间中，技术1和技术2的使用时间比例分别为 $p$ 和 $1-p$ （其中 $0 \leq p \leq 1$ ）。在这种情况下，每秒前进距离为 $A_1 \cdot p + A_2 \cdot (1 - p)$ ，体力消耗为 $B_1 \cdot p + B_2 \cdot (1 - p)$ 。
从几何角度看，组合这两种游泳技术的速度与体力消耗 $(A_x, B_x)$ 为 $(A_1, B_1) \cdot p$ 和 $(A_2, B_2) \cdot (1 - p)$ 的向量和，其可能的取值位于以 $(A_1, B_1)$ 和 $(A_2, B_2)$ 为端点的线段上的任意一点。
对于具体询问 $(C_i, D_i)$ ，为了确保“在到达终点之前不能耗尽体力”，我们需要找到的点必须位于斜率为 $D_i/C_i$ 的射线与x轴之间的夹角内。通过这种方式，我们可以确定是否有可能在给定的体力限制下完成指定的距离，并找到速度最快的点。 对于多种游泳技术的组合，情况会更复杂一些。我们将所有游泳技术视为一组向量 $(A_1, B_1), (A_2, B_2), \ldots, (A_n, B_n)$ 和一组对应的权重 $p_1, p_2, \ldots, p_n$ ，其中 $\sum_{i=1}^n p_i = 1$ 并且每个 $p_i \geq 0$ ，那么这些向量的加权和 $\sum_{i=1}^n p_i (A_i, B_i)$ 定义了一个在二维空间中的凸多边形，称为这些向量的凸包。 我们可以用稍微详细一点的数学来解释这一过程： 向量的线性组合 首先，定义向量 $\mathbf{v}_1, \mathbf{v}_2, \ldots, \mathbf{v}_n$ 在二维空间中的位置。每个向量 $\mathbf{v}i$ 可以表示为从原点到点 $(x_i, y_i)$ 的箭头。 当我们考虑这些向量的线性组合时： $\sum{i=1}^n \lambda_i \mathbf{v}_i$
其中，每个 $\lambda_i$ 是一个实数系数，我们实际上在描述一个新向量，这个向量是通过在每个原向量上“拉伸”或“压缩”（取决于 $\lambda_i$ 的正负和大小），然后将结果相加得到的。这种线性组合在几何上定义了一个点的集合。 凸组合与凸多边形 当这些系数 $\lambda_i$ 都非负且和为1（即 $\lambda_i \geq 0$ 且 $\sum_{i=1}^n \lambda_i = 1$ ），我们称这样的线性组合为凸组合。凸组合具有重要的几何特性：它定义的点一定位于这些向量端点所形成的凸多边形内部或边界上。 凸多边形的形成 边界的构成：如果你只考虑两个向量 $\mathbf{v}_1$ 和 $\mathbf{v}_2$ ，那么它们的凸组合会形成一条连接两点 $(x_1, y_1)$ 和 $(x_2, y_2)$ 的线段。这条线段是直线，因为所有的组合点都直接通过两点间的直线路径互相连结。 扩展到多个向量：当你有三个或更多向量时，通过考虑任意两个向量的所有凸组合（即所有可能的线段），然后再将这些线段的结果进行组合，最终你将覆盖一个多边形区域。这个区域是由最外围的向量点定义的，这些点在几何上构成了凸多边形的顶点。 数学描述：在数学上，这个区域可以看作是所有可能的 $\lambda_i$ 值（符合凸组合条件）下的 $\sum_{i=1}^n \lambda_i \mathbf{v}_i$ 的集合。由于每个 $\lambda_i$ 都保证非负且和为1，凸多边形的任意内部或边界点都可以通过这样的组合表示，且不会有任何点“凸出”于这个定义的多边形之外，这正是凸性质的体现。 类似于仅涉及两个点的简单情况，为了解决问题，我们需要找到凸多边形内与 $x$ 轴之间斜率为 $D_i/C_i$ 的射线包围的区域（即凸包中的深色部分）。我们进一步需要找出该部分中在 $x$ 轴上取得最大值的点。 代码实现 - 并不高效 实现步骤 求出所有 $(A_i, B_i)$ 点所构成的凸包 对于每一个查询Q，从零点画出斜率为 $D_i / C_i$ 的射线 如果凸包位于射线的“上方”，则没有满足条件的情况，返回-1 如果凸包位于射线的“下方”或与射线相交，则需要找到凸包在射线“下方” $B_i$ 值最大的点。意味着这个组合可以成功到达终点，并且平均速度最快 复杂度分析 对于每一次查询，我们都要遍历凸包的所有边（即“凸包壳”）与射线的交点。时间复杂度 $O(n)$ 。 对于所有查询，时间复杂度为 $O(q * n)$ ，明显是会超时的。 优化的可能性 易知，并不是凸包的所有部分都能得出最优解。与原点连线斜率越小的点，其“性价比”越高，即在消耗更少的体力的同时，可以游更远的距离。 同时，如果凸包内部的某一个点满足条件，则总有位于凸包壳上面的另一个点与它更优。同样，如果凸包壳上有两个点的斜率相同，那么 $B_i$ 值更大的点是更优的。
所以优化的目标在于找到一系列凸包壳，使其可以只保留最优解所在的边，并且排除所有非最优的情况。
我们可以从“性价比”最好的点开始，因为对于一个查询，如果所需要的“性价比”高于我们所有的选项，那么一定没有解。
然后我们逆时针遍历所有点，直到找到 $B_i$ 值最大的点，因为对于一个查询，在满足“性价比”的情况下，这是我们能给出的，消耗时间最小的答案。 实现方案1: 我们可以使用凸包算法，找到凸包壳，按照上文所述的方法，找到斜率最小（所谓“性价比最高”）的点，然后逆时针遍历到 $B_i$ 最大的点。这些点必然以斜率从小到大排序。 对于一个查询 $(C_i, D_i)$ ，我们将其视为斜率为 $D_i / C_i$ 的射线。我们使用二分法，找到与该射线相交的凸包壳边。再通过联立方程方法找到其交点 $(A_x, B_x)$ ，其中 $A_x$ 即为满足查询条件的最大游泳速度。 实现方案2： 方案2与方案1类似，只是在查找凸包的时候，加入点 $(0, 0)$ 与点 $(max(A_i), INF)$ 。如下图所示，加入这两个点之后，非最优解的点都被包含在了凸包（蓝色）内部。我们在找到凸包之后，将加入的点删除，并按方案1的方法排序。后续再进行二分，以及求交点等操作。 代码实现 我写的 （抄了别人的凸包算法） 官方题解 感悟 别调计算几何，会变的不幸（</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/atcoder-abc356g-solution/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2017-10-11 21:12:15 Title: Windows Azure Storage Made Simple Tags: Microsoft, Azure, WAS, 分布式系统, CAP, Consistency, 一致性 Slug: azure-storage-made-simple
加机器就是一把梭 没有什么问题是加一千台机器解决不了的，如果有，就再加一千台。 —— 《21天精通分布式系统》
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/azure-storage-made-simple/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2021-08-17 Title: 浅淡TCP BBR Tags: tcp, networking, bbr Slug: bbr-intro
背景 在一对跨地域的机器（美国&lt;->香港），使用TCP（Cubic拥塞控制算法）通信throughput最高2MB/s，丢包率0.02%。使用UDP通信throughput最高能达到140MB/s。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/bbr-intro/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2015-04-25 00:54:08 Title: Beauty-of-Programming 2015 Qualification Round Tutorial Tags: algorithm, 算法, 题解, Microsoft Slug: beauty-of-programming-2015-qualification-round status: draft
A. 2月29日 (Feb. 29th) Description Given a starting date and an ending date. Count how many Feb. 29th are between the given dates.
Solution The easiest way, of course, the brute force, which is quite simple with Python using the datetime lib.
However, it’s not an effective way for the problem.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/beauty-of-programming-2015-qualification-round/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2017-12-18 00:49:00 Title: Bw-Tree：在新硬件平台上的新B-Tree Tags: bw-tree, azure, storage, b-tree Slug: bw-tree
ARS 与 Bw-Tree nosql数据库从本质上说，都属于ARS（Atomic Record Stores，“原子记录存储”）。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/bw-tree/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2024-03-18 23:21:35 Title: CPU缓存一致性与内存一致性（第一部分-MESI协议） Tags: cpp, memory-barrier, multithread, thread, MESI Slug: cache-coherence-and-memory-order
在对称多处理系统（Symmetric Multiprocessing, SMP）中，一个变量（或内存位置）可以同时存在于多个CPU的缓存行中。为了提供完美的用户级抽象，任何对一个或多个变量的修改都应该被强制同步，以确保其它CPU的缓存得到更新。 然而，在实现上，由于CPU之间通常通过总线互联，它们不能同时对多个缓存进行写操作。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cache-coherence-and-memory-order-1/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2024-09-01 00:24:00 Title: CPU缓存一致性与内存一致性（第二部分-内存一致性） Tags: cpp, memory-barrier, multithread, litmus, herd7 Slug: cache-coherence-and-memory-order-2
缓存一致性与内存一致性 缓存一致性和内存一致性是多处理器系统中的两个不同概念，它们解决的是不同类型的内存访问问题。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cache-coherence-and-memory-order-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2013-11-27 Title: Codeforces Round #215 (Div. 2)不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-215-div-2
A. Sereja and Coat Rack 傻逼才错的题。不幸中枪。
没什么可说的。直接看代码就好。
B. Sereja and Suffixes 关键思想在于统计A[i…n-1]中有多少互不相同的数。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-215-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2013-12-9 23:02 Title: Codeforces Round #218 (Div. 2)不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-218-div-2
A. K-Periodic Array 将Array切片，然后按位统计某一位上1的个数C(1)和2的个数C(2)。然后在这一位上的操作数就为M = min(C(1), C(2))。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-218-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2013-12-25 19:05 Title: Codeforces Round #221 (Div. 2)不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-221-div-2
A. Lever 水题，杠杆原理。
用^把字符串分割开。然后分别计算两边的重量即可。
#Result: Dec 24, 2013 6:04:41 PM Wizmann A - Lever Python 2 Accepted 312 ms 4200 KB def calc(ss): res = 0 p = 1 for item in ss: if item != '=': t = int(item) res += t * p p += 1 return res s = raw_input() (a, b) = s.split('^') left = calc(a[::-1]) right = calc(b) if left == right: print 'balance' elif left > right: print 'left' else: print 'right' B. I.O.U. 水题，算出每个人负债和贷出（这个词的现学的~）的绝对值差。
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-221-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-01-18 14:47 Title: Codeforces Round #223 (Div. 2) 不完全不正确题解 Tags: codeforces, algorithm, 算法, 题解 Slug: cf-223-div-2
由于大号已经进Div. 1了，所以接下来的几场Div. 2都是用小号做的。
等有实力切D题了，再去打一区。（弱
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-223-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-04-08 14:39:11 Title: Codeforces Round #240 (Div. 2) Tutorials and Solutions(incomplete and incorrect) Tags: codeforces, algorithm, 算法, 题解 Slug: cf-240-div-2
Overview It has been months that I didn’t participate in the contest on CF, now I’m back. :)
This round of contest makes me confused that the problem B and C is a little bit too twisted, if you can’t catch the vital point, you will get a lot of WAs in the end.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-240-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-04-30 17:39 Title: Codeforces Round #242 (Div. 2) Tutorials and Solutions Tags: codeforces, algorithm, 算法, 题解 Slug: cf-242-div-2
A. Squats Trun x => X or X => x to make the number of ‘x’ is equal to the number of ‘X’.
n = int(raw_input()) hamsters = [c for c in raw_input()] sits = hamsters.count('x') stands = hamsters.count('X') if sits == stands: print 0 print ''.join(hamsters) else: if sits > stands: num = sits - n/2 key = 'x' else: num = stands - n/2 key = 'X' print num for i, c in enumerate(hamsters): if c == key: hamsters[i] = c.swapcase() num -= 1 if not num: break print ''.join(hamsters) B. Megacity Binary search.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-242-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2014-06-21 19:24:37 Title: Codeforces Round #253 Tutorial Tags: codeforces, algorithm Slug: cf-253
443A - Anton and Letters Simple and easy, solved by two lines of python code.
ls = filter(lambda y: y, map(lambda x: x.strip(), raw_input()[1:-1].split(","))) print len(set(ls)) 443B - Kolya and Tandem Repeat Brute force. Just enumerate the beginning and the end of the substring, and check if that substring is tandem repeat.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;algorithm> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x string str; int k; int main() { freopen("input.txt", "r", stdin); input(str >> k); for (int i = 0; i &lt; k; i++) { str += '?'; } int len = str.length(); int ans = 0; for (int i = 0; i &lt; len; i++) { if (str[i] == '?') { break; } for (int j = 1; i + j &lt; len; j += 2) { int slip = (j + 1) / 2; for (int k = 0; k &lt; slip; k++) { if (str[i + k] == str[i + k + slip] || str[i + k + slip] == '?') { /* pass */; } else { goto fail; } } ans = max(ans, j + 1); fail: /*pass*/; } } print(ans); return 0; } 442A - Borya and Hanabig Because Borya knows about the color and value of all his cards, he just need to distinguish each card from the others.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-253/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2015-02-16 21:16:30 Title: Codeforces Round #288 (Div. 2) Tags: codeforces, algorithm, 算法, 题解 Slug: cf-288-div-2
A. Pasha and Pixels Brute force.
There are multiple ways to form a 2*2 square at one single step.
So at every step, we have to check the neighbours of pixel that is colored black.
#include &lt;cstdio> #include &lt;cstdlib> #include &lt;cstring> #include &lt;iostream> #include &lt;vector> using namespace std; #define print(x) cout &lt;&lt; x &lt;&lt; endl #define input(x) cin >> x const int SIZE = 1024 + 123; const int mx[] = {0, 1, 0, 1}; const int my[] = {0, 0, 1, 1}; const int MOVE = 4; int mp[SIZE][SIZE]; int n, m, k; bool isBlackBlock(int y, int x) { int cnt = 0; for (int i = 0; i &lt; MOVE; i++) { int ny = y + my[i]; int nx = x + mx[i]; if (ny >= 0 && ny &lt; n && nx >= 0 && nx &lt; m && mp[ny][nx]) { cnt++; } } return cnt == MOVE; } int main() { int y, x; input(n >> m >> k); memset(mp, 0, sizeof(mp)); int ans = 0; for (int i = 0; i &lt; k; i++) { input(y >> x); x--; y--; mp[y][x] = 1; bool flag = false; for (int j = 0; j &lt; MOVE; j++) { flag |= isBlackBlock(y - my[j], x - mx[j]); } if (flag) { ans = i + 1; break; } } print(ans); return 0; } B. Anton and currency you all know At first, you have to understand the questions accurately.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-288-div-2/></a></article><article class=post-entry><header class=entry-header><h2 class=entry-hint-parent></h2></header><div class=entry-content><p>Date: 2015-02-16 21:16:31 Title: Codeforces Round #289 (Div. 2) Tutorial Tags: codeforces, algorithm, 算法, 题解 Slug: cf-289-div-2
A. Maximum in Table Simulation.
n = int(raw_input()) g = [[1 for i in xrange(n)] for j in xrange(n)] for i in xrange(1, n): for j in xrange(1, n): g[i][j] = g[i - 1][j] + g[i][j - 1] print g[n - 1][n - 1] B. Painting Pebbles Reading comperhension & Constructive.
The key point of this problem is abs(b(i, c) - b(j, c)) &lt;= 1.
...</p></div><footer class=entry-footer>wizmann</footer><a class=entry-link aria-label="post link to " href=https://wizmann.top/posts/cf-289-div-2/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://wizmann.top/page/2/>&nbsp;&nbsp;»</a></nav></footer></main><footer class=footer><span>&copy; 2025 <a href=https://wizmann.top/>Maerlyn's Rainbow</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>